{
    "version": "https://jsonfeed.org/version/1",
    "title": "Cubic Y³ • All posts by \"course notes\" category",
    "description": "Notes, CTF, DIY, thoughts and waifus.\n\nI'm CubicYYY, an undergraduate student majoring in Computer Science at Zhejiang University.\nLearning: Electric guitar\n❤❤❤ CTF, toy projects, anime\n✖✖✖ Technological supremacy\nResume is [here](https://latexonline.cc/compile?git=https://github.com/cubicYYY/resume&target=resume.tex&command=xelatex).",
    "home_page_url": "http://cubicy.icu",
    "items": [
        {
            "id": "http://cubicy.icu/compiler-construction-principles/",
            "url": "http://cubicy.icu/compiler-construction-principles/",
            "title": "编译原理课程笔记",
            "date_published": "2024-04-13T17:10:20.000Z",
            "content_html": "<h1 id=\"编译原理\"><a href=\"#编译原理\" class=\"headerlink\" title=\"编译原理\"></a>编译原理</h1><h2 id=\"Part-0-课程信息\"><a href=\"#Part-0-课程信息\" class=\"headerlink\" title=\"Part 0: 课程信息\"></a>Part 0: 课程信息</h2><p>使用教材：<em>Modern Compiler Implementation in C</em>, Andrew W. Appel （A.K.A 虎书）</p>\n<p>相关课程：</p>\n<ul>\n<li><a href=\"http://web.stanford.edu/class/cs143/\">Stanford课程主页</a></li>\n<li><a href=\"https://github.com/6035/sp21\">MIT课程主页</a></li>\n<li><a href=\"https://inst.eecs.berkeley.edu/~cs164/fa21/\">UCBerkeley课程主页</a></li>\n</ul>\n<p>分数构成：</p>\n<ul>\n<li>课程作业(课后小型练习题) &#x3D; 10%</li>\n<li>随堂测验&#x3D; 10%</li>\n<li>期中考试&#x3D; 15%</li>\n<li>综合性课程设计&#x3D; 25%</li>\n<li>期末考试&#x3D; 40%</li>\n</ul>\n<p>前置知识：计算理论（笔记参考<a href=\"https://note.tonycrane.cc/cs/tcs/toc/\">https://note.tonycrane.cc/cs/tcs/toc/</a>）</p>\n<h2 id=\"Part-1-简介\"><a href=\"#Part-1-简介\" class=\"headerlink\" title=\"Part 1: 简介\"></a>Part 1: 简介</h2><p>基本概念：</p>\n<ul>\n<li>中间代码&#x3D;Intermediate Code</li>\n<li>词法分析&#x3D;Lexing&#x2F;Scanning&#x2F;LexicalAnalysis</li>\n<li>语法分析&#x3D;Parsing&#x2F;SyntaxAnalysis</li>\n<li>中间表示&#x3D;IR&#x3D;Intermediate Representation</li>\n<li>树型中间表示&#x3D;IR Tree</li>\n<li>前端&#x3D;，后端&#x3D;<br>略。</li>\n</ul>\n<h2 id=\"Part-2-词法分析\"><a href=\"#Part-2-词法分析\" class=\"headerlink\" title=\"Part 2: 词法分析\"></a>Part 2: 词法分析</h2><h3 id=\"词法分析概述\"><a href=\"#词法分析概述\" class=\"headerlink\" title=\"词法分析概述\"></a>词法分析概述</h3><p>将输入字符串识别为有意义的子串。（把基本单元划分好）<br>(Token单词, Lexeme词素(可选)) e.g. (IF, ) (ELSE, ) (BINARY_OP, &gt;&#x3D;) (UNARY_OP, &amp;)</p>\n<h3 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h3><p>Regex Expression &#x3D; RE<br>运算：连接concatenation + 幂Power<br>e.g.: $ ab(a|b)^3c^* $<br>下略。</p>\n<h3 id=\"有穷自动机\"><a href=\"#有穷自动机\" class=\"headerlink\" title=\"有穷自动机\"></a>有穷自动机</h3><p>相关概念：</p>\n<ul>\n<li>NFA&#x2F;DFA：略</li>\n<li>子集构造法subsetconstruction(NFA-&gt;DFA)<ul>\n<li>DFA的每个状态是NFA的状态集合的一个子集</li>\n<li>读了输入ai后NFA能到达的所有状态：s1,s2,…,sk，则DFA到达一个状态，对应于NFA的{s1,s2,…,sk}</li>\n<li>NFA状态(集)上的一些操作定义<ul>\n<li>ε-closure(s):&#x3D; NFA状态s的ε-闭包:s经ε转换所能到达的状态集合</li>\n<li>ε-closure(T):&#x3D; T中所有状态的ε-闭包的并集,即 $ \\cup_{s\\in T}{\\epsilon-closure(s)} $</li>\n</ul>\n</li>\n<li>过程<ol>\n<li>NFA的初始状态的ε-闭包对应于DFA的初始状态</li>\n<li>针对每个DFA状态(对应NFA状态子集A)，求输入每个ai后能到达的NFA状态的ε-闭包并集（NFA从状态集A出发，读入ai后能到达的状态集合） $$ S&#x3D;\\epsilon-closure(move(A,a_i)) $$</li>\n<li>该集合S要么对应于DFA中的一个已有状态，要么是一个要新加的DFA状态</li>\n<li>逐步构造DFA的状态转换表，直到不动点</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>Thumpson构造法(RE-&gt;NFA)：略</li>\n</ul>\n<h3 id=\"词法分析器自动生成\"><a href=\"#词法分析器自动生成\" class=\"headerlink\" title=\"词法分析器自动生成\"></a>词法分析器自动生成</h3><ul>\n<li>DFA最小化（-&gt;状态最小的DFA，在同构意义下唯一）</li>\n<li>可区分状态：存在串s使其分别从状态s、t出发，一个接受串s，一个拒绝串s，则s与t可区分</li>\n<li>步骤：<ol>\n<li>初始等价类里，仅有接受状态集合和非接受状态集合</li>\n<li>不断用所有可能的输入应用于各个集合。只有集合G的每个状态读入同一字符后，都落入（包含在）相同的某个集合，那么就不用细分</li>\n<li>不断重复2直到不动点</li>\n<li>此时等价类中的每个集合即对应最小DFA的一个状态。在其上可以轻松构建min-DFA，该过程是trivial的。</li>\n</ol>\n</li>\n<li>可以每个组中选择一个状态作代表。</li>\n</ul>\n<h3 id=\"Lex工具\"><a href=\"#Lex工具\" class=\"headerlink\" title=\"Lex工具\"></a>Lex工具</h3><p>通常和Yacc一起使用，生成编译器的前端。</p>\n<ul>\n<li>声明部分<ul>\n<li>常量：常数标识符</li>\n<li>正则规则定义</li>\n</ul>\n</li>\n<li>转换规则模式{动作}<ul>\n<li>模式&#x3D;正则表达式</li>\n<li>动作&#x3D;识别到相应模式时应调用的处理函数（一般以C语言代码表示）</li>\n</ul>\n</li>\n<li>辅助函数：动作中使用的函数</li>\n</ul>\n<p>解决冲突：最长匹配，较前规则优先</p>\n<h2 id=\"Part-2-词法分析（1）\"><a href=\"#Part-2-词法分析（1）\" class=\"headerlink\" title=\"Part 2: 词法分析（1）\"></a>Part 2: 词法分析（1）</h2><p><em>&gt;&gt;&gt; To be continued…</em></p>\n",
            "tags": [
                "Compiler",
                "Computer Science",
                "On Going"
            ]
        }
    ]
}