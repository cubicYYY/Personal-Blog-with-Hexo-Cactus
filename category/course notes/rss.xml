<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Cubic Y³ • Posts by &#34;course notes&#34; category</title>
        <link>http://cubicy.icu</link>
        <description>Notes, CTF, DIY, thoughts and waifus.

I&#39;m CubicYYY, an undergraduate student majoring in Computer Science at Zhejiang University.
Learning: Electric guitar
❤❤❤ CTF, toy projects, anime
✖✖✖ Technological supremacy
Resume is [here](https://latexonline.cc/compile?git=https://github.com/cubicYYY/resume&amp;target=resume.tex&amp;command=xelatex).</description>
        <language>zh-CN</language>
        <pubDate>Sun, 14 Apr 2024 01:10:20 +0800</pubDate>
        <lastBuildDate>Sun, 14 Apr 2024 01:10:20 +0800</lastBuildDate>
        <category>Misc</category>
        <category>Write-Up</category>
        <category>出题</category>
        <category>English</category>
        <category>CISCN</category>
        <category>web</category>
        <category>Hackergame</category>
        <category>Overclocking</category>
        <category>SchoolBus</category>
        <category>Rust</category>
        <category>Lifetime</category>
        <category>Code</category>
        <category>Programming</category>
        <category>冰菓</category>
        <category>古籍研究社</category>
        <category>Treap</category>
        <category>Stack</category>
        <category>BST</category>
        <category>图论</category>
        <category>Kruskal</category>
        <category>Splay</category>
        <category>持久化</category>
        <category>线段树</category>
        <category>数链剖分</category>
        <category>树状数组</category>
        <category>LCA</category>
        <category>分块</category>
        <category>哈希</category>
        <category>Phar</category>
        <category>反序列化</category>
        <category>PHP</category>
        <category>Compiler</category>
        <category>Computer Science</category>
        <category>On Going</category>
        <category>NLP</category>
        <category>Fuzzing</category>
        <category>AFL</category>
        <category>Math</category>
        <category>Translation</category>
        <category>Yoneda Lemma</category>
        <category>Miscellaneous</category>
        <item>
            <guid isPermalink="true">http://cubicy.icu/compiler-construction-principles/</guid>
            <title>编译原理课程笔记（All-in-One速通版）</title>
            <link>http://cubicy.icu/compiler-construction-principles/</link>
            <category>Compiler</category>
            <category>Computer Science</category>
            <category>On Going</category>
            <pubDate>Sun, 14 Apr 2024 01:10:20 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;编译原理Speed-run-any&#34;&gt;&lt;a href=&#34;#编译原理Speed-run-any&#34; class=&#34;headerlink&#34; title=&#34;编译原理Speed-run any%&#34;&gt;&lt;/a&gt;编译原理&lt;code&gt;Speed-run any%&lt;/code&gt;&lt;/h1&gt;&lt;p&gt;以&lt;strong&gt;快速复习&lt;/strong&gt;为目的。&lt;br&gt;文中部分图片与文字来自于姚老师(ZJU, pyaoaa at zju.edu.cn)&lt;/p&gt;
&lt;h2 id=&#34;Part-0-课程信息&#34;&gt;&lt;a href=&#34;#Part-0-课程信息&#34; class=&#34;headerlink&#34; title=&#34;Part 0: 课程信息&#34;&gt;&lt;/a&gt;Part 0: 课程信息&lt;/h2&gt;&lt;p&gt;使用教材：&lt;em&gt;Modern Compiler Implementation in C&lt;/em&gt;, Andrew W. Appel （A.K.A 虎书）&lt;/p&gt;
&lt;p&gt;相关课程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://web.stanford.edu/class/cs143/&#34;&gt;Stanford课程主页&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/6035/sp21&#34;&gt;MIT课程主页&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://inst.eecs.berkeley.edu/~cs164/fa21/&#34;&gt;UCBerkeley课程主页&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分数构成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;课程作业(课后小型练习题) &amp;#x3D; 10%&lt;/li&gt;
&lt;li&gt;随堂测验&amp;#x3D; 10%&lt;/li&gt;
&lt;li&gt;期中考试&amp;#x3D; 15%&lt;/li&gt;
&lt;li&gt;综合性课程设计&amp;#x3D; 25%&lt;/li&gt;
&lt;li&gt;期末考试&amp;#x3D; 40% （斩杀线40&amp;#x2F;100）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前置知识：计算理论（笔记参考&lt;a href=&#34;https://note.tonycrane.cc/cs/tcs/toc/&#34;&gt;https://note.tonycrane.cc/cs/tcs/toc/&lt;/a&gt;）&lt;/p&gt;
&lt;h2 id=&#34;Part-1-简介&#34;&gt;&lt;a href=&#34;#Part-1-简介&#34; class=&#34;headerlink&#34; title=&#34;Part 1: 简介&#34;&gt;&lt;/a&gt;Part 1: 简介&lt;/h2&gt;&lt;p&gt;基本概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中间代码&amp;#x3D;Intermediate Code&lt;/li&gt;
&lt;li&gt;词法分析&amp;#x3D;Lexing&amp;#x2F;Scanning&amp;#x2F;LexicalAnalysis&lt;/li&gt;
&lt;li&gt;语法分析&amp;#x3D;Parsing&amp;#x2F;SyntaxAnalysis&lt;/li&gt;
&lt;li&gt;中间表示&amp;#x3D;IR&amp;#x3D;Intermediate Representation&lt;/li&gt;
&lt;li&gt;树型中间表示&amp;#x3D;IR Tree&lt;/li&gt;
&lt;li&gt;前端，后端&lt;br&gt;略。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Part-2-词法分析&#34;&gt;&lt;a href=&#34;#Part-2-词法分析&#34; class=&#34;headerlink&#34; title=&#34;Part 2: 词法分析&#34;&gt;&lt;/a&gt;Part 2: 词法分析&lt;/h2&gt;&lt;h3 id=&#34;词法分析概述&#34;&gt;&lt;a href=&#34;#词法分析概述&#34; class=&#34;headerlink&#34; title=&#34;词法分析概述&#34;&gt;&lt;/a&gt;词法分析概述&lt;/h3&gt;&lt;p&gt;将输入字符串识别为有意义的子串。（把基本单元划分好）&lt;br&gt;(Token单词, Lexeme词素(可选)) e.g. (IF, ) (ELSE, ) (BINARY_OP, &amp;gt;&amp;#x3D;) (UNARY_OP, &amp;amp;)&lt;/p&gt;
&lt;h3 id=&#34;正则表达式&#34;&gt;&lt;a href=&#34;#正则表达式&#34; class=&#34;headerlink&#34; title=&#34;正则表达式&#34;&gt;&lt;/a&gt;正则表达式&lt;/h3&gt;&lt;p&gt;Regex Expression &amp;#x3D; RE&lt;br&gt;运算：连接concatenation + 幂Power&lt;br&gt;e.g.: $ ab(a|b)^3c^* $&lt;br&gt;下略。&lt;/p&gt;
&lt;h3 id=&#34;有穷自动机&#34;&gt;&lt;a href=&#34;#有穷自动机&#34; class=&#34;headerlink&#34; title=&#34;有穷自动机&#34;&gt;&lt;/a&gt;有穷自动机&lt;/h3&gt;&lt;p&gt;相关概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;NFA&amp;#x2F;DFA：略&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;子集构造法subsetconstruction(NFA-&amp;gt;DFA)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DFA的每个状态是NFA的状态集合的一个子集&lt;/li&gt;
&lt;li&gt;读了输入ai后NFA能到达的所有状态：s1,s2,…,sk，则DFA到达一个状态，对应于NFA的{s1,s2,…,sk}&lt;/li&gt;
&lt;li&gt;NFA状态(集)上的一些操作定义&lt;ul&gt;
&lt;li&gt;ε-closure(s):&amp;#x3D; NFA状态s的ε-闭包&amp;#x3D;s经ε转换所能到达的状态集合&lt;/li&gt;
&lt;li&gt;ε-closure(T):&amp;#x3D; T中所有状态的ε-闭包的并集,即 $ \cup_{s\in T}{\epsilon-closure(s)} $&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;过程&lt;ol&gt;
&lt;li&gt;NFA的初始状态S的ε-闭包对应于DFA的初始状态&lt;/li&gt;
&lt;li&gt;针对每个DFA状态(对应NFA状态子集A)，求输入每个可能输入ai后能到达的NFA状态的ε-闭包并集（NFA从状态集A出发，读入ai后能到达的状态集合） $$ S&amp;#x3D;\epsilon-closure(move(A,a_i)) $$&lt;/li&gt;
&lt;li&gt;该集合S要么对应于DFA中的一个已有状态，要么令其成为一个新加的DFA状态&lt;/li&gt;
&lt;li&gt;重复上述两步，逐步构造DFA的状态转换表（每个状态集合S与每个输入ai），直到不动点（不再新增状态，且状态转移表完全求出，即对任一状态集合S已知分别接受所有输入ai将分别转移到何状态）&lt;/li&gt;
&lt;li&gt;在DFA中，只要状态集合S包含至少一个原来NFA中的终止状态，就把S标记为终止状态&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;示例（TODO）&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;/compiler-construction-principles/nfa2dfa.png&#34; alt=&#34;nfa2dfa&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Thumpson构造法(RE-&amp;gt;NFA)：略&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;词法分析器自动生成&#34;&gt;&lt;a href=&#34;#词法分析器自动生成&#34; class=&#34;headerlink&#34; title=&#34;词法分析器自动生成&#34;&gt;&lt;/a&gt;词法分析器自动生成&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;DFA最小化（-&amp;gt;状态最小的DFA，在同构意义下唯一）&lt;/li&gt;
&lt;li&gt;可区分状态：存在串s使其分别从状态s、t出发，一个接受串s，一个拒绝串s，则s与t可区分&lt;/li&gt;
&lt;li&gt;步骤：&lt;ol&gt;
&lt;li&gt;初始等价类，仅由接受状态集合和非接受状态两个集合构成&lt;/li&gt;
&lt;li&gt;用所有可能的输入ai应用于各个集合（走一步）&lt;ul&gt;
&lt;li&gt;只有集合G的每个状态读入同一字符后，都落入（包含在）相同的某个集合，该集合G在这一步才不用细分&lt;/li&gt;
&lt;li&gt;否则集合G要被细分：落入不同集合的对应状态需要被分割进不同集合&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不断重复2直到不动点（任一集合分别对所有输入ai都不可细分）&lt;/li&gt;
&lt;li&gt;此时等价类中的每个集合即对应最小DFA的一个状态。在其上可以轻松构建min-DFA，该过程是trivial的（可以每个组中选择一个状态作代表）。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;示例（TODO）&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;/compiler-construction-principles/DFA-simplify-diverge.png&#34; alt=&#34;DFA-simplify-diverge&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;/compiler-construction-principles/DFA-simplify.png&#34; alt=&#34;DFA-simplify&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;Lex工具&#34;&gt;&lt;a href=&#34;#Lex工具&#34; class=&#34;headerlink&#34; title=&#34;Lex工具&#34;&gt;&lt;/a&gt;Lex工具&lt;/h3&gt;&lt;p&gt;通常和Yacc一起使用，生成编译器的前端。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;声明部分&lt;ul&gt;
&lt;li&gt;常量：常数标识符&lt;/li&gt;
&lt;li&gt;正则规则定义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;转换规则模式{动作}&lt;ul&gt;
&lt;li&gt;模式&amp;#x3D;正则表达式&lt;/li&gt;
&lt;li&gt;动作&amp;#x3D;识别到相应模式时应调用的处理函数（一般以C语言代码表示）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;辅助函数：动作中使用的函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解决冲突：最长匹配，较前规则优先&lt;/p&gt;
&lt;h2 id=&#34;Part-3-语法分析-CFG-Parsing&#34;&gt;&lt;a href=&#34;#Part-3-语法分析-CFG-Parsing&#34; class=&#34;headerlink&#34; title=&#34;Part 3: 语法分析 - CFG &amp;amp; Parsing&#34;&gt;&lt;/a&gt;Part 3: 语法分析 - CFG &amp;amp; Parsing&lt;/h2&gt;&lt;h3 id=&#34;语法分析器概述&#34;&gt;&lt;a href=&#34;#语法分析器概述&#34; class=&#34;headerlink&#34; title=&#34;语法分析器概述&#34;&gt;&lt;/a&gt;语法分析器概述&lt;/h3&gt;&lt;p&gt;从词法分析器获得Token序列，确认该序列是否可以由语言的文法生成&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于语法错误的程序，报告错误信息&lt;/li&gt;
&lt;li&gt;对于语法正确的程序，生成语法分析树(简称语法树) e.g. 抽象语法树AST&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现：手动 or 自动(使用Parse generator&amp;#x3D;{Yacc, Bison, ANTLR, mehir…})&lt;/p&gt;
&lt;h3 id=&#34;上下文无关文法CFG&#34;&gt;&lt;a href=&#34;#上下文无关文法CFG&#34; class=&#34;headerlink&#34; title=&#34;上下文无关文法CFG&#34;&gt;&lt;/a&gt;上下文无关文法CFG&lt;/h3&gt;&lt;p&gt;CFG &amp;#x3D; Context Free Language&lt;/p&gt;
&lt;p&gt;$$ G&amp;#x3D;(T,N,P,S) $$&lt;br&gt;T：终结符集合(Terminals)&lt;br&gt;N：非终结符集合(Non-terminals)&lt;br&gt;P：产生式集合(Productions) $ A\rightarrow a, A \in N, a \in (T \cup N)^*$&lt;br&gt;S：开始符号(Startsymbol): $ S \in N $&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;📕“上下文无关”体现在：产生式左侧只有一个非终结符，因此类似 $xAy\rightarrow xay$这样，需要关心符号前后别的符号是什么才能应用的产生式是不能在CFG里的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;特殊符号：$ &amp;#x3D;end of file(EOF)&lt;br&gt;添加一个新符号S’与一条新规则以表明必须在尾部：&lt;ul&gt;
&lt;li&gt;$ S’ \rightarrow S$ $&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;产生式缩写：左侧一样的产生式可以把右侧使用”|”合并。例如 $E\rightarrow E+E|(E)|id$&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;推导Derivation和规约Reduction&#34;&gt;&lt;a href=&#34;#推导Derivation和规约Reduction&#34; class=&#34;headerlink&#34; title=&#34;推导Derivation和规约Reduction&#34;&gt;&lt;/a&gt;推导Derivation和规约Reduction&lt;/h3&gt;&lt;p&gt;例如有产生式 $A\rightarrow \gamma$，我们可以有 $\alpha A \beta \Rightarrow \alpha \gamma \beta$&lt;br&gt;那么我们说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\alpha A \beta $ &lt;strong&gt;直接推导&lt;/strong&gt;到 $ \alpha \gamma \beta$&lt;/li&gt;
&lt;li&gt;$\alpha \gamma \beta $ &lt;strong&gt;直接规约&lt;/strong&gt;到 $  \alpha A \beta$&lt;br&gt;不言而喻的&lt;strong&gt;多步推导记号&lt;/strong&gt;：$\Rightarrow^5$ $\Rightarrow^+$ $\Rightarrow^*$&lt;br&gt;分别代表五步推导，至少一步推导，0次或更多次推导&lt;/li&gt;
&lt;li&gt;推导&amp;#x3D;从文法生成语言里的句子，规约&amp;#x3D;识别句子成分并逐渐规约到开始符号&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;最左推导Left-most Derivation&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最左推导&amp;#x3D;每步代换最左边的非终结符。逆过程为最右规约&lt;/li&gt;
&lt;li&gt;类比可得出最右推导、最左规约的定义&lt;/li&gt;
&lt;li&gt;在自顶向下的分析中，总是采用&lt;strong&gt;最左推导&lt;/strong&gt;；在自底向上的分析中，总是采用&lt;strong&gt;最左归约&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; &lt;img src=&#34;/compiler-construction-principles/lmrm.png&#34; alt=&#34;left-most derive&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;句型 句子 语言&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;句型(Sentential form) &amp;#x3D; 文法G下可能推导出的一个符号序列：可能包含终结符&amp;#x2F;非终结符，可为空&lt;/li&gt;
&lt;li&gt;句子(Sentence) &amp;#x3D; 不含非终结符的句型（仅含终结符）&lt;/li&gt;
&lt;li&gt;语言(Language) &amp;#x3D; 文法G可产生的所有句子的集合&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;正则文法(RE) 与 上下文无关文法(CFG)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;上下文无关语言L(G) :&amp;#x3D; CFG产生的所有句子的集合&lt;/li&gt;
&lt;li&gt;正则语言L(r) :&amp;#x3D; RE产生的所有句子的集合&lt;ul&gt;
&lt;li&gt;RE &amp;#x3D; Regex Expression &amp;#x3D; 正则表达式&lt;/li&gt;
&lt;li&gt;正则表达式r定义正则语言L(r)&lt;/li&gt;
&lt;li&gt;$ L(r) \in L(G) $：因为正则对产生式限制更大，必须为( $A,B \in N, a \in T\cup {\epsilon} $ )：&lt;ul&gt;
&lt;li&gt;左线性文法：形如 $A\rightarrow aB$ 或 $A\rightarrow a$&lt;/li&gt;
&lt;li&gt;右线性文法：形如 $A\rightarrow Ba$ 或 $A\rightarrow a$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;正则语言可用于词法分析，上下文无关语言可用于语法分析（语言描述能力、复杂性决定的）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Chomsky范式（计算理论课程内容）:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0型文法&amp;#x3D;短语结构文法 递归可枚举&lt;/li&gt;
&lt;li&gt;1型文法&amp;#x3D;上下文有关文法&lt;/li&gt;
&lt;li&gt;2型文法&amp;#x3D;CFG&lt;/li&gt;
&lt;li&gt;3型文法&amp;#x3D;RE&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;CFG的分析树Parse-Tree&#34;&gt;&lt;a href=&#34;#CFG的分析树Parse-Tree&#34; class=&#34;headerlink&#34; title=&#34;CFG的分析树Parse Tree&#34;&gt;&lt;/a&gt;CFG的分析树Parse Tree&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;分析树性质&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根节点&amp;#x3D;文法初始符号&lt;/li&gt;
&lt;li&gt;叶节点&amp;#x3D;终结符&lt;/li&gt;
&lt;li&gt;内部节点&amp;#x3D;非终结符&lt;/li&gt;
&lt;li&gt;父节点→{叶节点}&amp;#x3D;产生式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;语法分析(Parsing)中的挑战&lt;br&gt;&lt;em&gt;核心目标：对于终结符号串x，要么从S推导出x，要么设法将x规约到S&lt;/em&gt;*&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自顶向下(Top-down) S-&amp;gt;x, 从&lt;strong&gt;根节点&lt;/strong&gt;开始构造Parse Tree&lt;/li&gt;
&lt;li&gt;自底向上(Bottom-up) x-&amp;gt;S, 从&lt;strong&gt;叶节点&lt;/strong&gt;开始构造Parse Tree&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作为搜索问题：搜索空间大-&amp;gt;空间大小受文法产生式限制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无限制：时间复杂度 $O(n^3)$&lt;/li&gt;
&lt;li&gt;上下文无关语言CFL 的子集需要的典型时间为 $O(n)$，例如&lt;ul&gt;
&lt;li&gt;Predictive parsing using LL(1) grammars&lt;/li&gt;
&lt;li&gt;Shift-Reduce parsing using LR(1) grammars&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;编程语言的文法设计&#34;&gt;&lt;a href=&#34;#编程语言的文法设计&#34; class=&#34;headerlink&#34; title=&#34;编程语言的文法设计&#34;&gt;&lt;/a&gt;编程语言的文法设计&lt;/h3&gt;&lt;p&gt;核心：&lt;strong&gt;无二义性&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;二义性来源：某些句子存在不止一棵分析树&amp;#x3D;有两个不同的最左推导&amp;#x3D;&lt;strong&gt;多种可选推导处于文法同一层&lt;/strong&gt;&lt;br&gt;例如：$$E \Rightarrow E*E \Rightarrow id*E \Rightarrow id*E+E$$ 与 $$E \Rightarrow E+E \Rightarrow E*E+E \Rightarrow id*E+E $$&lt;br&gt;对于”3*4+5”，前者给出3*(4+5)&amp;#x3D;27（错误），后者给出3*4+5&amp;#x3D;17（正确）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;解决办法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保只有一种最左推导&amp;#x3D;将同一层文法分层&lt;/li&gt;
&lt;li&gt;规定符号优先级（”*“” &amp;gt; “+”,”-“）&lt;ul&gt;
&lt;li&gt;越接近开始符号S的文法符号优先级越低&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;规定符号结合性（左结合&amp;#x2F;右结合）&lt;ul&gt;
&lt;li&gt;递归非终结符（也就是这个终结符在产生式左部右部都出现）在终结符（也就是这个运算符，比如&lt;code&gt;*&lt;/code&gt;,&lt;code&gt;+&lt;/code&gt;）左边，运算就左结合&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;/compiler-construction-principles/priority.png&#34; alt=&#34;op priority&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;判定CFG二义性：不可判定问题&lt;br&gt;但可以通过给定充分条件（无二义文法）确保无二义性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自顶向下：LL(1)&lt;/li&gt;
&lt;li&gt;自底向上：LR(1), LALR(1)&lt;br&gt;&lt;a name=&#34;grammars-set&#34;&gt;&lt;/a&gt;&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/grammars.png&#34; alt=&#34;grammars&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Part-4-语法分析-自顶向下&#34;&gt;&lt;a href=&#34;#Part-4-语法分析-自顶向下&#34; class=&#34;headerlink&#34; title=&#34;Part 4: 语法分析 - 自顶向下&#34;&gt;&lt;/a&gt;Part 4: 语法分析 - 自顶向下&lt;/h2&gt;&lt;p&gt;自顶向下每一步的推导都需要做出&lt;strong&gt;两个选择&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;替换哪个非终结符？&lt;/li&gt;
&lt;li&gt;应用哪个（左侧为该终结符的）产生式替换？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通用形式：&lt;strong&gt;递归下降分析(Recursive-Descent Parsing)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发生错误（没有产生式可以产生合法的子节点）就回溯&lt;/li&gt;
&lt;li&gt;问题：太慢！&lt;/li&gt;
&lt;li&gt;该过程类似NFA，能否构造类似DFA的分析方法？&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;LL-1-和预测分析法&#34;&gt;&lt;a href=&#34;#LL-1-和预测分析法&#34; class=&#34;headerlink&#34; title=&#34;LL(1)和预测分析法&#34;&gt;&lt;/a&gt;LL(1)和预测分析法&lt;/h3&gt;&lt;p&gt;预测分析法(Predictive parsing)：接受LL(k)文法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个L: “left to right” 从左到右扫描&lt;/li&gt;
&lt;li&gt;第二个L: “left-most derivation” 最左推导&lt;/li&gt;
&lt;li&gt;k: 向前看k个token确定推导选用的产生式（一般不明确说k就是k&amp;#x3D;1）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来需要添加约束使其无需回溯。我们先引入几个概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;First集和Follow集&lt;/p&gt;
&lt;p&gt;给定 $ G&amp;#x3D;(T,N,P,S),\alpha \in (T\cup N)^* $&lt;br&gt;&lt;strong&gt;记空串为$\epsilon$&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;First集：可从$\alpha$推导得到的串的首个终结符的集合（也就是说，$\alpha$自己推导出的第一个终结符可能是什么）&lt;br&gt;$$ \text{First}(\alpha)&amp;#x3D;{a| \alpha \Rightarrow^*a…\ ,a\in T} $$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Follow集：从S出发，可能在推导过程中跟在A右边的终结符号集&lt;br&gt;$$ \text{Follow}(A)&amp;#x3D;{a|S\Rightarrow^*…Aa…\ ,a\in T} $$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如: $ S\rightarrow \alpha\ A a\ \beta $，终结符号 $ a\in \text{Follow}(A) $ （仔细区分a和α）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们至此可以使用两个条件保证产生式的选择是唯一的：&lt;br&gt;对于产生式 $ A\rightarrow \alpha|\beta $ ,&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$ \text{First}(\alpha)\cap \text{First}(\beta)&amp;#x3D; \emptyset $ （α和β推导不出以同一个单词为首的串）&lt;ul&gt;
&lt;li&gt;意义：显然的。这样看终结符是哪个就知道应该用哪个产生式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;若$\beta \Rightarrow^* \epsilon$，那么$\alpha \nRightarrow^* \epsilon$，且 $ \text{First}(\alpha) \cap Follow(A) &amp;#x3D; \emptyset $ （α和β不能同时推出$\epsilon$;First(α)不应在Follow(A) 中）&lt;ul&gt;
&lt;li&gt;意义：其实就是考虑如果可以推导出空串时，后继终结符因为是空串所以暂时还没法确定，得从Follow集中寻找（再向后看），最终做出哪个产生式的选择。&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;满足这条要求的情况下&lt;/strong&gt;，假设下一个输入是b,且$\beta \Rightarrow^* \epsilon$&lt;ul&gt;
&lt;li&gt;如果b∈First(α)，则选择A → α(属于上面1的情况)&lt;/li&gt;
&lt;li&gt;如果b∈Follow(A)，则选择A → β ,这对应A最终到达了$\epsilon$而且后面紧跟着终结符b的情况&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;应试建议：直接列出LL(1)分析表并检查是否有&lt;em&gt;冲突&lt;/em&gt;（见下文）。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来我们会看到具体的LL(1)预测分析实现方式。&lt;br&gt;&lt;strong&gt;三步走：计算First,Follow-&amp;gt;构造预测分析表-&amp;gt;预测分析&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;计算First, Follow&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Nullable集&lt;br&gt;  由于刚刚提到了空串，我们需要引入一个简单的新定义：Nullable集&amp;#x3D;{可推导出空串的符号}。&lt;br&gt;  定义是递归的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Base Case: 如果有产生式 $ X\rightarrow \epsilon$, 那么X当然是Nullable的&lt;/li&gt;
&lt;li&gt;Inductive Case: 如果有产生式 $ X\rightarrow Y_1 Y_2 Y_3 … Y_n$, 且 $Y_1,Y_2,Y_3,…,Y_n$&lt;strong&gt;每个都能&lt;/strong&gt;推导出空串，则X是Nullable的&lt;/li&gt;
&lt;li&gt;对于每个产生式，我们可以循环用它们不断更新Nullable集直到不动点。这同样适用于First集与Follow集。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;First集：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Base Case: 如果X是终结符terminal: First(X)&amp;#x3D;{X}&lt;/li&gt;
&lt;li&gt;Inductive Case: 如果有产生式 $ X\rightarrow Y_1 Y_2 Y_3 … Y_n$&lt;ul&gt;
&lt;li&gt;首先，$\text{First}(X) \cup &amp;#x3D; \text{First}(Y_1)$ ($ a\cup &amp;#x3D; b$意为$ a \leftarrow a\cup b$，也就是把b并进a里)&lt;/li&gt;
&lt;li&gt;如果$Y_1 \in \text{Nullable}: $$\text{First}(X) \cup &amp;#x3D; \text{First}(Y_2)$&lt;/li&gt;
&lt;li&gt;如果$Y_1,Y_2 \in \text{Nullable}: $$\text{First}(X) \cup &amp;#x3D; \text{First}(Y_3)$&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;li&gt;直到某个$Y_i \notin \text{Nullable}$则停止&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对于每个产生式，我们可以循环用它们不断更新First集直到不动点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Follow集：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Base Case: $ \text{Follow}(A)&amp;#x3D;\emptyset $&lt;/li&gt;
&lt;li&gt;Inductive Case: 如果有产生式 $ B\rightarrow s_1 A\ s_2 $&lt;ul&gt;
&lt;li&gt;$\text{Follow}(A) \cup &amp;#x3D; \text{First}(s_2)$&lt;/li&gt;
&lt;li&gt;如果$s_2 \in \text{Nullable}$, $\text{Follow}(A) \cup &amp;#x3D; \text{Follow}(B)$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对于每个产生式，我们可以循环用它们不断更新Follow集直到不动点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; Tips(不要求掌握):Tiger book algorithm 3.13指出他们可以同时计算，感兴趣可以看看。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;构造预测分析表&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;del&gt;打开网站即可&lt;a href=&#34;https://jsmachines.sourceforge.net/machines/ll1.html&#34;&gt;LL(1) Parser Generator&lt;/a&gt;&lt;/del&gt; 不过这个网站确实对于理解第三步中PDA相关过程很有帮助。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;回顾自顶向下推导的两个选择题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Q: 替换当前句型中的哪个非终结符? A: “Left-most”一词说明：总是选择每个句型的最左非终结符进行替换。&lt;/li&gt;
&lt;li&gt;Q: 用该非终结符的哪个产生式进行替换? A: 构建二维表M, 通过当前非终结符和看到的终结符决定选取何种产生式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;定义并构造M：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每一行A对应一个非终结符&lt;/li&gt;
&lt;li&gt;每一列a对应某个终结符或输入结束符&lt;code&gt;$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;表中的某一格M[A,a]表示：针对当前非终结符A，下一个输入Token为终结符a时，可选的产生式集合&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/tableM.png&#34; alt=&#34;M table&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;构造过程：对于每个产生式 $X\rightarrow \gamma$&lt;ul&gt;
&lt;li&gt;如果 $ t\in \text{First}(\gamma)$, 插入产生式 $X\rightarrow \gamma$ 到M[X,t]&lt;/li&gt;
&lt;li&gt;如果 $ \gamma \in \text{Nullable} $ 且 $t \in \text{Follow}(X)$, 插入产生式 $X\rightarrow \gamma$ 到M[X,t]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果某一格存在多个产生式，就说明无法确定选取哪个产生式（也即：产生了&lt;em&gt;冲突&lt;/em&gt;），也就说明不是LL(1)文法！&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;预测分析&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;递归下降&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如对于文法：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;S -&amp;gt; E $&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;E -&amp;gt; E + T&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;E -&amp;gt; E – T&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;E -&amp;gt; T&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;T -&amp;gt; T * F&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;T -&amp;gt; T / F&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;T -&amp;gt; F&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;F -&amp;gt; id&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;F -&amp;gt; num&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;F -&amp;gt; ( E )&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;形如：&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt;)&lt;/span&gt; &amp;#123; E(); eat(EOF); &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt;)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;switch&lt;/span&gt;(tok) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;case&lt;/span&gt; ?: E(); eat(PLUS); T(); &lt;span class=&#34;keyword&#34;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;case&lt;/span&gt; ?: E(); eat(MINUS); T(); &lt;span class=&#34;keyword&#34;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;case&lt;/span&gt; ?: T(); &lt;span class=&#34;keyword&#34;&gt;break&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;default&lt;/span&gt;: error();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 问号处内容由预测分析表M决定，读者有兴趣可以帮忙验证一下这个文法是否LL(1)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;非递归下降（&lt;strong&gt;无需掌握&lt;/strong&gt;）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本质上还是递归下降，只是改写成Pushdown Automata所以相当于模拟一个栈&lt;/li&gt;
&lt;li&gt;如果栈顶是非终结符A：利用预测分析表,选择产生式A -&amp;gt; a（也就是将栈顶的非终结符A替换成串a）&lt;/li&gt;
&lt;li&gt;如果栈顶是终结符a：将栈顶记号a和输入中的Token匹配并出栈&lt;/li&gt;
&lt;li&gt;初态：压入初始符号&lt;/li&gt;
&lt;li&gt;终态：输入读取完毕，栈空，此时接受&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;消除左递归、提左公因子&#34;&gt;&lt;a href=&#34;#消除左递归、提左公因子&#34; class=&#34;headerlink&#34; title=&#34;消除左递归、提左公因子&#34;&gt;&lt;/a&gt;消除左递归、提左公因子&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;LL(1)文法的部分性质&lt;br&gt;可用于判定问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LL(1)文法是无二义的&lt;/li&gt;
&lt;li&gt;LL(1)文法是无左递归的&lt;/li&gt;
&lt;li&gt;LL(1)文法是无左公因子的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;左递归(left-recursive)文法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;有非终结符A使得 $A \Rightarrow^* A\alpha$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;形如 $S\rightarrow Sa$ 的称为直接&amp;#x2F;立即左递归&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;问题：这会导致递归下降分析进入无限循环&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$S\rightarrow Sa|b$ 分析 $baaaa$&lt;/li&gt;
&lt;li&gt;可能永远卡在”a”里而没机会考虑”b”: $ S \Rightarrow Sa \Rightarrow Saa \Rightarrow Saaa \Rightarrow Saaaa …$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;解决办法：通过文法变换消除（详见龙书）&lt;br&gt;比如我们可以将这一文法：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;A -&amp;gt; A a | b (a,b不以A开头，a不为空)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;转为右递归：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;A -&amp;gt; b A&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;A&amp;#x27; -&amp;gt; aA&amp;#x27; | ε&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;左公因子的(left-factored)文法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$ P \rightarrow \alpha \beta | \alpha \gamma$&lt;/li&gt;
&lt;li&gt;问题：同一非终结符的多个候选式存在共同前缀，可能导致回溯&lt;/li&gt;
&lt;li&gt;解决办法：限制文法 或 文法变换&lt;ul&gt;
&lt;li&gt;例如我们可以提取左公因子来“推迟决定”，这样我们可以在读入更多token后进行决策：&lt;br&gt; 把&lt;br&gt; $$ P \rightarrow \alpha \beta | \alpha \gamma $$&lt;br&gt; 变换为&lt;br&gt; $$ P \rightarrow \alpha Q \\ Q \rightarrow \beta | \gamma $$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;错误恢复&#34;&gt;&lt;a href=&#34;#错误恢复&#34; class=&#34;headerlink&#34; title=&#34;错误恢复&#34;&gt;&lt;/a&gt;错误恢复&lt;/h3&gt;&lt;p&gt;错误：表M中对应格是空格，没有任何可取的产生式&lt;br&gt;我们不希望遇到错误直接全盘放弃，而是令Parser报错后，尽可能从错误中恢复并继续工作，这样可以一次性尽可能报出程序里全部错误。&lt;/p&gt;
&lt;p&gt;可以通过以下几种方式恢复：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除：例如，可以一直跳过token直到遇到当前非终结符对应Follow集中的token&lt;/li&gt;
&lt;li&gt;插入：例如，如果左右括号不匹配，我们可以插入一个假装有&lt;/li&gt;
&lt;li&gt;替换：例如，变量名错误可以替换为最相近的变量名&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Part-5-语法分析-自底向上&#34;&gt;&lt;a href=&#34;#Part-5-语法分析-自底向上&#34; class=&#34;headerlink&#34; title=&#34;Part 5: 语法分析 - 自底向上&#34;&gt;&lt;/a&gt;Part 5: 语法分析 - 自底向上&lt;/h2&gt;&lt;p&gt;从串w归约为文法开始符号S的过程。规约时，一个与某产生式体&lt;strong&gt;相匹配的特定子串&lt;/strong&gt;被替换为该产生式头部的&lt;strong&gt;非终结符号&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;何时归约(归约哪些符号串)？&lt;/li&gt;
&lt;li&gt;归约到哪个非终结符号？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;回顾LL(1)的优势劣势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;+ 运行高效(线性时间)&lt;/li&gt;
&lt;li&gt;+ 递归实现符合文法结构、适合手动构造&amp;amp;自动生成&lt;/li&gt;
&lt;li&gt;- 能分析的文法类型受限&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们提出新文法：LR(k)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表达力: Every LL(k) grammar is also LR(k)&lt;/li&gt;
&lt;li&gt;不要求无左公因式&lt;/li&gt;
&lt;li&gt;可以处理左递归文法&lt;/li&gt;
&lt;li&gt;被广泛采用(Yacc, Bison, …)&lt;/li&gt;
&lt;li&gt;“L”: left-to-right scanning 自左向右扫描&lt;/li&gt;
&lt;li&gt;“R”: right-most derivation in reverse 最右推导的逆&lt;/li&gt;
&lt;li&gt;“k”: 向前看的字符的个数(k省略时取1)&lt;/li&gt;
&lt;li&gt;子集（详见&lt;a href=&#34;#grammars-set&#34;&gt;该图&lt;/a&gt;）：LR(1), LALR(1), SLR, LR(0), …&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;移进-规约-Shift-Reduce&#34;&gt;&lt;a href=&#34;#移进-规约-Shift-Reduce&#34; class=&#34;headerlink&#34; title=&#34;移进-规约 Shift-Reduce&#34;&gt;&lt;/a&gt;移进-规约 Shift-Reduce&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;这是LR(k) Parsing 的一般模式。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;核心思想：将字符串一分为二，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;右侧是未被parser检查过的&lt;/li&gt;
&lt;li&gt;左侧包含终结符与非终结符&lt;br&gt;我们接下来会使用”|”标记分割点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如，考虑该文法： $ E \rightarrow E+(E) | \text{int} $&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;显然并非LL(1)的：存在左递归&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们考虑处理字符串”int+(int)+(int)”，则过程如下：&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/sr.png&#34; alt=&#34;shift reduce&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;可见LR分析采用最右推导的&lt;strong&gt;逆过程&lt;/strong&gt;：最左规约。因此LR分析的每一步都是最右句型。&lt;br&gt;一般实现方式：采用&lt;strong&gt;栈&lt;/strong&gt;进行Shift-Reduce&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;栈：包含左侧字符串&lt;/li&gt;
&lt;li&gt;输入流：包含剩余未处理的右侧字符串&lt;/li&gt;
&lt;li&gt;操作：&lt;ul&gt;
&lt;li&gt;Shift: 从输入读入一个Terminal压入栈&lt;/li&gt;
&lt;li&gt;Reduce: 栈顶的几个元素满足某条产生式的&lt;strong&gt;RHS(Right hand side)&lt;/strong&gt;, 则pop这些元素并压入产生式的&lt;strong&gt;LHS(Left hand side)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Error: 爆！留待后文讨论。&lt;/li&gt;
&lt;li&gt;Accept: shift “$” 并且栈中只剩下文法的开始符号&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;需要解决的问题：&lt;strong&gt;何时shift? 何时reduce?&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;表驱动的LR分析：类似LL文法的表，但行列意义不同，且这个表一般很大（详见后文）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;几个文法的包含关系（仍然是详见&lt;a href=&#34;#grammars-set&#34;&gt;该图&lt;/a&gt;）:&lt;br&gt;$ LR(0) \in SLR(1) \in LALR(1) \in LR(1) $&lt;/p&gt;
&lt;h3 id=&#34;LR-0-Parsing&#34;&gt;&lt;a href=&#34;#LR-0-Parsing&#34; class=&#34;headerlink&#34; title=&#34;LR(0) Parsing&#34;&gt;&lt;/a&gt;LR(0) Parsing&lt;/h3&gt;&lt;p&gt;核心思想：因为需要凑出产生式RHS，维护栈顶内容对于所有产生式右侧的“进度”。&lt;br&gt;项(Item):&amp;#x3D; 一个产生式加上在其中某处的一个点。&lt;/p&gt;
&lt;p&gt;例如产生式 $A\rightarrow XYZ$ 有4个Item:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$A\rightarrow \bullet XYZ $&lt;/li&gt;
&lt;li&gt;$A\rightarrow X\bullet YZ $&lt;/li&gt;
&lt;li&gt;$A\rightarrow XY\bullet Z $&lt;/li&gt;
&lt;li&gt;$A\rightarrow XYZ \bullet $&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Item的含义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$ A\rightarrow \alpha \bullet \beta$: 已扫描&amp;#x2F;归约到了α，并期望在接下来的输入中经过扫描&amp;#x2F;归约得到β，然后把αβ归约到A&lt;/li&gt;
&lt;li&gt;$ A\rightarrow \alpha \beta \bullet$: 已扫描&amp;#x2F;归约得到了αβ，此时已经可以把αβ归约为A&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Item类似一个有穷自动机的状态!&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个项读入一个符号后可以转变为另一个项：例如$A\rightarrow \bullet XYZ $ 读入X就可以转为 $A\rightarrow X\bullet YZ $&lt;/li&gt;
&lt;li&gt;显然项的数量是有限的。&lt;/li&gt;
&lt;li&gt;这样的有穷自动机被称为&lt;strong&gt;LR(0)自动机&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;LR(0)Parsing的NFA:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;⚠ NFA只能识别正则语言RE，然而RE&amp;lt;LR(0). 所以这里的NFA只是用于辅助记录栈顶识别进度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;新增开始符号S’，并加入产生式” S’-&amp;gt;S$ “&lt;/li&gt;
&lt;li&gt;NFA起始状态：$S’\rightarrow \bullet S$ $&lt;/li&gt;
&lt;li&gt;NFA终结状态：$S’\rightarrow S\bullet$ $&lt;/li&gt;
&lt;li&gt;转移：&lt;ul&gt;
&lt;li&gt;$A\rightarrow \bullet XY $ 读入X就可以转为 $A\rightarrow X\bullet Y $&lt;/li&gt;
&lt;li&gt;对于产生式 $ X\rightarrow \alpha Y \beta $ 与 $Y\rightarrow \gamma$ 那么 $ X\rightarrow \alpha \bullet Y \beta $ 可以直接转换（ε-move）到 $ Y \rightarrow \bullet \gamma$ （相当于递归下降法里进入下一层递归，从而分析当前产生式内部的非终结符）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们更希望能转为DFA. 当然可以使用子集构造法转换，但事实上可以直接构造DFA.&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/lr-nfa2dfa.png&#34; alt=&#34;lr-nfa2dfa&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;LR(0)Parsing的DFA与分析表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;DFA构造：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;项集闭包CLOSURE:&amp;#x3D; a &lt;strong&gt;set&lt;/strong&gt; of &lt;strong&gt;items&lt;/strong&gt;, 记为I&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;任意符号记为X&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对任意项集Closure(I)求法（其实就是ε-closure）：&lt;br&gt;Closure(I) &amp;#x3D;&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;repeat&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  for any item A→ α•Xβ in I&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    for any production X→ γ&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      I ← I + &amp;#123;X→ •γ&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;until I does not change. &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;return I&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;blockquote&gt;
&lt;p&gt;TL;DR: 如果”·”的右边是非终结符X，就把X为LHS的产生式对应的初始项加入。注意这是递归的：加入的新初始项如果也有这个情况还得接着加。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;接下来的构造方式通过类比NFA-&amp;gt;DFA的子集构造法是显然的：&lt;br&gt;GOTO(I,X):&amp;#x3D; I是一个项集，X是一个文法符号，则GOTO(I,X)定义为I中所有形如 $A\rightarrow \bullet X \beta$ 的项所对应的新项 $A\rightarrow X \bullet \beta$ 构成的新集合生成的闭包（I是状态，X是转移，I里符合要求（也就是下一个符号是X）的产生式前移一位越过X加入转移到的新状态，不符合的被丢弃；当然考虑到ε-moves要再求一遍新状态的闭包）&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/lr-dfa.png&#34; alt=&#34;lr-dfa&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/lr-dfa-eg.png&#34; alt=&#34;lr-dfa example&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;DFA到分析表&lt;br&gt;分析表T类似LL(1)中的表M，但是行列的含义与内容都发生了很大变化。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Action表项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每一行对应一个状态i&lt;/li&gt;
&lt;li&gt;每一列对应一个&lt;strong&gt;终结符t&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;表中的一格T[i,t]代表要做的操作action，有以下几种可能：&lt;ul&gt;
&lt;li&gt;$s_n$ &amp;#x3D; shift n :&amp;#x3D; 从状态i经过&lt;strong&gt;终结符t&lt;/strong&gt;转移到状态n. 步骤：&lt;ol&gt;
&lt;li&gt;从输入流中取一个终结符t压入状态栈&lt;/li&gt;
&lt;li&gt;将n压入状态栈&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;$r_k$ &amp;#x3D; reduce k :&amp;#x3D; 确定使用第k个产生式进行规约（此时状态i没有出边）。 步骤：&lt;ol&gt;
&lt;li&gt;弹出状态栈顶的几个状态（数量对应产生式#k的RHS长度）&lt;/li&gt;
&lt;li&gt;符号栈压入产生式#k的LHS，也即一个非终结符X&lt;/li&gt;
&lt;li&gt;查询Goto表（见下文）T[i,X]将对应的下一个状态压入状态栈&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;accept :&amp;#x3D; 该状态包含 $S’\rightarrow S \bullet $ $, 接受字符串，运行完毕&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Goto表项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每一行对应一个状态i&lt;/li&gt;
&lt;li&gt;每一列对应一个&lt;strong&gt;非终结符X&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;表中的一格T[i,X]表明经过&lt;strong&gt;非终结符X&lt;/strong&gt;下一个状态是什么&lt;/li&gt;
&lt;li&gt;格中的$g_n$ &amp;#x3D; goto n :&amp;#x3D; 从状态i经过&lt;strong&gt;非终结符X&lt;/strong&gt;转移到状态n&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;img src=&#34;/compiler-construction-principles/dfa2table.png&#34; alt=&#34;dfa to table&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;LR实际实现只有状态栈，符号信息可从相应状态中获取&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个例子：&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/lr0-stack-table.png&#34; alt=&#34;lr0-stack-table&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何理解”LR(0)”中的”0”:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Item中没有Lookahead terminal等信息，不关心后面的token&lt;/li&gt;
&lt;li&gt;是否规约&amp;#x2F;使用何产生式规约完全取决于栈顶状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;局限性&lt;/strong&gt;：由于只要有产生式能规约就立刻规约，很容易产生冲突（也就是表中一格有多个$s_n$,$r_n$，不知道应该直接规约还是需要接受更多符号来完成另一个产生式，这被称作&lt;strong&gt;shift-reduce conflict&lt;/strong&gt;）&lt;br&gt;我们引入新的文法，放宽一些限制。&lt;/p&gt;
&lt;h3 id=&#34;SLR-1-Parsing&#34;&gt;&lt;a href=&#34;#SLR-1-Parsing&#34; class=&#34;headerlink&#34; title=&#34;SLR(1) Parsing&#34;&gt;&lt;/a&gt;SLR(1) Parsing&lt;/h3&gt;&lt;p&gt;SLR(1) &amp;#x3D; Simple LR(1)&lt;/p&gt;
&lt;p&gt;我们说过k省略时默认为1，所以称为SLR文法即可。其实就是LR(0)稍微改改。&lt;/p&gt;
&lt;p&gt;考虑每次规约，都会使用一个产生式 $E\rightarrow \alpha$&lt;br&gt;“LR分析是最右推导的逆过程”，因此每步归约都应该满足：&lt;br&gt;$$ t \in \text{Follow}(E) $$其中t指的是&lt;strong&gt;输入流中下一个token&lt;/strong&gt;, E指的是用于&lt;strong&gt;此规约用到的产生式的左部(LHS)&lt;/strong&gt;.&lt;br&gt;因此对于SLR文法来说，SLR的DFA和LR(0)一样；但LR(0)的分析表中有一些$r_n$是非法的，需要删去。&lt;br&gt;在生成分析表的具体步骤上：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LR(0)的某些状态包含可规约的Item，那么这个状态I在对应的Action表中T[I,_]这一行的每一个格子（无论终结符t是什么）无论如何都会有对应的$r_n$项&lt;/li&gt;
&lt;li&gt;SLR会关心后面的终结符是什么，因此如果t不在Follow集中，这不能是一个合法的规约，Action表对应的t列就不会有这个$r_n$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如，图中被划去的部分即为从LR(0)分析表到SLR分析表的变化：&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/slr-table.png&#34; alt=&#34;SLR分析表：删去了部分规约项&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;规约的条件更严格，也就“自动”消除了一些冲突，也就允许了更多语言被纳入该文法，因此 $\text{LR(0)} \in \text{SLR}$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;局限性&lt;/strong&gt;：显然不能消除所有shift-reduce冲突。如果产生冲突对应的终结符t恰好在Follow集里，就无法消除。例如考虑如下文法：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;S&amp;#x27; -&amp;gt; S $&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;S -&amp;gt; L = R&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;S -&amp;gt; R&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;L -&amp;gt; id&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;L -&amp;gt; * R&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;R -&amp;gt; L&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;由最后两条规则&lt;code&gt;L -&amp;gt; * R&lt;/code&gt; &lt;code&gt;R -&amp;gt; L&lt;/code&gt;可以看出Follow(R)与Follow(L)两个集合互相包含，即相等，即Follow(R)&amp;#x3D;Follow(L)&lt;br&gt;然而’&amp;#x3D;’在Follow(L)&amp;#x3D;{&lt;code&gt;=&lt;/code&gt;,&lt;code&gt;$&lt;/code&gt;}中，因此我们遇到’L&amp;#x3D;…’时仍然不知道应该接受等于号进行shift(这样就可以进一步在&lt;code&gt;S-&amp;gt;L=R&lt;/code&gt;这个产生式中前进)，还是直接使用&lt;code&gt;R-&amp;gt;L&lt;/code&gt;进行reduce.&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/slr-conflict.png&#34; alt=&#34;slr-conflict&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/slr-conflict-table.png&#34; alt=&#34;slr-conflict-table&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们需要更多、更精确的限制才能进一步降低冲突的可能。&lt;/p&gt;
&lt;h3 id=&#34;LR-1-Parsing&#34;&gt;&lt;a href=&#34;#LR-1-Parsing&#34; class=&#34;headerlink&#34; title=&#34;LR(1) Parsing&#34;&gt;&lt;/a&gt;LR(1) Parsing&lt;/h3&gt;&lt;p&gt;包含更多信息（后继token）来消除一些归约动作。&lt;br&gt;相当于“分裂”一些LR(0)状态，精确指明何时应该归约。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LR(1)项(item)的形式：$ A \rightarrow \alpha \bullet \beta,\ a$&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;逗号后的a是 &lt;strong&gt;向前看符号(lookahead symbol)&lt;/strong&gt; 即表明向前看一个终结符，可以是&lt;code&gt;$&lt;/code&gt;.&lt;br&gt;和LR(0)对比，处理ε-move时记录合法的向前看符号w.&lt;/p&gt;
&lt;p&gt;各种计算：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;计算Closure&lt;br&gt;对于状态I中的一个item $$A\rightarrow \alpha \bullet X \beta,\ z$$ 以及一个产生式 $$X\rightarrow \gamma$$&lt;br&gt;我们&lt;strong&gt;递归地&lt;/strong&gt;寻找所有 $w\in \text{First}(\beta z)$ 然后加入I：$I\cup&amp;#x3D;{(X\rightarrow \bullet \gamma,\ w) | \forall w\in \text{First}(\beta z) }$（直到不动点为止）&lt;br&gt;起始状态是 $S’\rightarrow \bullet S \$,\ ?$ 的闭包&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们不关心”?”处是什么，因为我们永远不会移进&lt;code&gt;$&lt;/code&gt;.&lt;br&gt;所以一种可行的表示是把&lt;code&gt;$&lt;/code&gt;都移到产生式外部，而非真的要产生一个&lt;code&gt;$&lt;/code&gt;符号： $S’\rightarrow \bullet S,\ \$$）&lt;br&gt;或者你也可以直接写作：$S’\rightarrow \bullet S\$,\ ?$ （推荐）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;计算Goto表&lt;br&gt;基本和LR(0)算法保持相同，移入动作不考虑向前看符号z&lt;br&gt;也就是对于转移X，转移前后项的变换是：&lt;br&gt;$$A \rightarrow \alpha \bullet X \beta,\ z \ \ \Rightarrow\ \ A \rightarrow \alpha X \bullet \beta,\ z$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;计算Action表：Reduce操作&lt;/p&gt;
&lt;p&gt;规约操作是变换较大的部分。&lt;br&gt;在LR(1)中，Action表项中Reduce操作形如$(I, z, A\rightarrow \alpha)$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I: 代表状态I对应的行&lt;/li&gt;
&lt;li&gt;z: 代表向前看符号&lt;/li&gt;
&lt;li&gt;$ A\rightarrow \alpha $ 为规约所采用的产生式&lt;br&gt;这就限制了从某个可规约项规约时，必须向前看一个符号以确保它是lookahead symbol.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/compiler-construction-principles/lr1-items.png&#34; alt=&#34;lr1 items&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;局限性&lt;/strong&gt;：这样的文法限制过少，过于灵活，导致状态数量过多，状态表过于庞大。&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/lr1-con.png&#34; alt=&#34;lr1 con&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/lr1-dfa.png&#34; alt=&#34;lr1 dfa&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：话虽如此，文法仍然可能因为R-R冲突与S-R冲突从而导致其不属于LR(1)！这样的例子可以在LR(k)且k&amp;gt;1的文法中大量找到。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此我们在SLR(1)&amp;#x3D;Simple LR(1)与LR(1)之间折中，可以得到一个新文法LALR(1).&lt;/p&gt;
&lt;h3 id=&#34;LALR-1-Parsing&#34;&gt;&lt;a href=&#34;#LALR-1-Parsing&#34; class=&#34;headerlink&#34; title=&#34;LALR(1) Parsing&#34;&gt;&lt;/a&gt;LALR(1) Parsing&lt;/h3&gt;&lt;p&gt;LALR &amp;#x3D; Look-Ahead LR&lt;/p&gt;
&lt;p&gt;动机：发现很多LR(1)中的状态都只有lookahead symbol的区别。能否合并？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LALR(1): 把LR(1)中只有lookahead symbol不同的item合并。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义：把LR(1)中item的集合里所有lookahead symbol去掉，剩下的称为&lt;strong&gt;核(core)&lt;/strong&gt;&lt;br&gt;把LR(1)中所有核相同的状态两两合并为一个状态。每次合并都删除两个旧状态，新增一个新状态，入边出边的连接方式是显然的，直接接在新状态上即可。&lt;br&gt;新状态的item是两个旧状态的item的并（其实就是把每个item的lookahead symbol合并一下）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/compiler-construction-principles/lr1-lalr1.png&#34; alt=&#34;lr1 to lalr1&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;这样得到的表将会小很多：与SLR的分析表&lt;strong&gt;一样大&lt;/strong&gt;！通常状态数只有LR(1)的十分之一。付出的微小代价：规约-规约冲突(reduce-reduce conflict)&lt;br&gt;例如对于如下文法：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;S -&amp;gt; a E c&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   | a F d&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   | b F c&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   | b E d&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;E -&amp;gt; e&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;F -&amp;gt; e&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在LALR分析表中有两个状态会被合并成一个。而之后的下个字符将会出现歧义。这个冲突对应的状态：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;E -&amp;gt; e, &amp;#123;c,d&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;F -&amp;gt; e, &amp;#123;c,d&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;LR(1)分析器：将产生两个不同的状态(图中的状态#6与#9)，不会产生冲突：&lt;img src=&#34;/compiler-construction-principles/lr1-eg.png&#34; alt=&#34;lr1 example&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;LALR(1)分析器：只会产生一个状态，产生冲突&lt;ul&gt;
&lt;li&gt;若下个输入字符为c或d，可以归约成E或F&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，上述文法对于LALR(1)是二义的。&lt;br&gt;但这是可以接受的：LALR(1)足以处理绝大部分程序设计语言。&lt;/p&gt;
&lt;h2 id=&#34;Part-6-语法分析杂项&#34;&gt;&lt;a href=&#34;#Part-6-语法分析杂项&#34; class=&#34;headerlink&#34; title=&#34;Part 6: 语法分析杂项&#34;&gt;&lt;/a&gt;Part 6: 语法分析杂项&lt;/h2&gt;&lt;h3 id=&#34;语法分析器的生成器：YACC&#34;&gt;&lt;a href=&#34;#语法分析器的生成器：YACC&#34; class=&#34;headerlink&#34; title=&#34;语法分析器的生成器：YACC&#34;&gt;&lt;/a&gt;语法分析器的生成器：YACC&lt;/h3&gt;&lt;p&gt;Yacc &amp;#x3D; yet another compiler-compiler:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于LALR(1)&lt;/li&gt;
&lt;li&gt;BNF(Backus Naur Form)范式&lt;/li&gt;
&lt;li&gt;GNU版本名为&lt;em&gt;Bison&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;流程：&lt;ol&gt;
&lt;li&gt;Yacc源程序(*.y) &amp;gt;&amp;gt; Yacc Compiler &amp;gt;&amp;gt; C语言实现的LALR分析器(y.tab.c)&lt;/li&gt;
&lt;li&gt;y.tab.c &amp;gt;&amp;gt; C Compiler &amp;gt;&amp;gt; 分析器可执行文件(&lt;em&gt;.exe&amp;#x2F;&lt;/em&gt;.out)&lt;/li&gt;
&lt;li&gt;输入 &amp;gt;&amp;gt; 分析器可执行文件 &amp;gt;&amp;gt; 输出&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Lex&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种词法分析器的生成器，将词法转化为词法解析器yylex()&lt;/li&gt;
&lt;li&gt;Yacc生成的yyparse()可以接受yylex()进而生成语法分析器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Yacc源程序结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;声明&lt;ul&gt;
&lt;li&gt;C语言的声明&lt;/li&gt;
&lt;li&gt;词法单元的声明&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;翻译规则&lt;ul&gt;
&lt;li&gt;产生式&lt;/li&gt;
&lt;li&gt;产生式相关语义动作（例如编译时计算）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;辅助性C语言例程&lt;ul&gt;
&lt;li&gt;直接拷贝到生成的*.tab.c中&lt;/li&gt;
&lt;li&gt;可以在语义动作中调用&lt;/li&gt;
&lt;li&gt;Lex生成的yylex()就是其中之一，可以返回词法单元&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 例如，对于示例文法：&lt;/p&gt;
 &lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;exp → exp addop term | term&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;addop → + | -&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;term → term mulop factor | factor&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;mulop → *&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;factor → ( exp ) | number&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt; 有示例程序：&lt;/p&gt;
 &lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;%&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;#include &amp;lt;ctype.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;int yylex(void);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;int yyerror (char * s);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;%&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;%token NUMBER&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;%%&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;command: exp &amp;#123;printf(&amp;quot;%d\n&amp;quot;, $1);&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;exp: exp &amp;#x27;+&amp;#x27; term &amp;#123;$$ = $1 + $3;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  | exp &amp;#x27;-&amp;#x27; term &amp;#123;$$ = $1 - $3;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  | term &amp;#123;$$ = $1&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;term: term &amp;#x27;*&amp;#x27; factor &amp;#123;$$ = $1 * $3;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    | factor &amp;#123;$$ = $1;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;factor: NUMBER &amp;#123;$$ = $1;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      | &amp;#x27;(&amp;#x27; exp &amp;#x27;)&amp;#x27; &amp;#123;$$ = $2;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt; 其中翻译规则Rule的格式为 &lt;code&gt;Rule &amp;#123;Action Code&amp;#125;&lt;/code&gt;，使用规则规约后Action Code就会被执行&lt;br&gt; 语义动作形如 &lt;code&gt;$$ = $1 + $3&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$$&lt;/code&gt; 表示和产生式头(LHS)相关的属性值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$i&lt;/code&gt; 表示产生式体中第i个文法符号（终结符&amp;#x2F;非终结符）的属性值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;消除二义性与解决冲突&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消除二义性：&lt;ul&gt;
&lt;li&gt;指定运算符优先级：先出现的优先&lt;/li&gt;
&lt;li&gt;指定运算符结合律：&lt;code&gt;%left&lt;/code&gt;（左结合，例如乘法加法） &lt;code&gt;%right&lt;/code&gt;（右结合，例如一元运算符负号）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;冲突解决&lt;ul&gt;
&lt;li&gt;规约-规约冲突：先出现的产生式优先采用&lt;/li&gt;
&lt;li&gt;移进-规约冲突：移进优先采用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;更通用的方法：通过改写文法，可以在消除冲突的同时减少二义性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;错误恢复-1&#34;&gt;&lt;a href=&#34;#错误恢复-1&#34; class=&#34;headerlink&#34; title=&#34;错误恢复&#34;&gt;&lt;/a&gt;错误恢复&lt;/h3&gt;&lt;p&gt;动机：一次性报告所有错误，而非遇到第一个就停下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;局部错误恢复：调整Parse过程的栈，使其恢复到正常从而继续进行Parsing&lt;/li&gt;
&lt;li&gt;全局错误恢复：删除&amp;#x2F;插入尽可能少的字符，使得源字符串成为合法的字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;局部错误恢复&lt;br&gt; Yacc中的一个方法：使用特殊的&lt;code&gt;error&lt;/code&gt;符号（终结符）控制恢复过程。&lt;br&gt; 例如：&lt;/p&gt;
 &lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;exp -&amp;gt; ( error )&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;exp -&amp;gt; error ; exp&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt; 于是通过这样的产生式，我们可以把错误的影响范围控制在右括号处&amp;#x2F;分号处。如果语法处理时遇到错误，可以一路跳过直到右括号和分号，然后继续处理。&lt;br&gt; 分号、右括号这样的符号就被叫做synchronizing token.&lt;/p&gt;
&lt;p&gt; 当语法分析器遇到错误时：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不断弹出栈中状态，直到栈顶状态包含项 $ A \rightarrow \bullet error\ \alpha$&lt;/li&gt;
&lt;li&gt;分析器将error移入栈中&lt;/li&gt;
&lt;li&gt;如果α为空，分析器直接执行归约，并调用相关的语义动作；否则跳过一些符号，找到可以归约为α的串为止&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 流程示例：&lt;br&gt; &lt;img src=&#34;/compiler-construction-principles/local-recovery.png&#34; alt=&#34;local error recovery&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;全局错误恢复&lt;br&gt; &lt;strong&gt;不要求掌握。&lt;/strong&gt;&lt;br&gt; Burke-Fisher 错误恢复: 对于在发生错误处之前的K个token，每一处都允许插入&amp;#x2F;删除&amp;#x2F;修改一个token，直到修复成功。&lt;br&gt; 优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不引入新产生式，不改变文法&lt;/li&gt;
&lt;li&gt;也不改变分析表&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 如何判定修复是否成功：修复后，在报告错误处继续Parsing直到下一个错误发生的距离最长（一般来说，修复后能从本来由于错误卡住的地方继续前进4个token就算成功了）。&lt;/p&gt;
&lt;p&gt; 实现：维护K个token前的旧栈，以及K个token组成的队列。遇到错误后基于旧栈和增删改后的token队列（不一定是K个了）试图parse. 尝试不同的增删改方案直到修复成功：&lt;br&gt; &lt;img src=&#34;/compiler-construction-principles/burke-fisher.png&#34; alt=&#34;burke-fisher&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt; 语义动作需要延迟到进入旧栈中（进入旧栈说明在解析流程中已经确定了）再进行&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;否则如果遇到错误，错误恢复发现原来的parsing方式不对时，文法符号的属性已经按照错误的方式运算了，回天乏术。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;语法分析小结：文法对比&#34;&gt;&lt;a href=&#34;#语法分析小结：文法对比&#34; class=&#34;headerlink&#34; title=&#34;语法分析小结：文法对比&#34;&gt;&lt;/a&gt;语法分析小结：文法对比&lt;/h2&gt;&lt;h3 id=&#34;SLR-与-LR-1&#34;&gt;&lt;a href=&#34;#SLR-与-LR-1&#34; class=&#34;headerlink&#34; title=&#34;SLR 与 LR(1)&#34;&gt;&lt;/a&gt;SLR 与 LR(1)&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;SLR&lt;/th&gt;
&lt;th&gt;LR(1)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;移   进&lt;/td&gt;
&lt;td&gt;$ A\rightarrow \alpha \bullet a \beta \in I_i \\ \text{Goto}(I_i,a)&amp;#x3D;I_j \\ \text{Action}[i,a]&amp;#x3D;s_j $&lt;/td&gt;
&lt;td&gt;$ A\rightarrow \alpha \bullet a \beta \in I_i \\ \text{Goto}(I_i,a)&amp;#x3D;I_j \\ \text{Action}[i,a]&amp;#x3D;s_j $&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;规   约&lt;/td&gt;
&lt;td&gt;$ A\rightarrow \alpha \bullet \in I_i \\ \alpha \in \text{Follow}(A) \\ \text{Action}[i,a]&amp;#x3D;r_j$&lt;/td&gt;
&lt;td&gt;$ A\rightarrow \alpha \bullet \in I_i \\ \text{Action}[i,a]&amp;#x3D;r_j $&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;可见唯一的区别就是SLR在规约时要求后继token是在Follow集里的。&lt;/p&gt;
&lt;h3 id=&#34;LL-1-与-LR-1&#34;&gt;&lt;a href=&#34;#LL-1-与-LR-1&#34; class=&#34;headerlink&#34; title=&#34;LL(1) 与 LR(1)&#34;&gt;&lt;/a&gt;LL(1) 与 LR(1)&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;LR(1)&lt;/th&gt;
&lt;th&gt;LL(1)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;建立分析树&lt;/td&gt;
&lt;td&gt;自底而上&lt;/td&gt;
&lt;td&gt;自顶而下&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;归约or推导&lt;/td&gt;
&lt;td&gt;规范归约(最右推导的逆)&lt;/td&gt;
&lt;td&gt;最左推导&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;分析表（行x列）&lt;/td&gt;
&lt;td&gt;状态×文法符号，大&lt;/td&gt;
&lt;td&gt;非终结符×终结符，小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;分析栈&lt;/td&gt;
&lt;td&gt;状态栈，信息更多&lt;/td&gt;
&lt;td&gt;文法符号栈&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;LL(1): 对于多个可选产生式 $A\rightarrow \alpha_1|\alpha_2|…$ 向前看下一个输入根据First,Follow确定使用哪条产生式推导&lt;/li&gt;
&lt;li&gt;LR(1): 对于多个可选产生式 $A\rightarrow \alpha,\ B\rightarrow \alpha,… $ 在识别出整个$\alpha$后，再往前看1个符号，然后确定使用哪条产生式归约&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;LL-1-LR-1-SLR&#34;&gt;&lt;a href=&#34;#LL-1-LR-1-SLR&#34; class=&#34;headerlink&#34; title=&#34;LL(1) LR(1) SLR&#34;&gt;&lt;/a&gt;LL(1) LR(1) SLR&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;/compiler-construction-principles/grammar-compare.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;Part-7-抽象语法&#34;&gt;&lt;a href=&#34;#Part-7-抽象语法&#34; class=&#34;headerlink&#34; title=&#34;Part 7: 抽象语法&#34;&gt;&lt;/a&gt;Part 7: 抽象语法&lt;/h2&gt;&lt;p&gt;编程语言 &amp;#x3D; 语法（识别一个合法的程序） + 语义（这个合法的程序对应的实际行为）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语法：已经在之前章节讨论过。&lt;/li&gt;
&lt;li&gt;语义：&lt;ul&gt;
&lt;li&gt;操作语义：如何执行程序？&lt;/li&gt;
&lt;li&gt;&lt;del&gt;公理语义：我们可以证明程序的那些性质？&lt;/del&gt;（该部分不在本课讨论）&lt;/li&gt;
&lt;li&gt;指称语义：程序是做什么的？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;属性文法Attribute-Grammar&#34;&gt;&lt;a href=&#34;#属性文法Attribute-Grammar&#34; class=&#34;headerlink&#34; title=&#34;属性文法Attribute Grammar&#34;&gt;&lt;/a&gt;属性文法Attribute Grammar&lt;/h3&gt;&lt;p&gt;属性文法&amp;#x3D;&lt;strong&gt;上下文无关文法+属性+属性计算规则&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;属性:&amp;#x3D; 描述文法符号的语义特征，比如表达式E的值我们可以记为E.val&lt;/li&gt;
&lt;li&gt;属性计算规则(语义规则):&amp;#x3D; 与产生式相关联、反映文法符号属性之间关系的规则，比如在乘法表达式中左侧的E.val要如何计算&lt;ul&gt;
&lt;li&gt;仅表明属性间“抽象”关系，不涉及计算次序等具体实现细节&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;应用：&lt;ul&gt;
&lt;li&gt;“推导类”：例如很多语言的&lt;strong&gt;编译期求值&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;“生成类”：生成AST， 中间代码等&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实现：例如在先前章节中Yacc等Parser生成器的&lt;strong&gt;语义动作&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;语义动作Semantic-Action&#34;&gt;&lt;a href=&#34;#语义动作Semantic-Action&#34; class=&#34;headerlink&#34; title=&#34;语义动作Semantic Action&#34;&gt;&lt;/a&gt;语义动作Semantic Action&lt;/h3&gt;&lt;p&gt;我们可以给产生式绑定一个语义动作，使得按照这个产生式规约时&amp;#x2F;推导时完成特定操作。&lt;/p&gt;
&lt;p&gt;每个token都可能有独属于自己的**语义值(Semantic Value)**。每种token的语义值类型可以不同，我们把A的语义值的类型称为“A的关联类型”。&lt;br&gt;例如对于产生式 $A\rightarrow B\ C\ D$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语义动作返回值必须是&lt;em&gt;A的关联类型&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;这个值可以通过B C D各自的语义值进行运算得出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如我们通过如下语义动作可以在编译期直接evaluate表达式的值：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;E-&amp;gt;E1 + T   &amp;#123; E.val= E1.val + T.val &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;E-&amp;gt;E1 – T   &amp;#123; E.val= E1.val - T.val &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;E-&amp;gt;T        &amp;#123; E.val= T.val &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;T-&amp;gt;(E)      &amp;#123; T.val= E.val &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;T-&amp;gt;num      &amp;#123; T.val= num.val &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在递归下降法中，语义动作体现为每个符号对应的parsing函数。这里我们同时关心函数的&lt;strong&gt;返回值&lt;/strong&gt;与&lt;strong&gt;副作用&lt;/strong&gt;。&lt;br&gt;因此假设T和F两个token的关联类型都是&lt;code&gt;int&lt;/code&gt;，对于表达式 $T\rightarrow T * F$ 我们可以如此实现语义动作：&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; a= T();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;eat(TIMES); &lt;span class=&#34;comment&#34;&gt;// &amp;#x27;*&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; b= F();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; a*b;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;而对于Parser生成器来说，其实现方式有所不同，以Yacc为例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用一个栈储存语义值，这个栈和状态栈是同步的&lt;/li&gt;
&lt;li&gt;当进行&lt;strong&gt;规约&lt;/strong&gt;操作时，需要执行相应的语义动作（C语言实现）&lt;ul&gt;
&lt;li&gt;可能用到的值一定可以通过多次pop语义值栈获得（和状态栈pop同步）&lt;/li&gt;
&lt;li&gt;pop完毕后运算得到的新值压入该栈（和状态栈压入新状态同步）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;抽象解析树Abstract-Parse-Tree&#34;&gt;&lt;a href=&#34;#抽象解析树Abstract-Parse-Tree&#34; class=&#34;headerlink&#34; title=&#34;抽象解析树Abstract Parse Tree&#34;&gt;&lt;/a&gt;抽象解析树Abstract Parse Tree&lt;/h3&gt;&lt;p&gt;语义动作的一种应用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;⚠和抽象语法树(Abstract Syntax Tree)的区别请参阅&lt;a href=&#34;https://stackoverflow.com/questions/5026517/whats-the-difference-between-parse-trees-and-abstract-syntax-trees-asts&#34;&gt;https://stackoverflow.com/questions/5026517/whats-the-difference-between-parse-trees-and-abstract-syntax-trees-asts&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;能否&lt;strong&gt;通过描述语义动作直接实现整个编译器&lt;/strong&gt;？可以，但是难以维护，且必须保证这些语义值的计算顺序和Parsing顺序完全一致。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;考虑分离语法解析（Parsing）和语义动作：一个可行方案是Parsing得到树，而后遍历以进行语义相关的操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们可以很容易得到一棵树：叶节点对应输入的token，内部节点对应一个语法规则。这被称为&lt;strong&gt;concrete parse tree&lt;/strong&gt;.&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/concrete-pt.png&#34; alt=&#34;concrete-pt&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缺点：太“啰嗦”。例如括号相关产生式只是为了解析顺序正确才有的，没必要放进树里。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;抽象语法树Abstract-Syntax-Tree&#34;&gt;&lt;a href=&#34;#抽象语法树Abstract-Syntax-Tree&#34; class=&#34;headerlink&#34; title=&#34;抽象语法树Abstract Syntax Tree&#34;&gt;&lt;/a&gt;抽象语法树Abstract Syntax Tree&lt;/h3&gt;&lt;p&gt;可以提供一个&lt;em&gt;干净的&lt;/em&gt;（不包含Parsing的那些繁文缛节）接口用于后续编译流程的实现或优化（编译器后端）。&lt;br&gt;生成方式：用&lt;strong&gt;具体语法&lt;/strong&gt;（Parser生成器能懂的）为&lt;strong&gt;抽象语法&lt;/strong&gt;（我们想要的、更可读的）生成抽象语法树&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/AST.png&#34; alt=&#34;AST&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为每一个非终结符定义一个类型声明，用于表示其关联类型&lt;/li&gt;
&lt;li&gt;产生式统一放进一个union（如果是Rust就是Option直接解决，&lt;del&gt;C语言太坏了&lt;/del&gt;）里，每一个产生式就是union里的一个结构体，这个结构体用于储存其子节点 &lt;img src=&#34;/compiler-construction-principles/AST-def.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;为每个产生式定义一个函数，除了计算需要的语义值返回以外，还将申请空间、分配新的树节点并设置好其子节点 &lt;img src=&#34;/compiler-construction-principles/AST-impl.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;以Yacc为例，把这些函数放入对应产生式的语义动作块中即可在规约时自动调用。随着Parsing的逐步推进，每次规约都可以产生一个新的内部节点，最终逐步构建出整颗AST&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外，通过遍历AST还能做很多：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过一些“变形”缩小树的规模，减少最终代码的大小&lt;/li&gt;
&lt;li&gt;通过一些“变形”优化树的结构，提高最终代码的性能&lt;/li&gt;
&lt;li&gt;代码内联优化&lt;/li&gt;
&lt;li&gt;静态分析，编译期推导值&lt;/li&gt;
&lt;li&gt;类型系统检查等安全检查&lt;/li&gt;
&lt;li&gt;翻译到中间表示，虽然&lt;strong&gt;AST也常被视作一种“中间表示”&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;位置Position&#34;&gt;&lt;a href=&#34;#位置Position&#34; class=&#34;headerlink&#34; title=&#34;位置Position&#34;&gt;&lt;/a&gt;位置Position&lt;/h3&gt;&lt;p&gt;在one-pass编译器中，词法分析、语法分析、语义分析是同步进行的。而错误发生时，&lt;strong&gt;词法分析器lexer&lt;/strong&gt;的位置可以用来作为错误发生位置的合理估计反馈给用户。所以，lexer存有一个全局变量维护当前位置信息。&lt;/p&gt;
&lt;p&gt;然而，对于使用AST的编译器，词法分析结束后才开始语法分析，因此这是不可行的。&lt;br&gt;解决方案：AST每个节点记录自己在源文件中的&lt;strong&gt;位置&lt;/strong&gt;，标记自己是具体哪几个字符派生而来的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;lexer把每个token的起始位置、结束位置传递给parser&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;parser维护&lt;em&gt;位置栈&lt;/em&gt;与&lt;em&gt;语义值栈&lt;/em&gt;，这样语义操作就知道位置信息了&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不是所有的Parser生成器都可以做到这一点：例如Bison可以但Yacc不行&lt;/li&gt;
&lt;li&gt;对于Yacc等无法直接实现的，可以引入新的非终结符pos（其语义值包含需要的位置信息）并改写文法。例如我们可以如此改写PLUS表达式以利用位置信息：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;%&amp;#123; extern A_OpExp(A_exp, A_binop, A_exp, position); %&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;%union &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    int num;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    string id;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    position pos;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;%type &amp;lt;pos&amp;gt; pos&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;pos: &amp;#123; $$ = EM_tokpos; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;exp: exp PLUS pos exp &amp;#123; $$ = A_OpExp($1, A_plus, $4, $3); &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Part-8-语义分析&#34;&gt;&lt;a href=&#34;#Part-8-语义分析&#34; class=&#34;headerlink&#34; title=&#34;Part 8: 语义分析&#34;&gt;&lt;/a&gt;Part 8: 语义分析&lt;/h2&gt;&lt;p&gt;我们注意到上述的属性文法等内容只适用于上下文无关文法CFG.&lt;br&gt;然而CFG有很多不足，例如我们不可能完成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;检查数组引用的维度是否匹配&lt;/li&gt;
&lt;li&gt;检查数组越界&lt;/li&gt;
&lt;li&gt;确定变量应储存于栈上还是堆上&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是因为，这些检查和值有关（涉及语义），而非语法本身。因此我们需要通过检查、遍历&lt;strong&gt;程序表示(Program Representation)&lt;strong&gt;来完成&lt;/strong&gt;（广义的）语义分析&lt;/strong&gt;。&lt;br&gt;常用的程序表示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;abstract syntax tree (AST)&lt;/li&gt;
&lt;li&gt;control flow graph (CFG)&lt;/li&gt;
&lt;li&gt;programdependence graph (PDG)&lt;/li&gt;
&lt;li&gt;valueflowgraph (VFG)&lt;/li&gt;
&lt;li&gt;single static assignment (SSA)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后我们就可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类型检查&lt;/li&gt;
&lt;li&gt;代码生成&lt;/li&gt;
&lt;li&gt;去除dead code&lt;/li&gt;
&lt;li&gt;寄存器分配&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在本课中，我们重点关注的（狭义的）语义分析指的是通过检查AST获知程序的静态属性，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作用域(Scope)与变量可见性&lt;/li&gt;
&lt;li&gt;变量、函数、表达式的类型&lt;br&gt;以及将AST转为中间代码(Intermediate Code)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;符号表Symbol-Table&#34;&gt;&lt;a href=&#34;#符号表Symbol-Table&#34; class=&#34;headerlink&#34; title=&#34;符号表Symbol Table&#34;&gt;&lt;/a&gt;符号表Symbol Table&lt;/h3&gt;&lt;p&gt;Binding:&amp;#x3D; 把类型、值等信息绑定到一个identifier上&lt;br&gt;Environment:&amp;#x3D; 一些绑定的集合，体现了程序当前环境下已声明的一些变量&amp;#x2F;函数&amp;#x2F;…&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;符号表&lt;/strong&gt;就是Environment的一种实现方式。我们在遍历AST的过程中可以维护一个符号表用于语义分析。&lt;br&gt;符号表中的重要组成部分就是各个局部变量及其作用域。当退出作用域时，自然就需要丢弃内部的一些binding.&lt;br&gt;变量在scope内重新定义时需要覆盖（屏蔽）掉更大作用域的，退出时则还原。&lt;br&gt;因此可见我们需要为符号表实现的接口包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;insert: 将名称绑定到相关信息(type, value, …), 且将覆盖已有的绑定关系（如果存在）&lt;/li&gt;
&lt;li&gt;lookup: 用名称查找信息&lt;/li&gt;
&lt;li&gt;beginScope: 进入作用域&lt;/li&gt;
&lt;li&gt;endScope: 退出作用域，将符号表恢复到进入之前的状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Java等语言中，可能有多个环境同时活跃（对应不同的module, class等），他们都需要一个符号表。这被称为多符号表。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;符号表的实现：&lt;br&gt;绑定时，如果遇到了符号已经存在的情况，我们有两种策略：&lt;ul&gt;
&lt;li&gt;Imperative Style: 直接覆盖旧的绑定，这样我们不可能lookup到旧的信息。当这个新的绑定不再有效时，需要复原旧的绑定。&lt;ul&gt;
&lt;li&gt;如何快速lookup且支持删除和复原(restore): 使用哈希表套链表储存每对binding. 我们称哈希表中的元素为bucket&lt;/li&gt;
&lt;li&gt;insert: 直接插入对应bucket的链表头。如果已经存在，由于这使得新的binding关系更靠前，这样做可以成功覆盖&lt;/li&gt;
&lt;li&gt;restore: 对应bucket的链表头弹出头部的一些元素&lt;/li&gt;
&lt;li&gt;我们会发现需要维护一些必要的额外信息（比如scope变化时应该要弹出几次）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Functional Style: 永远保留老的，只是查询时做一些额外处理（可以理解为只是renaming）。这样还原更简单。&lt;ul&gt;
&lt;li&gt;直接使用BST（红黑树等）实现查找&lt;/li&gt;
&lt;li&gt;可以使用可持久化数据结构完成删除、复原等操作，进一步降低单次操作的空间复杂度，非常方便&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两种方法均可使用。&lt;/p&gt;
&lt;h3 id=&#34;Tiger编译器符号相关的实现&#34;&gt;&lt;a href=&#34;#Tiger编译器符号相关的实现&#34; class=&#34;headerlink&#34; title=&#34;Tiger编译器符号相关的实现&#34;&gt;&lt;/a&gt;Tiger编译器符号相关的实现&lt;/h3&gt;&lt;p&gt;在哈希表中的链表进行lookup时，不断进行字符串比较是很耗时的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解决办法：使用新的数据结构将符号对象关联到一个整数上（哈希值）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Tiger编译器的environment是destructive-update的。也就是说，我们有两个函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;S_beginScope&lt;/code&gt;: 记下当前符号表的状态&lt;/li&gt;
&lt;li&gt;&lt;code&gt;S_endScope&lt;/code&gt;: 恢复到最近的、还未被恢复的&lt;code&gt;S_beginScope&lt;/code&gt;记下的状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们引入一个**辅助栈(Auxiliary stack)**来维护上文提到的必要的额外信息:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;符号入栈时，会将binding联动地插入对应bucket的链表头&lt;/li&gt;
&lt;li&gt;弹出栈顶符号时，对应bucket的链表头也会联动地被移除&lt;/li&gt;
&lt;li&gt;beginScope: 压入一个特殊标记到辅助栈中&lt;/li&gt;
&lt;li&gt;endScope: 一直弹出符号直到弹出了一个特殊标记&lt;ul&gt;
&lt;li&gt;我们可以由此标记推断：此次因为退出scope引发的restore操作可以就此结束&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;类型检查&#34;&gt;&lt;a href=&#34;#类型检查&#34; class=&#34;headerlink&#34; title=&#34;类型检查&#34;&gt;&lt;/a&gt;类型检查&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;类型系统&lt;/p&gt;
&lt;p&gt; 类型限定了变量的取值范围以及部分运算规则。&lt;br&gt; 可以大致把编程语言分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类型化的(typed): C&amp;#x2F;C++ Java Go&lt;/li&gt;
&lt;li&gt;非类型化的(untyped): LISP JavaScript&lt;ul&gt;
&lt;li&gt;注意：不是没有类型，而是类型可变&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 类型系统作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提高开发效率（高层抽象&amp;amp;指称语义）&lt;/li&gt;
&lt;li&gt;提高运行性能（指导编译优化）&lt;/li&gt;
&lt;li&gt;提高安全性（内存安全等）&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;事实上，我们可以理解为每引入一种类型就能&lt;strong&gt;完全&lt;/strong&gt;消除某一类特定错误。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 形式化的类型系统可用于数学领域，参见Coq以及&lt;a href=&#34;https://leanprover-community.github.io/&#34;&gt;LEAN&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Tiger的类型系统&lt;br&gt; 包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原始类型(primitive type): &lt;code&gt;int&lt;/code&gt;和&lt;code&gt;string&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;构造类型(constructed type): &lt;code&gt;record&lt;/code&gt;（类似结构体） 和&lt;code&gt;array&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 根据不同的判别法，&lt;strong&gt;类型等价&lt;/strong&gt;这一关系分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Name equivalence (NE): 必须声明是同一个类型才是同一类型&lt;/li&gt;
&lt;li&gt;Structure equivalence (SE): “长得一样”（内部结构一样）就是同一类型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 显然前者被广泛采用，Tiger语言也不例外。&lt;br&gt; Tiger存在两个独立的命名空间，不同命名空间的同名identifier不会互相遮蔽(hide)对方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Types&lt;/li&gt;
&lt;li&gt;Functions and variables&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Tiger的类型检查&lt;/p&gt;
&lt;p&gt;Tiger的语义分析需要两个环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Type&lt;/code&gt;: 把类型符号映射到其表示的具体类型对应的数据结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始时包含primitive type对应的映射 int $\mapsto$ Ty_int, string $\mapsto$ Ty_string&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Value&lt;/code&gt;: 把变量名映射到具体类型，把函数名映射到(参数类型, 返回值类型)（也就是函数签名）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始时包含Tiger中预定义的一些函数定义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;semant&lt;/code&gt; 模块包含类型检查等语义分析相关操作。类型检查分为两部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Type-checking expressions&lt;ul&gt;
&lt;li&gt;&lt;code&gt;transExp&lt;/code&gt;可以在给定的两个环境下将输入的表达式标记上type（如果发现非法则报错）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Type-checking declarations&lt;ul&gt;
&lt;li&gt;在Tiger语言中声明只可能在&lt;code&gt;let&lt;/code&gt;语句中出现&lt;/li&gt;
&lt;li&gt;变量声明：如果提供了变量类型，则检查初始化表达式类型是否匹配；否则直接通过初始化表达式类型获得变量类型&lt;/li&gt;
&lt;li&gt;类型声明：&lt;strong&gt;递归地&lt;/strong&gt;获取类型别名对应的实际类型。&lt;ul&gt;
&lt;li&gt;Q: 如何处理递归声明 &lt;code&gt;type list = &amp;#123;first: int, rest: list&amp;#125;&lt;/code&gt;？A: 不使用one-pass而是two-pass: pass#1: 记录声明头部（左侧）放入环境；pass#2: 完成&lt;/li&gt;
&lt;li&gt;不允许类型的直接循环引用(&lt;code&gt;type a=b;type b=a&lt;/code&gt;)：必须通过record或array完成(&lt;code&gt;type a=b;type b=&amp;#123;i:a&amp;#125;&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;函数声明：检查形参、返回值与函数体&lt;ul&gt;
&lt;li&gt;Q: 如何处理递归声明？A: 不使用one-pass而是two-pass: pass#1: 记录函数声明（签名）放入环境；pass#2: 处理函数题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;!!!以上所有内容为期中考覆盖范围&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;Part-9-活动记录Activation-Record&#34;&gt;&lt;a href=&#34;#Part-9-活动记录Activation-Record&#34; class=&#34;headerlink&#34; title=&#34;Part 9: 活动记录Activation Record&#34;&gt;&lt;/a&gt;Part 9: 活动记录Activation Record&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;其实Activation Record就是栈帧Stack Frame&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;Why-How&#34;&gt;&lt;a href=&#34;#Why-How&#34; class=&#34;headerlink&#34; title=&#34;Why &amp;amp; How&#34;&gt;&lt;/a&gt;Why &amp;amp; How&lt;/h3&gt;&lt;p&gt;编译过程需要区分代码（由PC寄存器指向）与数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高地址向低地址增长：栈Stack&lt;/li&gt;
&lt;li&gt;低地址向高地址增长：堆Heap&lt;/li&gt;
&lt;li&gt;低地址：静态数据（代码+全局变量）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;递归&amp;#x2F;调用子函数时需要在&lt;strong&gt;栈帧&lt;/strong&gt;存放当前函数的上下文信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用的参数&lt;/li&gt;
&lt;li&gt;局部变量&lt;/li&gt;
&lt;li&gt;子函数执行完毕后的返回地址&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主要寄存器：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Frame Pointer&amp;#x2F;Base Pointer 基址寄存器&lt;/li&gt;
&lt;li&gt;Stack Pointer 栈顶寄存器&lt;br&gt;例如f()中调用g():&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/ar-entering.png&#34; alt=&#34;ar-entering&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;然后g()执行完毕返回f()继续执行：&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/ar-exiting.png&#34; alt=&#34;ar-exiting&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;所以子函数是通过基址寄存器向高地址，越过返回地址获取自己的参数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;思考：为什么不开启优化的时候如下的写法可以“返回”值？&lt;/p&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;#&lt;span class=&#34;keyword&#34;&gt;include&lt;/span&gt;&lt;span class=&#34;string&#34;&gt;&amp;lt;bits/stdc++.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;namespace&lt;/span&gt; std;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; num)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; var=num+&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;comment&#34;&gt;// no return!&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; a = &lt;span class=&#34;built_in&#34;&gt;foo&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;114514&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; cout&amp;lt;&amp;lt; a &amp;lt;&amp;lt;endl; &lt;span class=&#34;comment&#34;&gt;// 114515&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;答案：如果有return语句，返回值会被push到栈帧。但是这里并没有return语句，所以本来是返回值的位置就被&lt;code&gt;var&lt;/code&gt;给“冒充”了。当然这是UB, 不能保证这种行为的可重复性（例如开启高优化级别&amp;#x2F;返回常数被编译器内联）。&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;&lt;a href=&#34;#总结&#34; class=&#34;headerlink&#34; title=&#34;总结&#34;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;p&gt;基址寄存器&amp;#x3D;FP&lt;br&gt;栈顶寄存器&amp;#x3D;SP&lt;br&gt;如果f调用g(a1, a2, …):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SP指向第一个参数a1&lt;/li&gt;
&lt;li&gt;SP减去栈帧大小（向低地址增长）得到FP&lt;br&gt;进入g:&lt;/li&gt;
&lt;li&gt;将旧的FP压入栈&lt;/li&gt;
&lt;li&gt;令新的FP&amp;#x3D;SP&lt;/li&gt;
&lt;li&gt;g可以基于FP向高地址获取参数，或向低地址压入&amp;#x2F;查询局部变量&lt;br&gt;从g退出：&lt;/li&gt;
&lt;li&gt;返回值拷贝至特殊寄存器&lt;/li&gt;
&lt;li&gt;SP&amp;#x3D;FP（释放g的栈帧）&lt;/li&gt;
&lt;li&gt;从栈上取回旧的FP值到FP中&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Part-10-寄存器与变量&#34;&gt;&lt;a href=&#34;#Part-10-寄存器与变量&#34; class=&#34;headerlink&#34; title=&#34;Part 10: 寄存器与变量&#34;&gt;&lt;/a&gt;Part 10: 寄存器与变量&lt;/h2&gt;&lt;p&gt;Intuition: 内存太慢了，使用层次化的储存提高速度(Regs-L1-L2-L3-Mem-Disks…)&lt;br&gt;所以其实并不是所有参数&amp;#x2F;局部变量都要放栈上，有时直接通过寄存器传参&amp;#x2F;保存局部变量即可。&lt;br&gt;Tiger语言：默认按值传递，函数内部改变不影响外部值&lt;br&gt;&lt;em&gt;注：函数&amp;#x2F;过程这两个词可以混用，是一个含义。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&#34;局部变量&#34;&gt;&lt;a href=&#34;#局部变量&#34; class=&#34;headerlink&#34; title=&#34;局部变量&#34;&gt;&lt;/a&gt;局部变量&lt;/h3&gt;&lt;p&gt;调用函数需要保护现场：因为寄存器的值可能会被子函数改变，返回时“现场已经被破坏”。为此部分寄存器的值需要在栈上进行备份。分为以下两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Caller-save: 例如临时寄存器，调用者如果用到则需要自己保存，子函数可以任意修改&lt;/li&gt;
&lt;li&gt;Callee-save: 例如FP&amp;#x2F;SP, 由子函数负责保存与恢复（进入子函数时push到栈，退出时从栈里pop），调用者无需关心&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;参数传递&#34;&gt;&lt;a href=&#34;#参数传递&#34; class=&#34;headerlink&#34; title=&#34;参数传递&#34;&gt;&lt;/a&gt;参数传递&lt;/h3&gt;&lt;p&gt;函数调用传参：大部分现代编译器对于前几个参数直接通过寄存器传递，多余的则仍然通过栈完成传递。&lt;br&gt;但是物理寄存器的数量是有限的：假设有如下调用链f(x)-&amp;gt;g(y)-&amp;gt;h(z), 如果所有函数都通过寄存器&lt;code&gt;r1&lt;/code&gt;接收参数，则f调用g(y)时要备份&lt;code&gt;r1&lt;/code&gt;，再将&lt;code&gt;r1&lt;/code&gt;设为要传给g的参数y.&lt;br&gt;因此，每个函数都要将&lt;code&gt;r1&lt;/code&gt;在栈上备份，带来额外的内存traffic。&lt;br&gt;优化策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从变量生命周期入手：如果寄存器对应的变量&amp;#x2F;参数在当前函数不再使用，子函数覆盖了自然也无妨&lt;/li&gt;
&lt;li&gt;全局寄存器分配策略：每个函数使用不同的一组寄存器传参&lt;/li&gt;
&lt;li&gt;优化叶过程(Leaf Procedure)：如果某函数不调用任何其他过程，自然也不需要为（不存在的）子过程备份传入的参数&lt;/li&gt;
&lt;li&gt;寄存器窗口Register Windows: 每次调用函数时，尽可能利用尚未用到的寄存器，然后为子函数分配新的一套可用的寄存器（SPARC采用该策略）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;返回值与返回地址&#34;&gt;&lt;a href=&#34;#返回值与返回地址&#34; class=&#34;headerlink&#34; title=&#34;返回值与返回地址&#34;&gt;&lt;/a&gt;返回值与返回地址&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;返回地址:&lt;br&gt;Tl;DR: 函数调用&lt;code&gt;call&lt;/code&gt;指令地址为a，则函数调用完毕应返回至地址a+1&lt;br&gt;现代机器基本将该地址保存在一个指定(designated)寄存器中。非叶过程需要在调用时把该值写入栈上，叶过程则不必。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;返回值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果可以则放置在指定寄存器中（例如X86-64使用&lt;code&gt;rax&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;如果不可以（如：返回对象太大），一般来说调用者会在自己栈帧开一个临时空间，然后将地址作为一个隐藏的参数传递给被调用函数。这样被调用方可以直接在这个空间上储存返回值，最后用寄存器（比如&lt;code&gt;eax&lt;/code&gt;&amp;#x2F;&lt;code&gt;rax&lt;/code&gt;）把返回值所在地址告诉调用者。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;关于局部变量、表达式中间值如何尽可能地利用寄存器储存，尽量减少内存traffic，以后会在&lt;em&gt;寄存器分配&lt;/em&gt;部分详细阐述。&lt;/p&gt;
&lt;h3 id=&#34;Frame-Resident-Variables&#34;&gt;&lt;a href=&#34;#Frame-Resident-Variables&#34; class=&#34;headerlink&#34; title=&#34;Frame-Resident Variables&#34;&gt;&lt;/a&gt;Frame-Resident Variables&lt;/h3&gt;&lt;p&gt;寄存器并非万能：有时，在栈上分配空间（实体化）是不可避免的。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象过大，无法放在寄存器中&lt;/li&gt;
&lt;li&gt;数组对象，需要通过地址偏移访问&lt;/li&gt;
&lt;li&gt;寄存器被特殊需要，例如上文提到可能用于传参&lt;/li&gt;
&lt;li&gt;太多中间值&amp;#x2F;局部变量，有限的寄存器放不下&lt;ul&gt;
&lt;li&gt;称为 &lt;strong&gt;“Spill”&lt;/strong&gt; 了, 在寄存器分配部分会展开讨论&lt;br&gt;以及有时变量“逃逸(escape)”了（也就是脱离了当前scope&amp;#x2F;无法确定变量有效的生命周期）：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;引用传参：需要内存地址（虽然对于现代语言经过优化并不总是需要一个地址）&lt;/li&gt;
&lt;li&gt;显式地取变量地址（C语言等）&lt;/li&gt;
&lt;li&gt;被嵌套函数访问（Tiger语言不需要考虑）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些变量就是 &lt;em&gt;frame-resident&lt;/em&gt; 的，也就是它们不得不被分配在栈帧上。&lt;/p&gt;
&lt;h2 id=&#34;Part-11-块结构Block-Structure&#34;&gt;&lt;a href=&#34;#Part-11-块结构Block-Structure&#34; class=&#34;headerlink&#34; title=&#34;Part 11: 块结构Block Structure&#34;&gt;&lt;/a&gt;Part 11: 块结构Block Structure&lt;/h2&gt;&lt;p&gt;Intuition: 在允许函数嵌套定义的语言（比如Tiger）中，内部函数可能使用外部函数中的局部变量。&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/nested-funcs.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;我们可以通过FP访问（因为定义的变量内存地址在编译时未知，&lt;strong&gt;但相对当前函数的FP偏移值(offset)是已知的&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;在编译时，如何使得内部函数访问非局部定义的外部变量呢？有以下几种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;静态链接Static Link&lt;/strong&gt;: 当内部函数&lt;code&gt;g&lt;/code&gt;被调用时，调用者&lt;code&gt;f&lt;/code&gt;传入一个指针指向&lt;code&gt;f&lt;/code&gt;的栈帧（或者说活动记录）&lt;ul&gt;
&lt;li&gt;这种情况下，我们说”&lt;code&gt;f&lt;/code&gt; statically encloses &lt;code&gt;g&lt;/code&gt;“&lt;/li&gt;
&lt;li&gt;如果多次嵌套，嵌套次数为&lt;code&gt;N&lt;/code&gt;，这些指针会构成一个长为&lt;code&gt;N&lt;/code&gt;的单向链表串联起栈帧&lt;/li&gt;
&lt;li&gt;每个函数记录自己的嵌套深度&lt;code&gt;n&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果访问了在深度&lt;code&gt;m&lt;/code&gt;的变量，只需沿着该链向上&lt;code&gt;n-m&lt;/code&gt;次就可以找到该变量所在的栈帧&lt;/li&gt;
&lt;li&gt;优缺点：Overhead小，但是因为要通过链表向上经过多层速度较慢&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;/compiler-construction-principles/static-link-nested.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意：有时&lt;code&gt;f&lt;/code&gt;中嵌套的函数&lt;code&gt;g&lt;/code&gt;不直接引用外部变量，而更里面的函数&lt;code&gt;h&lt;/code&gt;可能才会；这时&lt;code&gt;h&lt;/code&gt;的static link可以越过&lt;code&gt;g&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Lamda lifting: 从最深的一层叶过程开始，把所有&lt;code&gt;g(a1)&lt;/code&gt;用到的外部变量&lt;code&gt;o1&lt;/code&gt; &lt;code&gt;o2&lt;/code&gt;改写为真正传入的参数，于是变为&lt;code&gt;g(o1, o2, a1)&lt;/code&gt;. 如此逐渐向上改写每一层即可。&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/lambda-lifting.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;Display数组：一个全局数组，记录当前每个嵌套深度&lt;code&gt;i&lt;/code&gt;对应的栈帧地址。这样不需要经过链表即可直接找到变量对应的栈帧。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Part-12-Tiger语言：一个例子&#34;&gt;&lt;a href=&#34;#Part-12-Tiger语言：一个例子&#34; class=&#34;headerlink&#34; title=&#34;Part 12: Tiger语言：一个例子&#34;&gt;&lt;/a&gt;Part 12: Tiger语言：一个例子&lt;/h2&gt;&lt;h3 id=&#34;Tiger语言的栈帧布局-Layout&#34;&gt;&lt;a href=&#34;#Tiger语言的栈帧布局-Layout&#34; class=&#34;headerlink&#34; title=&#34;Tiger语言的栈帧布局(Layout)&#34;&gt;&lt;/a&gt;Tiger语言的栈帧布局(Layout)&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;/compiler-construction-principles/layout.png&#34; alt=&#34;layout&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;incoming parameters: 调用者传入&lt;/li&gt;
&lt;li&gt;return address: 返回&lt;code&gt;CALL&lt;/code&gt;指令&lt;/li&gt;
&lt;li&gt;local variables: 部分必须在栈帧中放置的局部变量&lt;/li&gt;
&lt;li&gt;saved registers: 该函数保存的一些寄存器值，为其他用途腾出寄存器&lt;/li&gt;
&lt;li&gt;out-going arguments: 调用其他函数时传递的参数&lt;/li&gt;
&lt;li&gt;static link: 如上所述&lt;/li&gt;
&lt;li&gt;FP&amp;#x2F;SP: 指向基址&amp;#x2F;栈顶&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;Tiger语言编译器的栈帧实现&#34;&gt;&lt;a href=&#34;#Tiger语言编译器的栈帧实现&#34; class=&#34;headerlink&#34; title=&#34;Tiger语言编译器的栈帧实现&#34;&gt;&lt;/a&gt;Tiger语言编译器的栈帧实现&lt;/h3&gt;&lt;p&gt;&lt;del&gt;看起来就不是什么会详细考的部分&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;formals &amp;#x3D; formal-parameters (不包括static link之类隐藏的参数)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;记录变量在寄存器中还是在栈帧中&lt;/li&gt;
&lt;li&gt;记录变量是否逃逸(escape)&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进入被调用函数的上下文&amp;#x3D;新的栈帧&amp;#x3D;“视角切换(view shift)”, 这是不同机器&amp;#x2F;指令集的实现需要完成的。&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/view-shift.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;💡本质上，我们在做的事和Lab3里为每一个参数分配地址，把一切读写放在内存里是一样的。只是为了效率，有时这个“地址”并不存在而是储存在寄存器中；此外有的变量会逃逸。因此我们需要实现访问的接口，对在寄存器的变量或者会逃逸的变量进行一些额外处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其他trivial话题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Temporary: 局部变量的抽象名，代表一些暂存在寄存器中的值&lt;ul&gt;
&lt;li&gt;本质上是为不同scope里的相同变量名进行重命名，类似我们在lambda演算时做的重命名等价变换： $ \lambda x.x \equiv \lambda y.y$ 所以 $\lambda x.\lambda x.x \equiv \lambda x.\lambda y.y$, 然后才能无歧义地带入x, y&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Label: 标记还不能确定的机器静态的、物理的地址&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;总结：两层抽象&#34;&gt;&lt;a href=&#34;#总结：两层抽象&#34; class=&#34;headerlink&#34; title=&#34;总结：两层抽象&#34;&gt;&lt;/a&gt;总结：两层抽象&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;/compiler-construction-principles/two-layers.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;frame.h&lt;/code&gt; &lt;code&gt;temp.h&lt;/code&gt; 封装了&lt;strong&gt;机器无关&lt;/strong&gt;的变量视角，我们无需关心是在内存还是在寄存器中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Translate&lt;/code&gt;模块用于在上述封装的基础上将高级语言翻译为有层次的、用static link连接起来的各个函数，维护函数间的层次关系；找到跨层次的、对外部变量的访问，并把每个访问定位到具体某一层函数的某一个变量上。&lt;ul&gt;
&lt;li&gt;这里，我们让Static link这一指针“伪装”成一个传给嵌套函数的参数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Part-13-中间表示-IR&#34;&gt;&lt;a href=&#34;#Part-13-中间表示-IR&#34; class=&#34;headerlink&#34; title=&#34;Part 13: 中间表示(IR)&#34;&gt;&lt;/a&gt;Part 13: 中间表示(IR)&lt;/h2&gt;&lt;h3 id=&#34;概述&#34;&gt;&lt;a href=&#34;#概述&#34; class=&#34;headerlink&#34; title=&#34;概述&#34;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;IR &amp;#x3D; Intermediate Representation&lt;/p&gt;
&lt;p&gt;编译流程划分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前端：源代码-&amp;gt;词法分析-&amp;gt;语法分析-&amp;gt;语义分析-&amp;gt;&lt;/li&gt;
&lt;li&gt;中端：IR1-&amp;gt;IR2-&amp;gt;…-&amp;gt;IRn-&amp;gt;&lt;ul&gt;
&lt;li&gt;这个过程可做一些机器无关优化（比如循环展开）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;后端：指令选择-&amp;gt;寄存器分配-&amp;gt;指令调度-&amp;gt;机器码&lt;ul&gt;
&lt;li&gt;这个过程可做一些机器相关优化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;为何需要IR&#34;&gt;&lt;a href=&#34;#为何需要IR&#34; class=&#34;headerlink&#34; title=&#34;为何需要IR&#34;&gt;&lt;/a&gt;为何需要IR&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;更模块化，更可迁移（跨平台）&lt;ul&gt;
&lt;li&gt;考虑n个语言和m种平台，如果没有IR则需要n*m个编译器；引入一个IR后先统一翻译成IR，则只需要n+m个编译器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多层的：分层应用不同的分析和优化（i.e. 变换）&lt;ul&gt;
&lt;li&gt;例如GCC, LLVM, Rust…&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可能丢失少部分机器特定的细节，但不会损失太多&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个好的IR应该简单，然后将复杂的AST翻译为IR代码，最后组合不同代码块。&lt;/p&gt;
&lt;h3 id=&#34;IR杂项&#34;&gt;&lt;a href=&#34;#IR杂项&#34; class=&#34;headerlink&#34; title=&#34;IR杂项&#34;&gt;&lt;/a&gt;IR杂项&lt;/h3&gt;&lt;p&gt;（不要求掌握）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;IR分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高层IR: 提供语言特性的检测（例如borrow checking）&lt;/li&gt;
&lt;li&gt;中层IR&lt;/li&gt;
&lt;li&gt;低层IR: 贴近目标语言，易于生成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;表示方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;结构化&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;基于图（树、无环图……）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线性Linear: 储存布局是线性的&lt;ul&gt;
&lt;li&gt;栈（虚拟）机、&lt;strong&gt;三地址码&lt;/strong&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;混合Hybrid: 节点内线性，节点间图形化&lt;ul&gt;
&lt;li&gt;经常见到的控制流图(CFG)就是一种&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;三地址码：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是一种线性的IR&lt;/li&gt;
&lt;li&gt;格式：&lt;code&gt;x = y op z&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;每个指令至多一个算符&lt;code&gt;op&lt;/code&gt;, 至多三个操作数（地址）&lt;code&gt;x&lt;/code&gt; &lt;code&gt;y&lt;/code&gt; &lt;code&gt;z&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;地址可以为：&lt;ul&gt;
&lt;li&gt;源程序中显式的变量名&lt;/li&gt;
&lt;li&gt;常量、字面量&lt;/li&gt;
&lt;li&gt;编译器生成的临时中间变量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;也可以记为一个四元组：&lt;code&gt;(op, x, y, z)&lt;/code&gt; &lt;code&gt;(unary_op, x, y, _)&lt;/code&gt; …&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;静态单赋值SSA:&lt;/p&gt;
&lt;p&gt; Lab3实现过但&lt;strong&gt;不要求掌握&lt;/strong&gt;。&lt;br&gt; SSA是特殊的三地址码：每个变量只能被赋值一次&lt;br&gt; 加速分析优化，被广泛应用（如LLVM）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;Tiger语言的IR-Tree&#34;&gt;&lt;a href=&#34;#Tiger语言的IR-Tree&#34; class=&#34;headerlink&#34; title=&#34;Tiger语言的IR Tree&#34;&gt;&lt;/a&gt;Tiger语言的IR Tree&lt;/h3&gt;&lt;p&gt;许多现代语言采用多层IR: AST-&amp;gt;IR1-&amp;gt;IR2-&amp;gt;…-&amp;gt;IRk-&amp;gt;机器码&lt;br&gt;Tiger只使用单个IR, 也就是IR Tree: AST-&amp;gt;IR Tree-&amp;gt;汇编-&amp;gt;机器码&lt;/p&gt;
&lt;p&gt;IR Tree是一种特殊的树形IR, 包含如下指令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CONST(i)&lt;/li&gt;
&lt;li&gt;NAME(n)&lt;/li&gt;
&lt;li&gt;TEMP(t)&lt;/li&gt;
&lt;li&gt;(TODO)…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;每个指令都对应IR Tree的一颗子树。指令为根，操作数为其子节点。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在这种中间表示中，我们假定有无数个寄存器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重要指令：ESEQ(s, e)&lt;/strong&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先，&lt;code&gt;s&lt;/code&gt;被执行(evaluate), 可能带有副作用(side effect)&lt;/li&gt;
&lt;li&gt;而后，&lt;code&gt;e&lt;/code&gt;被执行作为指令的值&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例如，&lt;code&gt;ESEQ(a=5, a+5)&lt;/code&gt;会返回值&lt;code&gt;10&lt;/code&gt;, 同时副作用是&lt;code&gt;a&lt;/code&gt;的值变为5&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;❗副作用&amp;#x3D;更新了内存单元或更改了寄存器的值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;从AST生成IR-Tree&#34;&gt;&lt;a href=&#34;#从AST生成IR-Tree&#34; class=&#34;headerlink&#34; title=&#34;从AST生成IR Tree&#34;&gt;&lt;/a&gt;从AST生成IR Tree&lt;/h3&gt;&lt;p&gt;&lt;del&gt;这部分看看就行&lt;/del&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;总览&lt;br&gt;Tiger语言并不区分语句(statement)和表达式。&lt;br&gt;AST中的表达式(expression)可以分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;返回数值的，记为&lt;code&gt;Ex&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;不返回数值的，记为&lt;code&gt;Nx&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;返回布尔值：用于条件跳转，记为&lt;code&gt;Cx&lt;/code&gt;&lt;br&gt; 加上一些辅助函数&lt;code&gt;unEx&lt;/code&gt; &lt;code&gt;unNx&lt;/code&gt; &lt;code&gt;unCx&lt;/code&gt;用于在不同类型之间转换。&lt;/li&gt;
&lt;li&gt;例如&lt;code&gt;flag:= (a&amp;gt;b | c&amp;lt;d)&lt;/code&gt;, 右侧是&lt;code&gt;Cx&lt;/code&gt;没有返回值，要转换成&lt;code&gt;Ex&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;表达式上下文不同，含义也不同，因此需要我们在这一步根据情况像这样进行转换&lt;/li&gt;
&lt;li&gt;说到底，IR翻译是上下文有关问题，不便用CFG刻画&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;变量翻译&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普通变量&lt;ul&gt;
&lt;li&gt;相对FP的便宜是固定的。假设偏移量为&lt;code&gt;k&lt;/code&gt;，则内存中变量的值为：&lt;code&gt;MEM(BINOP(PLUS,TEMP fp, CONST k))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;注意，对于一些常见的操作（例如加法）我们有如下简写：&lt;code&gt;BINOP(PLUS, a, b) = +(a, b)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;因此若变量&lt;code&gt;a&lt;/code&gt;在内存中为&lt;code&gt;InFrame(k)&lt;/code&gt;, 则&lt;code&gt;F_Exp(a,T_Temp(F_FP())&lt;/code&gt;翻译为&lt;code&gt;MEM(BINOP(PLUS,TEMPFP,CONST(k)))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;而如果变量&lt;code&gt;b&lt;/code&gt;在寄存器中为&lt;code&gt;InReg(t_832)&lt;/code&gt;, 则直接翻译为&lt;code&gt;TEMP(t_832)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数组变量&lt;ul&gt;
&lt;li&gt;其实就是一种固定的指针，只是没法直接拷贝（这一点取决于具体语言有所不同，Pascal就可以）&lt;/li&gt;
&lt;li&gt;Tiger语言提供&lt;code&gt;Record&lt;/code&gt;类型，类似结构体。本质上还是指针，可以（浅）拷贝&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;左值与右值&lt;br&gt; 初略的理解：&lt;br&gt; 右值：可以出现在赋值语句右侧，不能出现在左侧&lt;br&gt; 左值：可以出现在赋值语句左侧和右侧&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🤭当然C++作为一门博大精深的语言把左值、右值、纯右值、将亡值的定义和用法给玩出花来了。左值和将亡值合称泛左值(generalized lvalue&amp;#x3D;glvalue)，纯右值和将亡值合称右值(right value&amp;#x3D;rvalue)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 左值&amp;#x2F;右值各自又分为两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;标量(scalar)&lt;/strong&gt;: 只有一个元素（比如单个的变量名）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;结构化的(structured)&lt;/strong&gt;: 例如C中的结构体和数组&lt;ul&gt;
&lt;li&gt;在这种情况下，从内存中取值的指令&lt;code&gt;MEM(addr)&lt;/code&gt;要修改为&lt;code&gt;MEM(addr, size)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当然Tiger语言并不需要：因为在Tiger语言中所有变量和左值都是标量（Tiger的数组和record本质上只是指针）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;杂项&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;对于这部分内容，如果认真写过Lab3: 实现AST-&amp;gt;IR的应该可以直接无视。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;下标索引与field选择&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组：考虑&lt;code&gt;a[i]&lt;/code&gt;, 其实际地址为&lt;code&gt;(i-l)*s+a&lt;/code&gt;, 其中a为基地址，s为元素大小，l为最小索引值（l取0时即为&lt;code&gt;i*s+a&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;Record: &lt;code&gt;a.f&lt;/code&gt;地址自然是&lt;code&gt;offset(f)+a&lt;/code&gt;, 其中&lt;code&gt;offset(f)&lt;/code&gt;代表该field在Record中的固定偏移量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;内存安全&lt;/p&gt;
&lt;p&gt;内存漏洞普遍存在且危害大。&lt;br&gt;部分解决方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入额外的指令动态检查数组越界或空指针&lt;ul&gt;
&lt;li&gt;性能↓↓↓&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;静态检查：例如borrow checker&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;运算符与条件语句&lt;/p&gt;
&lt;p&gt;二元运算符的翻译是显然的。&lt;br&gt;一元运算符可以由等效的二元运算符表达式代替：&lt;code&gt;-a&lt;/code&gt; &amp;#x3D; &lt;code&gt;0-a&lt;/code&gt; …&lt;br&gt;条件表达式可以转写为条件跳转，同时还能实现短路功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If, While, For&lt;/p&gt;
&lt;p&gt;通过多个LABEL和条件跳转完成。&lt;br&gt;结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If(cond): &lt;code&gt;cjump(cond,:TRUE,:FALSE)&lt;/code&gt; &lt;code&gt;:TRUE&lt;/code&gt; &lt;code&gt;then&lt;/code&gt; &lt;code&gt;:FALSE&lt;/code&gt; &lt;code&gt;else&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;While(cond): &lt;code&gt;:TEST&lt;/code&gt; &lt;code&gt;cjump(cond,...)&lt;/code&gt; &lt;code&gt;body&lt;/code&gt; &lt;code&gt;:DONE&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;遇到break则跳转到&lt;code&gt;:DONE&lt;/code&gt;, 遇到continue则跳转到&lt;code&gt;:TEST&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;For(init;cond;each): 转写为While即可。不过要记得及时跳出循环，因此在开头和执行&lt;code&gt;each&lt;/code&gt;前都要判断&lt;code&gt;cond&lt;/code&gt;是否成立。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数调用&lt;/p&gt;
&lt;p&gt;显然的。但是记得在参数列表开头加入static link:&lt;br&gt;&lt;code&gt;CALL(NAME :LABEL_f,[SL, e1, e2, ..., en])&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;类型、变量与函数定义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;丢弃类型定义（毕竟只是别名）&lt;/li&gt;
&lt;li&gt;确定变量相对函数frame的偏移&lt;/li&gt;
&lt;li&gt;把变量初始化值转为赋值语句，插入初始化处&lt;/li&gt;
&lt;li&gt;函数定义分为三部分：&lt;ul&gt;
&lt;li&gt;prologue:&lt;ul&gt;
&lt;li&gt;函数入口的LABEL标记&lt;/li&gt;
&lt;li&gt;更改栈帧的FP&amp;#x2F;SP以创建新栈帧&lt;/li&gt;
&lt;li&gt;保存不逃逸的参数到可用寄存器&lt;/li&gt;
&lt;li&gt;保存逃逸的参数到栈帧（包含Static link）&lt;/li&gt;
&lt;li&gt;保存Callee-save的寄存器到栈帧（例如返回地址）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;body: 翻译的函数体&lt;/li&gt;
&lt;li&gt;epiloge:&lt;ul&gt;
&lt;li&gt;保存返回值到寄存器（或栈上某地址）&lt;/li&gt;
&lt;li&gt;从栈帧中恢复Callee-save的寄存器&lt;/li&gt;
&lt;li&gt;回退到调用者的栈帧（更改FP&amp;#x2F;SP）&lt;/li&gt;
&lt;li&gt;Return指令&lt;/li&gt;
&lt;li&gt;【可选】伪指令标记函数在此结束&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;重定位&lt;/p&gt;
&lt;p&gt;对于条件跳转或其他跳转指令的目的地址有可能在此时没法直接确定。例如C语言的编译单元是每个&lt;code&gt;.c&lt;/code&gt; &lt;code&gt;.h&lt;/code&gt;文件，并不知道其他文件存在，所以可能遇到如下情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要函数入口&amp;#x2F;变量的绝对地址，但目前只知道相对地址&lt;/li&gt;
&lt;li&gt;需要访问在外部定义的函数&amp;#x2F;变量，但尚未进行链接&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果都能直接通过偏移找到位置，那么就是 &lt;strong&gt;“位置无关代码(PIC)”&lt;/strong&gt; 了。&lt;br&gt;我们维护一个表记录需要待确定、需要在之后被填入的地址在哪些位置，留待日后使用。&lt;br&gt;参考ELF的&lt;a href=&#34;https://stackoverflow.com/questions/63672744/why-differentiate-rel-text-and-rel-data-section&#34;&gt;.rel.text&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Part-14-基本块与traces&#34;&gt;&lt;a href=&#34;#Part-14-基本块与traces&#34; class=&#34;headerlink&#34; title=&#34;Part 14: 基本块与traces&#34;&gt;&lt;/a&gt;Part 14: 基本块与traces&lt;/h2&gt;&lt;p&gt;&lt;em&gt;&amp;gt;&amp;gt;&amp;gt; To be continued…&lt;/em&gt;&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
