<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://cubicy.icu</id>
    <title>Cubic Y³ • Posts by &#34;course notes&#34; category</title>
    <link href="http://cubicy.icu" />
    <updated>2024-04-13T17:10:20.000Z</updated>
    <category term="CISCN" />
    <category term="web" />
    <category term="Write-Up" />
    <category term="Misc" />
    <category term="出题" />
    <category term="Hackergame" />
    <category term="SchoolBus" />
    <category term="Rust" />
    <category term="Lifetime" />
    <category term="Code" />
    <category term="Programming" />
    <category term="冰菓" />
    <category term="古籍研究社" />
    <category term="Treap" />
    <category term="BST" />
    <category term="Stack" />
    <category term="图论" />
    <category term="Kruskal" />
    <category term="Splay" />
    <category term="数链剖分" />
    <category term="持久化" />
    <category term="线段树" />
    <category term="树状数组" />
    <category term="LCA" />
    <category term="分块" />
    <category term="哈希" />
    <category term="Phar" />
    <category term="反序列化" />
    <category term="PHP" />
    <category term="Compiler" />
    <category term="Computer Science" />
    <category term="On Going" />
    <category term="Math" />
    <category term="Translation" />
    <category term="Yoneda Lemma" />
    <category term="Miscellaneous" />
    <category term="NLP" />
    <category term="Fuzzing" />
    <category term="AFL" />
    <entry>
        <id>http://cubicy.icu/compiler-construction-principles/</id>
        <title>编译原理课程笔记</title>
        <link rel="alternate" href="http://cubicy.icu/compiler-construction-principles/"/>
        <content type="html">&lt;h1 id=&#34;编译原理&#34;&gt;&lt;a href=&#34;#编译原理&#34; class=&#34;headerlink&#34; title=&#34;编译原理&#34;&gt;&lt;/a&gt;编译原理&lt;/h1&gt;&lt;h2 id=&#34;Part-0-课程信息&#34;&gt;&lt;a href=&#34;#Part-0-课程信息&#34; class=&#34;headerlink&#34; title=&#34;Part 0: 课程信息&#34;&gt;&lt;/a&gt;Part 0: 课程信息&lt;/h2&gt;&lt;p&gt;使用教材：&lt;em&gt;Modern Compiler Implementation in C&lt;/em&gt;, Andrew W. Appel （A.K.A 虎书）&lt;/p&gt;
&lt;p&gt;相关课程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://web.stanford.edu/class/cs143/&#34;&gt;Stanford课程主页&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/6035/sp21&#34;&gt;MIT课程主页&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://inst.eecs.berkeley.edu/~cs164/fa21/&#34;&gt;UCBerkeley课程主页&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分数构成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;课程作业(课后小型练习题) &amp;#x3D; 10%&lt;/li&gt;
&lt;li&gt;随堂测验&amp;#x3D; 10%&lt;/li&gt;
&lt;li&gt;期中考试&amp;#x3D; 15%&lt;/li&gt;
&lt;li&gt;综合性课程设计&amp;#x3D; 25%&lt;/li&gt;
&lt;li&gt;期末考试&amp;#x3D; 40% （斩杀线40&amp;#x2F;100）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前置知识：计算理论（笔记参考&lt;a href=&#34;https://note.tonycrane.cc/cs/tcs/toc/&#34;&gt;https://note.tonycrane.cc/cs/tcs/toc/&lt;/a&gt;）&lt;/p&gt;
&lt;h2 id=&#34;Part-1-简介&#34;&gt;&lt;a href=&#34;#Part-1-简介&#34; class=&#34;headerlink&#34; title=&#34;Part 1: 简介&#34;&gt;&lt;/a&gt;Part 1: 简介&lt;/h2&gt;&lt;p&gt;基本概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中间代码&amp;#x3D;Intermediate Code&lt;/li&gt;
&lt;li&gt;词法分析&amp;#x3D;Lexing&amp;#x2F;Scanning&amp;#x2F;LexicalAnalysis&lt;/li&gt;
&lt;li&gt;语法分析&amp;#x3D;Parsing&amp;#x2F;SyntaxAnalysis&lt;/li&gt;
&lt;li&gt;中间表示&amp;#x3D;IR&amp;#x3D;Intermediate Representation&lt;/li&gt;
&lt;li&gt;树型中间表示&amp;#x3D;IR Tree&lt;/li&gt;
&lt;li&gt;前端&amp;#x3D;，后端&amp;#x3D;&lt;br&gt;略。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Part-2-词法分析&#34;&gt;&lt;a href=&#34;#Part-2-词法分析&#34; class=&#34;headerlink&#34; title=&#34;Part 2: 词法分析&#34;&gt;&lt;/a&gt;Part 2: 词法分析&lt;/h2&gt;&lt;h3 id=&#34;词法分析概述&#34;&gt;&lt;a href=&#34;#词法分析概述&#34; class=&#34;headerlink&#34; title=&#34;词法分析概述&#34;&gt;&lt;/a&gt;词法分析概述&lt;/h3&gt;&lt;p&gt;将输入字符串识别为有意义的子串。（把基本单元划分好）&lt;br&gt;(Token单词, Lexeme词素(可选)) e.g. (IF, ) (ELSE, ) (BINARY_OP, &amp;gt;&amp;#x3D;) (UNARY_OP, &amp;amp;)&lt;/p&gt;
&lt;h3 id=&#34;正则表达式&#34;&gt;&lt;a href=&#34;#正则表达式&#34; class=&#34;headerlink&#34; title=&#34;正则表达式&#34;&gt;&lt;/a&gt;正则表达式&lt;/h3&gt;&lt;p&gt;Regex Expression &amp;#x3D; RE&lt;br&gt;运算：连接concatenation + 幂Power&lt;br&gt;e.g.: $ ab(a|b)^3c^* $&lt;br&gt;下略。&lt;/p&gt;
&lt;h3 id=&#34;有穷自动机&#34;&gt;&lt;a href=&#34;#有穷自动机&#34; class=&#34;headerlink&#34; title=&#34;有穷自动机&#34;&gt;&lt;/a&gt;有穷自动机&lt;/h3&gt;&lt;p&gt;相关概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;NFA&amp;#x2F;DFA：略&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;子集构造法subsetconstruction(NFA-&amp;gt;DFA)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DFA的每个状态是NFA的状态集合的一个子集&lt;/li&gt;
&lt;li&gt;读了输入ai后NFA能到达的所有状态：s1,s2,…,sk，则DFA到达一个状态，对应于NFA的{s1,s2,…,sk}&lt;/li&gt;
&lt;li&gt;NFA状态(集)上的一些操作定义&lt;ul&gt;
&lt;li&gt;ε-closure(s):&amp;#x3D; NFA状态s的ε-闭包&amp;#x3D;s经ε转换所能到达的状态集合&lt;/li&gt;
&lt;li&gt;ε-closure(T):&amp;#x3D; T中所有状态的ε-闭包的并集,即 $ \cup_{s\in T}{\epsilon-closure(s)} $&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;过程&lt;ol&gt;
&lt;li&gt;NFA的初始状态S的ε-闭包对应于DFA的初始状态&lt;/li&gt;
&lt;li&gt;针对每个DFA状态(对应NFA状态子集A)，求输入每个可能输入ai后能到达的NFA状态的ε-闭包并集（NFA从状态集A出发，读入ai后能到达的状态集合） $$ S&amp;#x3D;\epsilon-closure(move(A,a_i)) $$&lt;/li&gt;
&lt;li&gt;该集合S要么对应于DFA中的一个已有状态，要么令其成为一个新加的DFA状态&lt;/li&gt;
&lt;li&gt;重复上述两步，逐步构造DFA的状态转换表（每个状态集合S与每个输入ai），直到不动点（不再新增状态，且状态转移表完全求出，即对任一状态集合S已知分别接受所有输入ai将分别转移到何状态）&lt;/li&gt;
&lt;li&gt;在DFA中，只要状态集合S包含至少一个原来NFA中的终止状态，就把S标记为终止状态&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;示例（TODO）&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;/compiler-construction-principles/nfa2dfa.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Thumpson构造法(RE-&amp;gt;NFA)：略&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;词法分析器自动生成&#34;&gt;&lt;a href=&#34;#词法分析器自动生成&#34; class=&#34;headerlink&#34; title=&#34;词法分析器自动生成&#34;&gt;&lt;/a&gt;词法分析器自动生成&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;DFA最小化（-&amp;gt;状态最小的DFA，在同构意义下唯一）&lt;/li&gt;
&lt;li&gt;可区分状态：存在串s使其分别从状态s、t出发，一个接受串s，一个拒绝串s，则s与t可区分&lt;/li&gt;
&lt;li&gt;步骤：&lt;ol&gt;
&lt;li&gt;初始等价类，仅由接受状态集合和非接受状态两个集合构成&lt;/li&gt;
&lt;li&gt;用所有可能的输入ai应用于各个集合（走一步）&lt;ul&gt;
&lt;li&gt;只有集合G的每个状态读入同一字符后，都落入（包含在）相同的某个集合，该集合G在这一步才不用细分&lt;/li&gt;
&lt;li&gt;否则集合G要被细分：落入不同集合的对应状态需要被分割进不同集合&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不断重复2直到不动点（任一集合分别对所有输入ai都不可细分）&lt;/li&gt;
&lt;li&gt;此时等价类中的每个集合即对应最小DFA的一个状态。在其上可以轻松构建min-DFA，该过程是trivial的（可以每个组中选择一个状态作代表）。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;示例（TODO）&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;/compiler-construction-principles/DFA-simplify-diverge.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;/compiler-construction-principles/DFA-simplify.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;Lex工具&#34;&gt;&lt;a href=&#34;#Lex工具&#34; class=&#34;headerlink&#34; title=&#34;Lex工具&#34;&gt;&lt;/a&gt;Lex工具&lt;/h3&gt;&lt;p&gt;通常和Yacc一起使用，生成编译器的前端。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;声明部分&lt;ul&gt;
&lt;li&gt;常量：常数标识符&lt;/li&gt;
&lt;li&gt;正则规则定义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;转换规则模式{动作}&lt;ul&gt;
&lt;li&gt;模式&amp;#x3D;正则表达式&lt;/li&gt;
&lt;li&gt;动作&amp;#x3D;识别到相应模式时应调用的处理函数（一般以C语言代码表示）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;辅助函数：动作中使用的函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解决冲突：最长匹配，较前规则优先&lt;/p&gt;
&lt;h2 id=&#34;Part-3-语法分析-CFG-amp-Parsing&#34;&gt;&lt;a href=&#34;#Part-3-语法分析-CFG-amp-Parsing&#34; class=&#34;headerlink&#34; title=&#34;Part 3: 语法分析 - CFG &amp;amp; Parsing&#34;&gt;&lt;/a&gt;Part 3: 语法分析 - CFG &amp;amp; Parsing&lt;/h2&gt;&lt;h3 id=&#34;语法分析器概述&#34;&gt;&lt;a href=&#34;#语法分析器概述&#34; class=&#34;headerlink&#34; title=&#34;语法分析器概述&#34;&gt;&lt;/a&gt;语法分析器概述&lt;/h3&gt;&lt;p&gt;从词法分析器获得Token序列，确认该序列是否可以由语言的文法生成&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于语法错误的程序，报告错误信息&lt;/li&gt;
&lt;li&gt;对于语法正确的程序，生成语法分析树(简称语法树) e.g. 抽象语法树AST&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现：手动 or 自动(使用Parse generator&amp;#x3D;{Yacc, Bison, ANTLR, mehir…})&lt;/p&gt;
&lt;h3 id=&#34;上下文无关文法CFG-x3D-Context-Free-Language&#34;&gt;&lt;a href=&#34;#上下文无关文法CFG-x3D-Context-Free-Language&#34; class=&#34;headerlink&#34; title=&#34;上下文无关文法CFG&amp;#x3D;Context Free Language&#34;&gt;&lt;/a&gt;上下文无关文法CFG&amp;#x3D;Context Free Language&lt;/h3&gt;&lt;p&gt;$$ G&amp;#x3D;(T,N,P,S) $$&lt;br&gt;T：终结符集合(Terminals)&lt;br&gt;N：非终结符集合(Non-terminals)&lt;br&gt;P：产生式集合(Productions) $ A\rightarrow a, A \in N, a \in (T \cup N)^*$&lt;br&gt;S：开始符号(Startsymbol): $ S \in N $&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;📕“上下文无关”体现在：产生式左侧只有一个非终结符，因此类似 $xAy\rightarrow xay$这样，需要关心符号前后别的符号是什么才能应用的产生式是不能在CFG里的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;特殊符号：$ &amp;#x3D;end of file(EOF)&lt;br&gt;添加一个新符号S’与一条新规则以表明必须在尾部：&lt;ul&gt;
&lt;li&gt;$ S’ \rightarrow S$ $&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;产生式缩写：左侧一样的产生式可以把右侧使用”|”合并。例如 $E\rightarrow E+E|(E)|id$&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;推导Derivation和规约Reduction&#34;&gt;&lt;a href=&#34;#推导Derivation和规约Reduction&#34; class=&#34;headerlink&#34; title=&#34;推导Derivation和规约Reduction&#34;&gt;&lt;/a&gt;推导Derivation和规约Reduction&lt;/h3&gt;&lt;p&gt;例如有产生式 $A\rightarrow \gamma$，我们可以有 $\alpha A \beta \Rightarrow \alpha \gamma \beta$&lt;br&gt;那么我们说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\alpha A \beta $ &lt;strong&gt;直接推导&lt;/strong&gt;到 $ \alpha \gamma \beta$&lt;/li&gt;
&lt;li&gt;$\alpha \gamma \beta $ &lt;strong&gt;直接规约&lt;/strong&gt;到 $  \alpha A \beta$&lt;br&gt;不言而喻的&lt;strong&gt;多步推导记号&lt;/strong&gt;：$\Rightarrow^5$ $\Rightarrow^+$ $\Rightarrow^*$&lt;br&gt;分别代表五步推导，至少一步推导，0次或更多次推导&lt;/li&gt;
&lt;li&gt;推导&amp;#x3D;从文法生成语言里的句子，规约&amp;#x3D;识别句子成分并逐渐规约到开始符号&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;最左推导Left-most-Derivation&#34;&gt;&lt;a href=&#34;#最左推导Left-most-Derivation&#34; class=&#34;headerlink&#34; title=&#34;最左推导Left-most Derivation&#34;&gt;&lt;/a&gt;最左推导Left-most Derivation&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;最左推导&amp;#x3D;每步代换最左边的非终结符。逆过程为最右规约&lt;/li&gt;
&lt;li&gt;类比可得出最右推导、最左规约的定义&lt;/li&gt;
&lt;li&gt;在自顶向下的分析中，总是采用&lt;strong&gt;最左推导&lt;/strong&gt;；在自底向上的分析中，总是采用&lt;strong&gt;最左归约&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/compiler-construction-principles/lmrm.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;句型-Sentential-form-句子-Sentence-语言-Language&#34;&gt;&lt;a href=&#34;#句型-Sentential-form-句子-Sentence-语言-Language&#34; class=&#34;headerlink&#34; title=&#34;句型(Sentential form) 句子(Sentence) 语言(Language)&#34;&gt;&lt;/a&gt;句型(Sentential form) 句子(Sentence) 语言(Language)&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;句型 &amp;#x3D; 文法G下可能推导出的一个符号序列：可能包含终结符&amp;#x2F;非终结符，可为空&lt;/li&gt;
&lt;li&gt;句子 &amp;#x3D; 不含非终结符的句型（仅含终结符）&lt;/li&gt;
&lt;li&gt;语言 &amp;#x3D; 文法G可产生的所有句子的集合&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;正则文法-RE-与-上下文无关文法-CFG&#34;&gt;&lt;a href=&#34;#正则文法-RE-与-上下文无关文法-CFG&#34; class=&#34;headerlink&#34; title=&#34;正则文法(RE) 与 上下文无关文法(CFG)&#34;&gt;&lt;/a&gt;正则文法(RE) 与 上下文无关文法(CFG)&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;上下文无关语言L(G) :&amp;#x3D; CFG产生的所有句子的集合&lt;/li&gt;
&lt;li&gt;正则语言L(r) :&amp;#x3D; RE产生的所有句子的集合&lt;ul&gt;
&lt;li&gt;RE &amp;#x3D; Regex Expression &amp;#x3D; 正则表达式&lt;/li&gt;
&lt;li&gt;正则表达式r定义正则语言L(r)&lt;/li&gt;
&lt;li&gt;$ L(r) \in L(G) $：因为正则对产生式限制更大，必须为( $A,B \in N, a \in T\cup {\epsilon} $ )：&lt;ul&gt;
&lt;li&gt;左线性文法：形如 $A\rightarrow aB$ 或 $A\rightarrow a$&lt;/li&gt;
&lt;li&gt;右线性文法：形如 $A\rightarrow Ba$ 或 $A\rightarrow a$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;正则语言可用于词法分析，上下文无关语言可用于语法分析（语言描述能力、复杂性决定的）&lt;/li&gt;
&lt;li&gt;Chomsky（计算理论课程内容）: &lt;ul&gt;
&lt;li&gt;0型文法&amp;#x3D;短语结构文法 递归可枚举&lt;/li&gt;
&lt;li&gt;1型文法&amp;#x3D;上下文有关文法&lt;/li&gt;
&lt;li&gt;2型文法&amp;#x3D;CFG&lt;/li&gt;
&lt;li&gt;3型文法&amp;#x3D;RE&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;CFG的分析树Parse-Tree&#34;&gt;&lt;a href=&#34;#CFG的分析树Parse-Tree&#34; class=&#34;headerlink&#34; title=&#34;CFG的分析树Parse Tree&#34;&gt;&lt;/a&gt;CFG的分析树Parse Tree&lt;/h3&gt;&lt;p&gt;分析树性质&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根节点&amp;#x3D;文法初始符号&lt;/li&gt;
&lt;li&gt;叶节点&amp;#x3D;终结符&lt;/li&gt;
&lt;li&gt;内部节点&amp;#x3D;非终结符&lt;/li&gt;
&lt;li&gt;父节点→{叶节点}&amp;#x3D;产生式&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;语法分析-Parsing-中的挑战&#34;&gt;&lt;a href=&#34;#语法分析-Parsing-中的挑战&#34; class=&#34;headerlink&#34; title=&#34;语法分析(Parsing)中的挑战&#34;&gt;&lt;/a&gt;语法分析(Parsing)中的挑战&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;核心目标：对于终结符号串x，要么从S推导出x，要么设法将x规约到S&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自顶向下(Top-down) S-&amp;gt;x, 从&lt;strong&gt;根节点&lt;/strong&gt;开始构造Parse Tree&lt;/li&gt;
&lt;li&gt;自底向上(Bottom-up) x-&amp;gt;S, 从&lt;strong&gt;叶节点&lt;/strong&gt;开始构造Parse Tree&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作为搜索问题：搜索空间大-&amp;gt;空间大小受文法产生式限制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无限制：时间复杂度 $O(n^3)$&lt;/li&gt;
&lt;li&gt;上下文无关语言CFL 的子集需要的典型时间为 $O(n)$，例如&lt;ul&gt;
&lt;li&gt;Predictive parsing using LL(1) grammars&lt;/li&gt;
&lt;li&gt;Shift-Reduce parsing using LR(1) grammars&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;编程语言的文法设计&#34;&gt;&lt;a href=&#34;#编程语言的文法设计&#34; class=&#34;headerlink&#34; title=&#34;编程语言的文法设计&#34;&gt;&lt;/a&gt;编程语言的文法设计&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;核心：无二义性&lt;/strong&gt;&lt;br&gt;二义性来源：某些句子存在不止一棵分析树&amp;#x3D;有两个不同的最左推导&amp;#x3D;&lt;strong&gt;多种可选推导处于文法同一层&lt;/strong&gt;&lt;br&gt;例如：$$E \Rightarrow E&lt;em&gt;E \Rightarrow id&lt;/em&gt;E \Rightarrow id&lt;em&gt;E+E$$ 与 $$E \Rightarrow E+E \Rightarrow E&lt;/em&gt;E+E \Rightarrow id&lt;em&gt;E+E $$&lt;br&gt;对于”3*4+5”，前者给出3*(4+5)&amp;#x3D;27（错误），后者给出3&lt;/em&gt;4+5&amp;#x3D;17（正确）。&lt;/p&gt;
&lt;p&gt;解决办法：确保只有一种最左推导&amp;#x3D;将同一层文法分层&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;规定符号优先级（”*“” &amp;gt; “+”,”-“）&lt;ul&gt;
&lt;li&gt;越接近开始符号S的文法符号优先级越低&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;规定符号结合性（左结合&amp;#x2F;右结合）&lt;ul&gt;
&lt;li&gt;递归非终结符在终结符左边，运算就左结合&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;/compiler-construction-principles/priority.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;判定CFG二义性：不可判定问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;但可以通过给定充分条件（无二义文法）确保无二义性&lt;ul&gt;
&lt;li&gt;自顶向下：LL(1)&lt;/li&gt;
&lt;li&gt;自底向上：LR(1), LALR(1)&lt;br&gt;&lt;a name=&#34;grammars-set&#34;&gt;&lt;/a&gt;&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/grammars.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Part-4-语法分析-自顶向下&#34;&gt;&lt;a href=&#34;#Part-4-语法分析-自顶向下&#34; class=&#34;headerlink&#34; title=&#34;Part 4: 语法分析 - 自顶向下&#34;&gt;&lt;/a&gt;Part 4: 语法分析 - 自顶向下&lt;/h2&gt;&lt;p&gt;自顶向下每一步的推导都需要做出&lt;strong&gt;两个选择&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;替换哪个非终结符？&lt;/li&gt;
&lt;li&gt;应用哪个（左侧为该终结符的）产生式替换？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通用形式：&lt;strong&gt;递归下降分析(Recursive-Descent Parsing)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发生错误（没有产生式可以产生合法的子节点）就回溯&lt;/li&gt;
&lt;li&gt;问题：太慢！&lt;/li&gt;
&lt;li&gt;该过程类似NFA，能否构造类似DFA的分析方法？&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;LL-1-和预测分析法-Predictive-parsing&#34;&gt;&lt;a href=&#34;#LL-1-和预测分析法-Predictive-parsing&#34; class=&#34;headerlink&#34; title=&#34;LL(1)和预测分析法(Predictive parsing)&#34;&gt;&lt;/a&gt;LL(1)和预测分析法(Predictive parsing)&lt;/h3&gt;&lt;p&gt;预测分析法：接受LL(k)文法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个L: “left to right” 从左到右扫描&lt;/li&gt;
&lt;li&gt;第二个L: “left-most derivation” 最左推导&lt;/li&gt;
&lt;li&gt;k: 向前看k个token确定推导选用的产生式（一般k&amp;#x3D;1）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来需要添加约束使其无需回溯。我们先引入几个概念：&lt;/p&gt;
&lt;h4 id=&#34;First集和Follow集&#34;&gt;&lt;a href=&#34;#First集和Follow集&#34; class=&#34;headerlink&#34; title=&#34;First集和Follow集&#34;&gt;&lt;/a&gt;First集和Follow集&lt;/h4&gt;&lt;p&gt;给定 $ G&amp;#x3D;(T,N,P,S),\alpha \in (T\cup N)^* $&lt;br&gt;&lt;strong&gt;记空串为$\epsilon$&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;First集：可从$\alpha$推导得到的串的首个终结符的集合（也就是说，$\alpha$自己推导出的第一个终结符可能是什么）&lt;br&gt;$$ \text{First}(\alpha)&amp;#x3D;{a| \alpha \Rightarrow^*a…\ ,a\in T} $$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Follow集：从S出发，可能在推导过程中跟在A右边的终结符号集&lt;br&gt;$$ \text{Follow}(A)&amp;#x3D;{a|S\Rightarrow^*…Aa…\ ,a\in T} $$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如:S→αAaβ，终结符号 $ a\in \text{Follow}(A) $&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们至此可以使用两个条件保证产生式的选择是唯一的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$ \text{First}(\alpha)\cap \text{First}(\beta)&amp;#x3D; \emptyset $ （α和β推导不出以同一个单词为首的串）&lt;ul&gt;
&lt;li&gt;意义：显然的。这样看终结符是哪个就知道应该用哪个产生式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;若$\beta \Rightarrow^* \epsilon$，那么$\alpha \nRightarrow^* \epsilon$，且 $ \text{First}(\alpha) \cap Follow(A) &amp;#x3D; \emptyset $ （α和β不能同时推出$\epsilon$;First(α)不应在Follow(A) 中）&lt;ul&gt;
&lt;li&gt;意义：其实就是考虑如果有空串时，最后终结符因为空串没了则转而考虑Follow集以实现再向后看一个的效果。假设下一个输入是b,且$\beta \Rightarrow^* \epsilon$&lt;ul&gt;
&lt;li&gt;如果b∈First(α)，则选择A → α(属于上面1的情况)&lt;/li&gt;
&lt;li&gt;如果b∈Follow(A)，则选择A → β ,因为A最终到达了$\epsilon$，而后面紧跟着b&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下来我们会看到具体的实现方式以实现LL(1)预测分析。三步走：计算First,Follow-&amp;gt;构造预测分析表-&amp;gt;预测分析&lt;/p&gt;
&lt;h4 id=&#34;第一步：计算First-Follow&#34;&gt;&lt;a href=&#34;#第一步：计算First-Follow&#34; class=&#34;headerlink&#34; title=&#34;第一步：计算First, Follow&#34;&gt;&lt;/a&gt;第一步：计算First, Follow&lt;/h4&gt;&lt;h5 id=&#34;Nullable集&#34;&gt;&lt;a href=&#34;#Nullable集&#34; class=&#34;headerlink&#34; title=&#34;Nullable集&#34;&gt;&lt;/a&gt;Nullable集&lt;/h5&gt;&lt;p&gt;由于刚刚提到了空串，我们需要引入一个简单的新定义：Nullable集&amp;#x3D;{可推导出空串的符号}。&lt;br&gt;定义是递归的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Base Case: 如果有产生式 $ X\rightarrow \epsilon$, 那么X当然是Nullable的&lt;/li&gt;
&lt;li&gt;Inductive Case: 如果有产生式 $ X\rightarrow Y_1 Y_2 Y_3 … Y_n$, 且 $Y_1,Y_2,Y_3,…,Y_n$&lt;strong&gt;每个都能&lt;/strong&gt;推导出空串，则X是Nullable的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于每个产生式，我们可以循环用它们不断更新Nullable集直到不动点。这同样适用于First集与Follow集。&lt;/p&gt;
&lt;p&gt;First集：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Base Case: 如果X是终结符terminal: First(X)&amp;#x3D;{X}&lt;/li&gt;
&lt;li&gt;Inductive Case: 如果有产生式 $ X\rightarrow Y_1 Y_2 Y_3 … Y_n$&lt;ul&gt;
&lt;li&gt;$\text{First}(X) \cup &amp;#x3D; \text{First}(Y_1)$ ($ a\cup &amp;#x3D; b$意为$ a \leftarrow a\cup b$)&lt;/li&gt;
&lt;li&gt;如果$Y_1 \in \text{Nullable}: $$\text{First}(X) \cup &amp;#x3D; \text{First}(Y_1)$&lt;/li&gt;
&lt;li&gt;如果$Y_1,Y_2 \in \text{Nullable}: $$\text{First}(X) \cup &amp;#x3D; \text{First}(Y_2)$&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;li&gt;直到某个$Y_i \notin \text{Nullable}$则停止&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于每个产生式，我们可以循环用它们不断更新First集直到不动点。&lt;/p&gt;
&lt;p&gt;Follow集：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Base Case: $ \text{Follow}(A)&amp;#x3D;\emptyset $&lt;/li&gt;
&lt;li&gt;Inductive Case: 如果有产生式 $ B\rightarrow s_1 A\ s_2 $&lt;ul&gt;
&lt;li&gt;$\text{Follow}(A) \cup &amp;#x3D; \text{First}(s_2)$&lt;/li&gt;
&lt;li&gt;如果$s_2 \in \text{Nullable}$, $\text{Follow}(A) \cup &amp;#x3D; \text{Follow}(B)$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于每个产生式，我们可以循环用它们不断更新Follow集直到不动点。&lt;/p&gt;
&lt;p&gt;Tips(不要求掌握):Tiger book algorithm 3.13指出他们可以同时计算，感兴趣可以看看。&lt;/p&gt;
&lt;h4 id=&#34;第二步：构造预测分析表&#34;&gt;&lt;a href=&#34;#第二步：构造预测分析表&#34; class=&#34;headerlink&#34; title=&#34;第二步：构造预测分析表&#34;&gt;&lt;/a&gt;第二步：构造预测分析表&lt;/h4&gt;&lt;p&gt;&lt;del&gt;打开网站即可&lt;a href=&#34;https://jsmachines.sourceforge.net/machines/ll1.html&#34;&gt;LL(1) Parser Generator&lt;/a&gt;&lt;/del&gt;&lt;br&gt;不过这个网站对于理解第三步中PDA相关过程很有帮助。&lt;/p&gt;
&lt;p&gt;回顾自顶向下推导的两个选择题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;替换当前句型中的哪个非终结符?&lt;ul&gt;
&lt;li&gt;“Left-most”一词说明：总是选择每个句型的最左非终结符进行替换&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用该非终结符的哪个产生式进行替换? &lt;ul&gt;
&lt;li&gt;构建二维表M, 通过当前非终结符和看到的终结符决定选取何种产生式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;M的构造：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每一行A对应一个非终结符&lt;/li&gt;
&lt;li&gt;每一列a对应某个终结符或输入结束符$&lt;/li&gt;
&lt;li&gt;表中的某一格M[A,a]表示：针对当前非终结符A，下一个输入Token为终结符a时，可选的产生式集合&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;/compiler-construction-principles/tableM.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;构造：对于每个产生式 $X\rightarrow \gamma$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 $ t\in \text{First}(\gamma)$, 插入产生式 $X\rightarrow \gamma$ 到M[X,t]&lt;/li&gt;
&lt;li&gt;如果 $ \gamma \in \text{Nullable} $ 且 $t \in \text{Follow}(X)$, 插入产生式 $X\rightarrow \gamma$ 到M[X,t]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;如果某一格存在多个产生式，就说明无法确定选取哪个产生式，也就说明不是LL(1)文法！&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;第三步：预测分析&#34;&gt;&lt;a href=&#34;#第三步：预测分析&#34; class=&#34;headerlink&#34; title=&#34;第三步：预测分析&#34;&gt;&lt;/a&gt;第三步：预测分析&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;递归下降&lt;ul&gt;
&lt;li&gt;例如对于文法：&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;S -&amp;gt; E $&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;E -&amp;gt; E + T&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;E -&amp;gt; E – T&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;E -&amp;gt; T&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;T -&amp;gt; T * F&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;T -&amp;gt; T / F&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;T -&amp;gt; F&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;F -&amp;gt; id&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;F -&amp;gt; num&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;F -&amp;gt; ( E )&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
形如：&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt;)&lt;/span&gt; &amp;#123; E(); eat(EOF); &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt;)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;switch&lt;/span&gt;(tok) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;case&lt;/span&gt; ?: E(); eat(PLUS); T(); &lt;span class=&#34;keyword&#34;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;case&lt;/span&gt; ?: E(); eat(MINUS); T(); &lt;span class=&#34;keyword&#34;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;case&lt;/span&gt; ?: T(); &lt;span class=&#34;keyword&#34;&gt;break&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;default&lt;/span&gt;: error();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 问号处内容由预测分析表M决定，读者有兴趣可以帮忙验证一下这个文法是否LL(1)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;非递归下降（&lt;strong&gt;无需掌握&lt;/strong&gt;）&lt;ul&gt;
&lt;li&gt;本质上还是递归下降，只是改写成Pushdown Automata所以相当于模拟一个栈&lt;/li&gt;
&lt;li&gt;如果栈顶是非终结符A：利用预测分析表,选择产生式A -&amp;gt; a（也就是将栈顶的非终结符A替换成串a）&lt;/li&gt;
&lt;li&gt;如果栈顶是终结符a：将栈顶记号a和输入中的Token匹配并出栈&lt;/li&gt;
&lt;li&gt;初态：压入初始符号&lt;/li&gt;
&lt;li&gt;终态：输入读取完毕，栈空，此时接受&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;消除左递归、提左公因子&#34;&gt;&lt;a href=&#34;#消除左递归、提左公因子&#34; class=&#34;headerlink&#34; title=&#34;消除左递归、提左公因子&#34;&gt;&lt;/a&gt;消除左递归、提左公因子&lt;/h3&gt;&lt;p&gt;LL(1)文法的一些性质（可用于判定）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LL(1)文法是无二义的&lt;/li&gt;
&lt;li&gt;LL(1)文法是无左递归的&lt;/li&gt;
&lt;li&gt;LL(1)文法是无左公因子的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;左递归(left-recursive)文法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有非终结符A使得 $A \Rightarrow^* A\alpha$&lt;/li&gt;
&lt;li&gt;形如 $S\rightarrow Sa$ 的称为直接&amp;#x2F;立即左递归&lt;/li&gt;
&lt;li&gt;问题：这会导致递归下降分析进入无限循环&lt;ul&gt;
&lt;li&gt;$S\rightarrow Sa|b$ 分析 $baaaa$&lt;/li&gt;
&lt;li&gt;可能永远卡在”a”里而没机会考虑”b”: $ S \Rightarrow Sa \Rightarrow Saa \Rightarrow Saaa \Rightarrow Saaaa …$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;解决办法：通过文法变换消除（详见龙书）&lt;ul&gt;
&lt;li&gt;比如我们可以将这一文法：&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;A -&amp;gt; A a | b (a,b不以A开头，a不为空)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
转为右递归：&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;A -&amp;gt; b A&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;A&amp;#x27; -&amp;gt; aA&amp;#x27; | ε&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;左公因子的(left-factored)文法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$ P \rightarrow \alpha \beta | \alpha \gamma$&lt;/li&gt;
&lt;li&gt;问题：同一非终结符的多个候选式存在共同前缀，可能导致回溯&lt;/li&gt;
&lt;li&gt;解决办法：限制文法 或 文法变换&lt;ul&gt;
&lt;li&gt;例如我们可以提取左公因子来“推迟决定”，这样我们可以在读入更多token后进行决策：&lt;br&gt;把&lt;br&gt;$$ P \rightarrow \alpha \beta | \alpha \gamma $$&lt;br&gt;变换为&lt;br&gt;$$ P \rightarrow \alpha Q $$&lt;br&gt;$$ Q \rightarrow \beta | \gamma $$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;错误恢复&#34;&gt;&lt;a href=&#34;#错误恢复&#34; class=&#34;headerlink&#34; title=&#34;错误恢复&#34;&gt;&lt;/a&gt;错误恢复&lt;/h3&gt;&lt;p&gt;错误：表M中对应格是空格，没有任何可取的产生式&lt;br&gt;我们不希望遇到错误直接全盘放弃，而是令Parser报错后，尽可能从错误中恢复并继续工作，这样可以一次性尽可能报出程序里全部错误。&lt;/p&gt;
&lt;p&gt;可以通过以下几种方式恢复：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除：例如，可以一直跳过token直到遇到当前非终结符对应Follow集中的token&lt;/li&gt;
&lt;li&gt;插入：例如，如果左右括号不匹配，我们可以插入一个假装有&lt;/li&gt;
&lt;li&gt;替换：例如，变量名错误可以替换为最相近的变量名&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Part-5-语法分析-自底向上&#34;&gt;&lt;a href=&#34;#Part-5-语法分析-自底向上&#34; class=&#34;headerlink&#34; title=&#34;Part 5: 语法分析 - 自底向上&#34;&gt;&lt;/a&gt;Part 5: 语法分析 - 自底向上&lt;/h2&gt;&lt;p&gt;从串w归约为文法开始符号S的过程。规约时，一个与某产生式体&lt;strong&gt;相匹配的特定子串&lt;/strong&gt;被替换为该产生式头部的&lt;strong&gt;非终结符号&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;何时归约(归约哪些符号串)？&lt;/li&gt;
&lt;li&gt;归约到哪个非终结符号？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;回顾：LL(1)的优势劣势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;+ 运行高效(线性时间)&lt;/li&gt;
&lt;li&gt;+ 递归实现符合文法结构、适合手动构造&amp;amp;自动生成&lt;/li&gt;
&lt;li&gt;- 能分析的文法类型受限&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们提出新文法：LR(k)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表达力: Every LL(k) grammar is also LR(k)&lt;/li&gt;
&lt;li&gt;不要求无左公因式&lt;/li&gt;
&lt;li&gt;可以处理左递归文法&lt;/li&gt;
&lt;li&gt;被广泛采用(Yacc, Bison, …)&lt;/li&gt;
&lt;li&gt;“L”: left-to-right scanning 自左向右扫描&lt;/li&gt;
&lt;li&gt;“R”: right-most derivation in reverse 最右推导的逆&lt;/li&gt;
&lt;li&gt;“k”: 向前看的字符的个数(k省略时取1)&lt;/li&gt;
&lt;li&gt;子集（详见&lt;a href=&#34;#grammars-set&#34;&gt;该图&lt;/a&gt;）：LR(1), LALR(1), SLR, LR(0), …&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;LR-k-Parsing-的一般模式：移进-规约-Shift-Reduce&#34;&gt;&lt;a href=&#34;#LR-k-Parsing-的一般模式：移进-规约-Shift-Reduce&#34; class=&#34;headerlink&#34; title=&#34;LR(k) Parsing 的一般模式：移进-规约 Shift-Reduce&#34;&gt;&lt;/a&gt;LR(k) Parsing 的一般模式：移进-规约 Shift-Reduce&lt;/h3&gt;&lt;p&gt;核心思想：将字符串一分为二，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;右侧是未被parser检查过的&lt;/li&gt;
&lt;li&gt;左侧包含终结符与非终结符&lt;br&gt;我们接下来会使用”|”标记分割点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如，考虑该文法： $ E \rightarrow E+(E) | \text{int} $&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;显然并非LL(1)的：存在左递归&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们考虑处理字符串”int+(int)+(int)”，则过程如下：&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/sr.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;可见LR分析采用最右推导的&lt;strong&gt;逆过程&lt;/strong&gt;：最左规约。因此LR分析的每一步都是最右句型。&lt;br&gt;一般实现方式：采用&lt;strong&gt;栈&lt;/strong&gt;进行Shift-Reduce&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;栈：包含左侧字符串&lt;/li&gt;
&lt;li&gt;输入流：包含剩余未处理的右侧字符串&lt;/li&gt;
&lt;li&gt;操作：&lt;ul&gt;
&lt;li&gt;Shift: 从输入读入一个Terminal压入栈&lt;/li&gt;
&lt;li&gt;Reduce: 栈顶的几个元素满足某条生成式的&lt;strong&gt;RHS(Right hand side)&lt;/strong&gt;, 则pop这些元素并压入生成式的&lt;strong&gt;LHS(Left hand side)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Error&lt;/li&gt;
&lt;li&gt;Accept: shift “$” 并且栈中只剩下文法的开始符号&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;需要解决的问题：&lt;strong&gt;何时shift? 何时reduce?&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;表驱动的LR分析：类似LL文法的表，但行列意义不同，且这个表一般很大（详见后文）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;几个文法的包含关系（仍然是详见&lt;a href=&#34;#grammars-set&#34;&gt;该图&lt;/a&gt;）:&lt;br&gt;$ LR(0) \in SLR(1) \in LALR(1) \in LR(1) $&lt;/p&gt;
&lt;h3 id=&#34;LR-0-Parsing&#34;&gt;&lt;a href=&#34;#LR-0-Parsing&#34; class=&#34;headerlink&#34; title=&#34;LR(0) Parsing&#34;&gt;&lt;/a&gt;LR(0) Parsing&lt;/h3&gt;&lt;p&gt;核心思想：因为需要凑出生成式RHS，维护栈顶内容对于所有生成式右侧的“进度”。&lt;br&gt;项(Item):&amp;#x3D; 一个产生式加上在其中某处的一个点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;产生式 $A\rightarrow XYZ$ 有4个Item: &lt;ul&gt;
&lt;li&gt;$A\rightarrow \bullet XYZ $ &lt;/li&gt;
&lt;li&gt;$A\rightarrow X\bullet YZ $ &lt;/li&gt;
&lt;li&gt;$A\rightarrow XY\bullet Z $ &lt;/li&gt;
&lt;li&gt;$A\rightarrow XYZ \bullet $&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;$ A\rightarrow \alpha \bullet \beta$: 已扫描&amp;#x2F;归约到了α，并期望在接下来的输入中经过扫描&amp;#x2F;归约得到β，然后把αβ归约到A&lt;/li&gt;
&lt;li&gt;$ A\rightarrow \alpha \beta \bullet$: 已扫描&amp;#x2F;归约得到了αβ，此时已经可以把αβ归约为A&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Item类似有穷自动机的状态!&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;一个项读入一个符号后可以转变为另一个项：例如$A\rightarrow \bullet XYZ $ 读入X就可以转为 $A\rightarrow X\bullet YZ $&lt;/li&gt;
&lt;li&gt;显然项的数量是有限的。&lt;/li&gt;
&lt;li&gt;这样的有穷自动机被称为&lt;strong&gt;LR(0)自动机&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;LR-0-Parsing的NFA&#34;&gt;&lt;a href=&#34;#LR-0-Parsing的NFA&#34; class=&#34;headerlink&#34; title=&#34;LR(0)Parsing的NFA&#34;&gt;&lt;/a&gt;LR(0)Parsing的NFA&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;⚠ NFA只能识别正则语言RE，然而RE&amp;lt;LR(0). 所以这里的NFA只是用于辅助记录栈顶识别进度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;新增开始符号S’，并加入产生式” S’-&amp;gt;S$ “&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NFA起始状态：$S’\rightarrow \bullet S$ $ &lt;/li&gt;
&lt;li&gt;NFA终结状态：$S’\rightarrow S\bullet$ $ &lt;/li&gt;
&lt;li&gt;转移：&lt;ul&gt;
&lt;li&gt;$A\rightarrow \bullet XY $ 读入X就可以转为 $A\rightarrow X\bullet Y $&lt;/li&gt;
&lt;li&gt;对于产生式 $ X\rightarrow \alpha Y \beta $ 与 $Y\rightarrow \gamma$ 那么 $ X\rightarrow \alpha \bullet Y \beta $ 可以直接转换（ε-move）到 $ Y \rightarrow \bullet \gamma$ （相当于递归下降法里进入下一层递归，从而分析当前产生式内部的非终结符）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们更希望能转为DFA. 当然可以使用子集构造法转换，但事实上可以直接构造DFA.&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/lr-nfa2dfa.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;LR-0-Parsing的DFA与分析表&#34;&gt;&lt;a href=&#34;#LR-0-Parsing的DFA与分析表&#34; class=&#34;headerlink&#34; title=&#34;LR(0)Parsing的DFA与分析表&#34;&gt;&lt;/a&gt;LR(0)Parsing的DFA与分析表&lt;/h4&gt;&lt;h5 id=&#34;DFA构造&#34;&gt;&lt;a href=&#34;#DFA构造&#34; class=&#34;headerlink&#34; title=&#34;DFA构造&#34;&gt;&lt;/a&gt;DFA构造&lt;/h5&gt;&lt;p&gt;项集闭包CLOSURE:&amp;#x3D; a &lt;strong&gt;set&lt;/strong&gt; of &lt;strong&gt;items&lt;/strong&gt;, 记为I&lt;br&gt;任意符号记为X&lt;br&gt;对任意项集Closure(I)求法（其实就是ε-closure）：&lt;br&gt;Closure(I) &amp;#x3D; &lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;repeat&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  for any item A→ α•Xβ in I&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    for any production X→ γ&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      I ← I + &amp;#123;X→ •γ&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;until I does not change. &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;return I&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;TL;DR: 如果”·”的右边是非终结符X，就把X为LHS的生成式对应的初始项加入。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来的构造方式通过类比NFA-&amp;gt;DFA的子集构造法是显然的：&lt;br&gt;GOTO(I,X):&amp;#x3D; I是一个项集，X是一个文法符号，则GOTO(I,X)定义为I中所有形如 $A\rightarrow \bullet X \beta$ 的项所对应的新项 $A\rightarrow X \bullet \beta$ 构成的新集合生成的闭包（I是状态，X是转移，I里符合要求（也就是下一个符号是X）的生成式前移一位越过X加入转移到的新状态，不符合的被丢弃；当然考虑到ε-moves要再求一遍新状态的闭包）&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/lr-dfa.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/lr-dfa-eg.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;DFA到分析表&#34;&gt;&lt;a href=&#34;#DFA到分析表&#34; class=&#34;headerlink&#34; title=&#34;DFA到分析表&#34;&gt;&lt;/a&gt;DFA到分析表&lt;/h5&gt;&lt;p&gt;分析表T类似LL(1)中的表M，但是行列的含义与内容都发生了很大变化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Action表项：&lt;ul&gt;
&lt;li&gt;每一行对应一个状态i&lt;/li&gt;
&lt;li&gt;每一列对应一个&lt;strong&gt;终结符t&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;表中的一格T[i,t]代表要做的操作action，有以下几种可能：&lt;ul&gt;
&lt;li&gt;$s_n$ &amp;#x3D; shift n :&amp;#x3D; 从状态i经过&lt;strong&gt;终结符t&lt;/strong&gt;转移到状态n&lt;ul&gt;
&lt;li&gt;从输入流中取一个终结符t压入状态栈&lt;/li&gt;
&lt;li&gt;将n压入状态栈&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;$r_k$ &amp;#x3D; reduce k :&amp;#x3D; 确定使用第k个产生式进行规约（此时状态i没有出边）&lt;ul&gt;
&lt;li&gt;弹出状态栈顶的几个状态（数量对应产生式#k的RHS长度）&lt;/li&gt;
&lt;li&gt;符号栈压入产生式#k的LHS，也即一个非终结符X&lt;/li&gt;
&lt;li&gt;查询Goto表（见下文）T[i,X]将对应的下一个状态压入状态栈&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;accept :&amp;#x3D; 该状态包含 $S’\rightarrow S \bullet $ $, 接受字符串，运行完毕&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Goto表项：&lt;ul&gt;
&lt;li&gt;每一行对应一个状态i&lt;/li&gt;
&lt;li&gt;每一列对应一个&lt;strong&gt;非终结符X&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;表中的一格T[i,X]表明经过&lt;strong&gt;非终结符X&lt;/strong&gt;下一个状态是什么&lt;/li&gt;
&lt;li&gt;格中的$g_n$ &amp;#x3D; goto n :&amp;#x3D; 从状态i经过&lt;strong&gt;非终结符X&lt;/strong&gt;转移到状态n&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/compiler-construction-principles/dfa2table.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;LR实际实现只有状态栈，符号信息可从相应状态中获取&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用法：每次根据状态栈顶的那个状态与输入流的符号决定一系列操作。&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/lr0-stack-table.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;Part-6-抽象语法&#34;&gt;&lt;a href=&#34;#Part-6-抽象语法&#34; class=&#34;headerlink&#34; title=&#34;Part 6: 抽象语法&#34;&gt;&lt;/a&gt;Part 6: 抽象语法&lt;/h2&gt;&lt;h2 id=&#34;Part-7-语义分析&#34;&gt;&lt;a href=&#34;#Part-7-语义分析&#34; class=&#34;headerlink&#34; title=&#34;Part 7: 语义分析&#34;&gt;&lt;/a&gt;Part 7: 语义分析&lt;/h2&gt;&lt;p&gt;&lt;em&gt;&amp;gt;&amp;gt;&amp;gt; To be continued…&lt;/em&gt;&lt;/p&gt;
</content>
        <category term="Compiler" />
        <category term="Computer Science" />
        <category term="On Going" />
        <updated>2024-04-13T17:10:20.000Z</updated>
    </entry>
</feed>
