{
    "version": "https://jsonfeed.org/version/1",
    "title": "Cubic Y³ • All posts by \"compiler construction principles\" category",
    "description": "Notes, CTF, DIY, thoughts and waifus.\n\nI'm CubicYYY, an undergraduate student majoring in Computer Science at Zhejiang University.\nLearning: Electric guitar\n❤❤❤ CTF, toy projects, anime\n✖✖✖ Technological supremacy\nResume is [here](https://latexonline.cc/compile?git=https://github.com/cubicYYY/resume&target=resume.tex&command=xelatex).",
    "home_page_url": "http://cubicy.icu",
    "items": [
        {
            "id": "http://cubicy.icu/compiler-construction-principles/",
            "url": "http://cubicy.icu/compiler-construction-principles/",
            "title": "编译原理课程笔记",
            "date_published": "2024-04-13T17:10:20.000Z",
            "content_html": "<h1 id=\"编译原理\"><a href=\"#编译原理\" class=\"headerlink\" title=\"编译原理\"></a>编译原理</h1><p>文中部分图片与文字来自于姚老师(ZJU, pyaoaa at zju.edu.cn)</p>\n<h2 id=\"Part-0-课程信息\"><a href=\"#Part-0-课程信息\" class=\"headerlink\" title=\"Part 0: 课程信息\"></a>Part 0: 课程信息</h2><p>使用教材：<em>Modern Compiler Implementation in C</em>, Andrew W. Appel （A.K.A 虎书）</p>\n<p>相关课程：</p>\n<ul>\n<li><a href=\"http://web.stanford.edu/class/cs143/\">Stanford课程主页</a></li>\n<li><a href=\"https://github.com/6035/sp21\">MIT课程主页</a></li>\n<li><a href=\"https://inst.eecs.berkeley.edu/~cs164/fa21/\">UCBerkeley课程主页</a></li>\n</ul>\n<p>分数构成：</p>\n<ul>\n<li>课程作业(课后小型练习题) &#x3D; 10%</li>\n<li>随堂测验&#x3D; 10%</li>\n<li>期中考试&#x3D; 15%</li>\n<li>综合性课程设计&#x3D; 25%</li>\n<li>期末考试&#x3D; 40% （斩杀线40&#x2F;100）</li>\n</ul>\n<p>前置知识：计算理论（笔记参考<a href=\"https://note.tonycrane.cc/cs/tcs/toc/\">https://note.tonycrane.cc/cs/tcs/toc/</a>）</p>\n<h2 id=\"Part-1-简介\"><a href=\"#Part-1-简介\" class=\"headerlink\" title=\"Part 1: 简介\"></a>Part 1: 简介</h2><p>基本概念：</p>\n<ul>\n<li>中间代码&#x3D;Intermediate Code</li>\n<li>词法分析&#x3D;Lexing&#x2F;Scanning&#x2F;LexicalAnalysis</li>\n<li>语法分析&#x3D;Parsing&#x2F;SyntaxAnalysis</li>\n<li>中间表示&#x3D;IR&#x3D;Intermediate Representation</li>\n<li>树型中间表示&#x3D;IR Tree</li>\n<li>前端，后端<br>略。</li>\n</ul>\n<h2 id=\"Part-2-词法分析\"><a href=\"#Part-2-词法分析\" class=\"headerlink\" title=\"Part 2: 词法分析\"></a>Part 2: 词法分析</h2><h3 id=\"词法分析概述\"><a href=\"#词法分析概述\" class=\"headerlink\" title=\"词法分析概述\"></a>词法分析概述</h3><p>将输入字符串识别为有意义的子串。（把基本单元划分好）<br>(Token单词, Lexeme词素(可选)) e.g. (IF, ) (ELSE, ) (BINARY_OP, &gt;&#x3D;) (UNARY_OP, &amp;)</p>\n<h3 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h3><p>Regex Expression &#x3D; RE<br>运算：连接concatenation + 幂Power<br>e.g.: $ ab(a|b)^3c^* $<br>下略。</p>\n<h3 id=\"有穷自动机\"><a href=\"#有穷自动机\" class=\"headerlink\" title=\"有穷自动机\"></a>有穷自动机</h3><p>相关概念：</p>\n<ul>\n<li><p>NFA&#x2F;DFA：略</p>\n</li>\n<li><p>子集构造法subsetconstruction(NFA-&gt;DFA)</p>\n<ul>\n<li>DFA的每个状态是NFA的状态集合的一个子集</li>\n<li>读了输入ai后NFA能到达的所有状态：s1,s2,…,sk，则DFA到达一个状态，对应于NFA的{s1,s2,…,sk}</li>\n<li>NFA状态(集)上的一些操作定义<ul>\n<li>ε-closure(s):&#x3D; NFA状态s的ε-闭包&#x3D;s经ε转换所能到达的状态集合</li>\n<li>ε-closure(T):&#x3D; T中所有状态的ε-闭包的并集,即 $ \\cup_{s\\in T}{\\epsilon-closure(s)} $</li>\n</ul>\n</li>\n<li>过程<ol>\n<li>NFA的初始状态S的ε-闭包对应于DFA的初始状态</li>\n<li>针对每个DFA状态(对应NFA状态子集A)，求输入每个可能输入ai后能到达的NFA状态的ε-闭包并集（NFA从状态集A出发，读入ai后能到达的状态集合） $$ S&#x3D;\\epsilon-closure(move(A,a_i)) $$</li>\n<li>该集合S要么对应于DFA中的一个已有状态，要么令其成为一个新加的DFA状态</li>\n<li>重复上述两步，逐步构造DFA的状态转换表（每个状态集合S与每个输入ai），直到不动点（不再新增状态，且状态转移表完全求出，即对任一状态集合S已知分别接受所有输入ai将分别转移到何状态）</li>\n<li>在DFA中，只要状态集合S包含至少一个原来NFA中的终止状态，就把S标记为终止状态</li>\n</ol>\n</li>\n<li>示例（TODO）<ul>\n<li><img src=\"/compiler-construction-principles/nfa2dfa.png\" loading=\"lazy\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Thumpson构造法(RE-&gt;NFA)：略</p>\n</li>\n</ul>\n<h3 id=\"词法分析器自动生成\"><a href=\"#词法分析器自动生成\" class=\"headerlink\" title=\"词法分析器自动生成\"></a>词法分析器自动生成</h3><ul>\n<li>DFA最小化（-&gt;状态最小的DFA，在同构意义下唯一）</li>\n<li>可区分状态：存在串s使其分别从状态s、t出发，一个接受串s，一个拒绝串s，则s与t可区分</li>\n<li>步骤：<ol>\n<li>初始等价类，仅由接受状态集合和非接受状态两个集合构成</li>\n<li>用所有可能的输入ai应用于各个集合（走一步）<ul>\n<li>只有集合G的每个状态读入同一字符后，都落入（包含在）相同的某个集合，该集合G在这一步才不用细分</li>\n<li>否则集合G要被细分：落入不同集合的对应状态需要被分割进不同集合</li>\n</ul>\n</li>\n<li>不断重复2直到不动点（任一集合分别对所有输入ai都不可细分）</li>\n<li>此时等价类中的每个集合即对应最小DFA的一个状态。在其上可以轻松构建min-DFA，该过程是trivial的（可以每个组中选择一个状态作代表）。</li>\n</ol>\n</li>\n<li>示例（TODO）<ul>\n<li><img src=\"/compiler-construction-principles/DFA-simplify-diverge.png\" loading=\"lazy\"></li>\n<li><img src=\"/compiler-construction-principles/DFA-simplify.png\" loading=\"lazy\"></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lex工具\"><a href=\"#Lex工具\" class=\"headerlink\" title=\"Lex工具\"></a>Lex工具</h3><p>通常和Yacc一起使用，生成编译器的前端。</p>\n<ul>\n<li>声明部分<ul>\n<li>常量：常数标识符</li>\n<li>正则规则定义</li>\n</ul>\n</li>\n<li>转换规则模式{动作}<ul>\n<li>模式&#x3D;正则表达式</li>\n<li>动作&#x3D;识别到相应模式时应调用的处理函数（一般以C语言代码表示）</li>\n</ul>\n</li>\n<li>辅助函数：动作中使用的函数</li>\n</ul>\n<p>解决冲突：最长匹配，较前规则优先</p>\n<h2 id=\"Part-3-语法分析-CFG-Parsing\"><a href=\"#Part-3-语法分析-CFG-Parsing\" class=\"headerlink\" title=\"Part 3: 语法分析 - CFG &amp; Parsing\"></a>Part 3: 语法分析 - CFG &amp; Parsing</h2><h3 id=\"语法分析器概述\"><a href=\"#语法分析器概述\" class=\"headerlink\" title=\"语法分析器概述\"></a>语法分析器概述</h3><p>从词法分析器获得Token序列，确认该序列是否可以由语言的文法生成</p>\n<ul>\n<li>对于语法错误的程序，报告错误信息</li>\n<li>对于语法正确的程序，生成语法分析树(简称语法树) e.g. 抽象语法树AST</li>\n</ul>\n<p>实现：手动 or 自动(使用Parse generator&#x3D;{Yacc, Bison, ANTLR, mehir…})</p>\n<h3 id=\"上下文无关文法CFG\"><a href=\"#上下文无关文法CFG\" class=\"headerlink\" title=\"上下文无关文法CFG\"></a>上下文无关文法CFG</h3><p>CFG &#x3D; Context Free Language</p>\n<p>$$ G&#x3D;(T,N,P,S) $$<br>T：终结符集合(Terminals)<br>N：非终结符集合(Non-terminals)<br>P：产生式集合(Productions) $ A\\rightarrow a, A \\in N, a \\in (T \\cup N)^*$<br>S：开始符号(Startsymbol): $ S \\in N $</p>\n<blockquote>\n<p>📕“上下文无关”体现在：产生式左侧只有一个非终结符，因此类似 $xAy\\rightarrow xay$这样，需要关心符号前后别的符号是什么才能应用的产生式是不能在CFG里的。</p>\n</blockquote>\n<ul>\n<li>特殊符号：$ &#x3D;end of file(EOF)<br>添加一个新符号S’与一条新规则以表明必须在尾部：<ul>\n<li>$ S’ \\rightarrow S$ $</li>\n</ul>\n</li>\n<li>产生式缩写：左侧一样的产生式可以把右侧使用”|”合并。例如 $E\\rightarrow E+E|(E)|id$</li>\n</ul>\n<h3 id=\"推导Derivation和规约Reduction\"><a href=\"#推导Derivation和规约Reduction\" class=\"headerlink\" title=\"推导Derivation和规约Reduction\"></a>推导Derivation和规约Reduction</h3><p>例如有产生式 $A\\rightarrow \\gamma$，我们可以有 $\\alpha A \\beta \\Rightarrow \\alpha \\gamma \\beta$<br>那么我们说：</p>\n<ul>\n<li>$\\alpha A \\beta $ <strong>直接推导</strong>到 $ \\alpha \\gamma \\beta$</li>\n<li>$\\alpha \\gamma \\beta $ <strong>直接规约</strong>到 $  \\alpha A \\beta$<br>不言而喻的<strong>多步推导记号</strong>：$\\Rightarrow^5$ $\\Rightarrow^+$ $\\Rightarrow^*$<br>分别代表五步推导，至少一步推导，0次或更多次推导</li>\n<li>推导&#x3D;从文法生成语言里的句子，规约&#x3D;识别句子成分并逐渐规约到开始符号</li>\n</ul>\n<h4 id=\"最左推导Left-most-Derivation\"><a href=\"#最左推导Left-most-Derivation\" class=\"headerlink\" title=\"最左推导Left-most Derivation\"></a>最左推导Left-most Derivation</h4><ul>\n<li>最左推导&#x3D;每步代换最左边的非终结符。逆过程为最右规约</li>\n<li>类比可得出最右推导、最左规约的定义</li>\n<li>在自顶向下的分析中，总是采用<strong>最左推导</strong>；在自底向上的分析中，总是采用<strong>最左归约</strong></li>\n</ul>\n<p><img src=\"/compiler-construction-principles/lmrm.png\" loading=\"lazy\"></p>\n<h4 id=\"句型-Sentential-form-句子-Sentence-语言-Language\"><a href=\"#句型-Sentential-form-句子-Sentence-语言-Language\" class=\"headerlink\" title=\"句型(Sentential form) 句子(Sentence) 语言(Language)\"></a>句型(Sentential form) 句子(Sentence) 语言(Language)</h4><ul>\n<li>句型 &#x3D; 文法G下可能推导出的一个符号序列：可能包含终结符&#x2F;非终结符，可为空</li>\n<li>句子 &#x3D; 不含非终结符的句型（仅含终结符）</li>\n<li>语言 &#x3D; 文法G可产生的所有句子的集合</li>\n</ul>\n<h4 id=\"正则文法-RE-与-上下文无关文法-CFG\"><a href=\"#正则文法-RE-与-上下文无关文法-CFG\" class=\"headerlink\" title=\"正则文法(RE) 与 上下文无关文法(CFG)\"></a>正则文法(RE) 与 上下文无关文法(CFG)</h4><ul>\n<li>上下文无关语言L(G) :&#x3D; CFG产生的所有句子的集合</li>\n<li>正则语言L(r) :&#x3D; RE产生的所有句子的集合<ul>\n<li>RE &#x3D; Regex Expression &#x3D; 正则表达式</li>\n<li>正则表达式r定义正则语言L(r)</li>\n<li>$ L(r) \\in L(G) $：因为正则对产生式限制更大，必须为( $A,B \\in N, a \\in T\\cup {\\epsilon} $ )：<ul>\n<li>左线性文法：形如 $A\\rightarrow aB$ 或 $A\\rightarrow a$</li>\n<li>右线性文法：形如 $A\\rightarrow Ba$ 或 $A\\rightarrow a$</li>\n</ul>\n</li>\n<li>正则语言可用于词法分析，上下文无关语言可用于语法分析（语言描述能力、复杂性决定的）</li>\n<li>Chomsky（计算理论课程内容）: <ul>\n<li>0型文法&#x3D;短语结构文法 递归可枚举</li>\n<li>1型文法&#x3D;上下文有关文法</li>\n<li>2型文法&#x3D;CFG</li>\n<li>3型文法&#x3D;RE</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"CFG的分析树Parse-Tree\"><a href=\"#CFG的分析树Parse-Tree\" class=\"headerlink\" title=\"CFG的分析树Parse Tree\"></a>CFG的分析树Parse Tree</h3><p>分析树性质</p>\n<ul>\n<li>根节点&#x3D;文法初始符号</li>\n<li>叶节点&#x3D;终结符</li>\n<li>内部节点&#x3D;非终结符</li>\n<li>父节点→{叶节点}&#x3D;产生式</li>\n</ul>\n<h4 id=\"语法分析-Parsing-中的挑战\"><a href=\"#语法分析-Parsing-中的挑战\" class=\"headerlink\" title=\"语法分析(Parsing)中的挑战\"></a>语法分析(Parsing)中的挑战</h4><p><strong>核心目标：对于终结符号串x，要么从S推导出x，要么设法将x规约到S</strong></p>\n<ul>\n<li>自顶向下(Top-down) S-&gt;x, 从<strong>根节点</strong>开始构造Parse Tree</li>\n<li>自底向上(Bottom-up) x-&gt;S, 从<strong>叶节点</strong>开始构造Parse Tree</li>\n</ul>\n<p>作为搜索问题：搜索空间大-&gt;空间大小受文法产生式限制</p>\n<ul>\n<li>无限制：时间复杂度 $O(n^3)$</li>\n<li>上下文无关语言CFL 的子集需要的典型时间为 $O(n)$，例如<ul>\n<li>Predictive parsing using LL(1) grammars</li>\n<li>Shift-Reduce parsing using LR(1) grammars</li>\n<li>…</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"编程语言的文法设计\"><a href=\"#编程语言的文法设计\" class=\"headerlink\" title=\"编程语言的文法设计\"></a>编程语言的文法设计</h4><p><strong>核心：无二义性</strong><br>二义性来源：某些句子存在不止一棵分析树&#x3D;有两个不同的最左推导&#x3D;<strong>多种可选推导处于文法同一层</strong><br>例如：$$E \\Rightarrow E*E \\Rightarrow id*E \\Rightarrow id*E+E$$ 与 $$E \\Rightarrow E+E \\Rightarrow E*E+E \\Rightarrow id*E+E $$<br>对于”3*4+5”，前者给出3*(4+5)&#x3D;27（错误），后者给出3*4+5&#x3D;17（正确）。</p>\n<p>解决办法：确保只有一种最左推导&#x3D;将同一层文法分层</p>\n<ul>\n<li>规定符号优先级（”*“” &gt; “+”,”-“）<ul>\n<li>越接近开始符号S的文法符号优先级越低</li>\n</ul>\n</li>\n<li>规定符号结合性（左结合&#x2F;右结合）<ul>\n<li>递归非终结符在终结符左边，运算就左结合</li>\n<li><img src=\"/compiler-construction-principles/priority.png\" loading=\"lazy\"></li>\n</ul>\n</li>\n</ul>\n<p>判定CFG二义性：不可判定问题</p>\n<ul>\n<li>但可以通过给定充分条件（无二义文法）确保无二义性<ul>\n<li>自顶向下：LL(1)</li>\n<li>自底向上：LR(1), LALR(1)<br><a name=\"grammars-set\"></a><br><img src=\"/compiler-construction-principles/grammars.png\" loading=\"lazy\"></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Part-4-语法分析-自顶向下\"><a href=\"#Part-4-语法分析-自顶向下\" class=\"headerlink\" title=\"Part 4: 语法分析 - 自顶向下\"></a>Part 4: 语法分析 - 自顶向下</h2><p>自顶向下每一步的推导都需要做出<strong>两个选择</strong>：</p>\n<ul>\n<li>替换哪个非终结符？</li>\n<li>应用哪个（左侧为该终结符的）产生式替换？</li>\n</ul>\n<p>通用形式：<strong>递归下降分析(Recursive-Descent Parsing)</strong></p>\n<ul>\n<li>发生错误（没有产生式可以产生合法的子节点）就回溯</li>\n<li>问题：太慢！</li>\n<li>该过程类似NFA，能否构造类似DFA的分析方法？</li>\n</ul>\n<h3 id=\"LL-1-和预测分析法\"><a href=\"#LL-1-和预测分析法\" class=\"headerlink\" title=\"LL(1)和预测分析法\"></a>LL(1)和预测分析法</h3><p>预测分析法(Predictive parsing)：接受LL(k)文法</p>\n<ul>\n<li>第一个L: “left to right” 从左到右扫描</li>\n<li>第二个L: “left-most derivation” 最左推导</li>\n<li>k: 向前看k个token确定推导选用的产生式（一般k&#x3D;1）</li>\n</ul>\n<p>接下来需要添加约束使其无需回溯。我们先引入几个概念：</p>\n<h4 id=\"First集和Follow集\"><a href=\"#First集和Follow集\" class=\"headerlink\" title=\"First集和Follow集\"></a>First集和Follow集</h4><p>给定 $ G&#x3D;(T,N,P,S),\\alpha \\in (T\\cup N)^* $<br><strong>记空串为$\\epsilon$</strong></p>\n<ul>\n<li><p>First集：可从$\\alpha$推导得到的串的首个终结符的集合（也就是说，$\\alpha$自己推导出的第一个终结符可能是什么）<br>$$ \\text{First}(\\alpha)&#x3D;{a| \\alpha \\Rightarrow^*a…\\ ,a\\in T} $$</p>\n</li>\n<li><p>Follow集：从S出发，可能在推导过程中跟在A右边的终结符号集<br>$$ \\text{Follow}(A)&#x3D;{a|S\\Rightarrow^*…Aa…\\ ,a\\in T} $$</p>\n<ul>\n<li>例如:S→αAaβ，终结符号 $ a\\in \\text{Follow}(A) $</li>\n</ul>\n</li>\n</ul>\n<p>我们至此可以使用两个条件保证产生式的选择是唯一的：</p>\n<ol>\n<li>$ \\text{First}(\\alpha)\\cap \\text{First}(\\beta)&#x3D; \\emptyset $ （α和β推导不出以同一个单词为首的串）<ul>\n<li>意义：显然的。这样看终结符是哪个就知道应该用哪个产生式。</li>\n</ul>\n</li>\n<li>若$\\beta \\Rightarrow^* \\epsilon$，那么$\\alpha \\nRightarrow^* \\epsilon$，且 $ \\text{First}(\\alpha) \\cap Follow(A) &#x3D; \\emptyset $ （α和β不能同时推出$\\epsilon$;First(α)不应在Follow(A) 中）<ul>\n<li>意义：其实就是考虑如果有空串时，最后终结符因为空串没了则转而考虑Follow集以实现再向后看一个的效果。假设下一个输入是b,且$\\beta \\Rightarrow^* \\epsilon$<ul>\n<li>如果b∈First(α)，则选择A → α(属于上面1的情况)</li>\n<li>如果b∈Follow(A)，则选择A → β ,因为A最终到达了$\\epsilon$，而后面紧跟着b</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p>接下来我们会看到具体的实现方式以实现LL(1)预测分析。三步走：计算First,Follow-&gt;构造预测分析表-&gt;预测分析</p>\n<h4 id=\"第一步：计算First-Follow\"><a href=\"#第一步：计算First-Follow\" class=\"headerlink\" title=\"第一步：计算First, Follow\"></a>第一步：计算First, Follow</h4><h5 id=\"Nullable集\"><a href=\"#Nullable集\" class=\"headerlink\" title=\"Nullable集\"></a>Nullable集</h5><p>由于刚刚提到了空串，我们需要引入一个简单的新定义：Nullable集&#x3D;{可推导出空串的符号}。<br>定义是递归的：</p>\n<ul>\n<li>Base Case: 如果有产生式 $ X\\rightarrow \\epsilon$, 那么X当然是Nullable的</li>\n<li>Inductive Case: 如果有产生式 $ X\\rightarrow Y_1 Y_2 Y_3 … Y_n$, 且 $Y_1,Y_2,Y_3,…,Y_n$<strong>每个都能</strong>推导出空串，则X是Nullable的</li>\n</ul>\n<p>对于每个产生式，我们可以循环用它们不断更新Nullable集直到不动点。这同样适用于First集与Follow集。</p>\n<p>First集：</p>\n<ul>\n<li>Base Case: 如果X是终结符terminal: First(X)&#x3D;{X}</li>\n<li>Inductive Case: 如果有产生式 $ X\\rightarrow Y_1 Y_2 Y_3 … Y_n$<ul>\n<li>$\\text{First}(X) \\cup &#x3D; \\text{First}(Y_1)$ ($ a\\cup &#x3D; b$意为$ a \\leftarrow a\\cup b$)</li>\n<li>如果$Y_1 \\in \\text{Nullable}: $$\\text{First}(X) \\cup &#x3D; \\text{First}(Y_1)$</li>\n<li>如果$Y_1,Y_2 \\in \\text{Nullable}: $$\\text{First}(X) \\cup &#x3D; \\text{First}(Y_2)$</li>\n<li>…</li>\n<li>直到某个$Y_i \\notin \\text{Nullable}$则停止</li>\n</ul>\n</li>\n</ul>\n<p>对于每个产生式，我们可以循环用它们不断更新First集直到不动点。</p>\n<p>Follow集：</p>\n<ul>\n<li>Base Case: $ \\text{Follow}(A)&#x3D;\\emptyset $</li>\n<li>Inductive Case: 如果有产生式 $ B\\rightarrow s_1 A\\ s_2 $<ul>\n<li>$\\text{Follow}(A) \\cup &#x3D; \\text{First}(s_2)$</li>\n<li>如果$s_2 \\in \\text{Nullable}$, $\\text{Follow}(A) \\cup &#x3D; \\text{Follow}(B)$</li>\n</ul>\n</li>\n</ul>\n<p>对于每个产生式，我们可以循环用它们不断更新Follow集直到不动点。</p>\n<p>Tips(不要求掌握):Tiger book algorithm 3.13指出他们可以同时计算，感兴趣可以看看。</p>\n<h4 id=\"第二步：构造预测分析表\"><a href=\"#第二步：构造预测分析表\" class=\"headerlink\" title=\"第二步：构造预测分析表\"></a>第二步：构造预测分析表</h4><p><del>打开网站即可<a href=\"https://jsmachines.sourceforge.net/machines/ll1.html\">LL(1) Parser Generator</a></del><br>不过这个网站对于理解第三步中PDA相关过程很有帮助。</p>\n<p>回顾自顶向下推导的两个选择题：</p>\n<ul>\n<li>替换当前句型中的哪个非终结符?<ul>\n<li>“Left-most”一词说明：总是选择每个句型的最左非终结符进行替换</li>\n</ul>\n</li>\n<li>用该非终结符的哪个产生式进行替换? <ul>\n<li>构建二维表M, 通过当前非终结符和看到的终结符决定选取何种产生式</li>\n</ul>\n</li>\n</ul>\n<p>M的构造：</p>\n<ul>\n<li>每一行A对应一个非终结符</li>\n<li>每一列a对应某个终结符或输入结束符$</li>\n<li>表中的某一格M[A,a]表示：针对当前非终结符A，下一个输入Token为终结符a时，可选的产生式集合</li>\n<li><img src=\"/compiler-construction-principles/tableM.png\" loading=\"lazy\"></li>\n</ul>\n<p>构造：对于每个产生式 $X\\rightarrow \\gamma$</p>\n<ul>\n<li>如果 $ t\\in \\text{First}(\\gamma)$, 插入产生式 $X\\rightarrow \\gamma$ 到M[X,t]</li>\n<li>如果 $ \\gamma \\in \\text{Nullable} $ 且 $t \\in \\text{Follow}(X)$, 插入产生式 $X\\rightarrow \\gamma$ 到M[X,t]</li>\n</ul>\n<p><strong>如果某一格存在多个产生式，就说明无法确定选取哪个产生式，也就说明不是LL(1)文法！</strong></p>\n<h4 id=\"第三步：预测分析\"><a href=\"#第三步：预测分析\" class=\"headerlink\" title=\"第三步：预测分析\"></a>第三步：预测分析</h4><ul>\n<li>递归下降<ul>\n<li>例如对于文法：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">S -&gt; E $</span><br><span class=\"line\">E -&gt; E + T</span><br><span class=\"line\">E -&gt; E – T</span><br><span class=\"line\">E -&gt; T</span><br><span class=\"line\">T -&gt; T * F</span><br><span class=\"line\">T -&gt; T / F</span><br><span class=\"line\">T -&gt; F</span><br><span class=\"line\">F -&gt; id</span><br><span class=\"line\">F -&gt; num</span><br><span class=\"line\">F -&gt; ( E )</span><br></pre></td></tr></table></figure>\n形如：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">S</span><span class=\"params\">(<span class=\"type\">void</span>)</span> &#123; E(); eat(EOF); &#125; </span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">E</span><span class=\"params\">(<span class=\"type\">void</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span>(tok) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">case</span> ?: E(); eat(PLUS); T(); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> ?: E(); eat(MINUS); T(); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> ?: T(); <span class=\"keyword\">break</span>; </span><br><span class=\"line\">    <span class=\"keyword\">default</span>: error();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 问号处内容由预测分析表M决定，读者有兴趣可以帮忙验证一下这个文法是否LL(1)</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>非递归下降（<strong>无需掌握</strong>）<ul>\n<li>本质上还是递归下降，只是改写成Pushdown Automata所以相当于模拟一个栈</li>\n<li>如果栈顶是非终结符A：利用预测分析表,选择产生式A -&gt; a（也就是将栈顶的非终结符A替换成串a）</li>\n<li>如果栈顶是终结符a：将栈顶记号a和输入中的Token匹配并出栈</li>\n<li>初态：压入初始符号</li>\n<li>终态：输入读取完毕，栈空，此时接受</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"消除左递归、提左公因子\"><a href=\"#消除左递归、提左公因子\" class=\"headerlink\" title=\"消除左递归、提左公因子\"></a>消除左递归、提左公因子</h3><p>LL(1)文法的一些性质（可用于判定）：</p>\n<ul>\n<li>LL(1)文法是无二义的</li>\n<li>LL(1)文法是无左递归的</li>\n<li>LL(1)文法是无左公因子的</li>\n</ul>\n<p>左递归(left-recursive)文法:</p>\n<ul>\n<li>有非终结符A使得 $A \\Rightarrow^* A\\alpha$</li>\n<li>形如 $S\\rightarrow Sa$ 的称为直接&#x2F;立即左递归</li>\n<li>问题：这会导致递归下降分析进入无限循环<ul>\n<li>$S\\rightarrow Sa|b$ 分析 $baaaa$</li>\n<li>可能永远卡在”a”里而没机会考虑”b”: $ S \\Rightarrow Sa \\Rightarrow Saa \\Rightarrow Saaa \\Rightarrow Saaaa …$</li>\n</ul>\n</li>\n<li>解决办法：通过文法变换消除（详见龙书）<ul>\n<li>比如我们可以将这一文法：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A -&gt; A a | b (a,b不以A开头，a不为空)</span><br></pre></td></tr></table></figure>\n转为右递归：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A -&gt; b A&#x27;</span><br><span class=\"line\">A&#x27; -&gt; aA&#x27; | ε</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<p>左公因子的(left-factored)文法:</p>\n<ul>\n<li>$ P \\rightarrow \\alpha \\beta | \\alpha \\gamma$</li>\n<li>问题：同一非终结符的多个候选式存在共同前缀，可能导致回溯</li>\n<li>解决办法：限制文法 或 文法变换<ul>\n<li>例如我们可以提取左公因子来“推迟决定”，这样我们可以在读入更多token后进行决策：<br>把<br>$$ P \\rightarrow \\alpha \\beta | \\alpha \\gamma $$<br>变换为<br>$$ P \\rightarrow \\alpha Q $$<br>$$ Q \\rightarrow \\beta | \\gamma $$</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"错误恢复\"><a href=\"#错误恢复\" class=\"headerlink\" title=\"错误恢复\"></a>错误恢复</h3><p>错误：表M中对应格是空格，没有任何可取的产生式<br>我们不希望遇到错误直接全盘放弃，而是令Parser报错后，尽可能从错误中恢复并继续工作，这样可以一次性尽可能报出程序里全部错误。</p>\n<p>可以通过以下几种方式恢复：</p>\n<ul>\n<li>删除：例如，可以一直跳过token直到遇到当前非终结符对应Follow集中的token</li>\n<li>插入：例如，如果左右括号不匹配，我们可以插入一个假装有</li>\n<li>替换：例如，变量名错误可以替换为最相近的变量名</li>\n</ul>\n<h2 id=\"Part-5-语法分析-自底向上\"><a href=\"#Part-5-语法分析-自底向上\" class=\"headerlink\" title=\"Part 5: 语法分析 - 自底向上\"></a>Part 5: 语法分析 - 自底向上</h2><p>从串w归约为文法开始符号S的过程。规约时，一个与某产生式体<strong>相匹配的特定子串</strong>被替换为该产生式头部的<strong>非终结符号</strong>。</p>\n<p>问题：</p>\n<ul>\n<li>何时归约(归约哪些符号串)？</li>\n<li>归约到哪个非终结符号？</li>\n</ul>\n<p>回顾：LL(1)的优势劣势：</p>\n<ul>\n<li>+ 运行高效(线性时间)</li>\n<li>+ 递归实现符合文法结构、适合手动构造&amp;自动生成</li>\n<li>- 能分析的文法类型受限</li>\n</ul>\n<p>我们提出新文法：LR(k)</p>\n<ul>\n<li>表达力: Every LL(k) grammar is also LR(k)</li>\n<li>不要求无左公因式</li>\n<li>可以处理左递归文法</li>\n<li>被广泛采用(Yacc, Bison, …)</li>\n<li>“L”: left-to-right scanning 自左向右扫描</li>\n<li>“R”: right-most derivation in reverse 最右推导的逆</li>\n<li>“k”: 向前看的字符的个数(k省略时取1)</li>\n<li>子集（详见<a href=\"#grammars-set\">该图</a>）：LR(1), LALR(1), SLR, LR(0), …</li>\n</ul>\n<h3 id=\"移进-规约-Shift-Reduce\"><a href=\"#移进-规约-Shift-Reduce\" class=\"headerlink\" title=\"移进-规约 Shift-Reduce\"></a>移进-规约 Shift-Reduce</h3><p><strong>这是LR(k) Parsing 的一般模式。</strong></p>\n<p>核心思想：将字符串一分为二，</p>\n<ul>\n<li>右侧是未被parser检查过的</li>\n<li>左侧包含终结符与非终结符<br>我们接下来会使用”|”标记分割点。</li>\n</ul>\n<p>例如，考虑该文法： $ E \\rightarrow E+(E) | \\text{int} $</p>\n<ul>\n<li>显然并非LL(1)的：存在左递归</li>\n</ul>\n<p>我们考虑处理字符串”int+(int)+(int)”，则过程如下：<br><img src=\"/compiler-construction-principles/sr.png\" loading=\"lazy\"></p>\n<p>可见LR分析采用最右推导的<strong>逆过程</strong>：最左规约。因此LR分析的每一步都是最右句型。<br>一般实现方式：采用<strong>栈</strong>进行Shift-Reduce</p>\n<ul>\n<li>栈：包含左侧字符串</li>\n<li>输入流：包含剩余未处理的右侧字符串</li>\n<li>操作：<ul>\n<li>Shift: 从输入读入一个Terminal压入栈</li>\n<li>Reduce: 栈顶的几个元素满足某条产生式的<strong>RHS(Right hand side)</strong>, 则pop这些元素并压入产生式的<strong>LHS(Left hand side)</strong></li>\n<li>Error</li>\n<li>Accept: shift “$” 并且栈中只剩下文法的开始符号</li>\n</ul>\n</li>\n<li>需要解决的问题：<strong>何时shift? 何时reduce?</strong><ul>\n<li>表驱动的LR分析：类似LL文法的表，但行列意义不同，且这个表一般很大（详见后文）</li>\n</ul>\n</li>\n</ul>\n<p>几个文法的包含关系（仍然是详见<a href=\"#grammars-set\">该图</a>）:<br>$ LR(0) \\in SLR(1) \\in LALR(1) \\in LR(1) $</p>\n<h3 id=\"LR-0-Parsing\"><a href=\"#LR-0-Parsing\" class=\"headerlink\" title=\"LR(0) Parsing\"></a>LR(0) Parsing</h3><p>核心思想：因为需要凑出产生式RHS，维护栈顶内容对于所有产生式右侧的“进度”。<br>项(Item):&#x3D; 一个产生式加上在其中某处的一个点</p>\n<ul>\n<li>产生式 $A\\rightarrow XYZ$ 有4个Item: <ul>\n<li>$A\\rightarrow \\bullet XYZ $ </li>\n<li>$A\\rightarrow X\\bullet YZ $ </li>\n<li>$A\\rightarrow XY\\bullet Z $ </li>\n<li>$A\\rightarrow XYZ \\bullet $</li>\n</ul>\n</li>\n<li>$ A\\rightarrow \\alpha \\bullet \\beta$: 已扫描&#x2F;归约到了α，并期望在接下来的输入中经过扫描&#x2F;归约得到β，然后把αβ归约到A</li>\n<li>$ A\\rightarrow \\alpha \\beta \\bullet$: 已扫描&#x2F;归约得到了αβ，此时已经可以把αβ归约为A</li>\n<li><strong>Item类似有穷自动机的状态!</strong><ul>\n<li>一个项读入一个符号后可以转变为另一个项：例如$A\\rightarrow \\bullet XYZ $ 读入X就可以转为 $A\\rightarrow X\\bullet YZ $</li>\n<li>显然项的数量是有限的。</li>\n<li>这样的有穷自动机被称为<strong>LR(0)自动机</strong></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"LR-0-Parsing的NFA\"><a href=\"#LR-0-Parsing的NFA\" class=\"headerlink\" title=\"LR(0)Parsing的NFA\"></a>LR(0)Parsing的NFA</h4><blockquote>\n<p>⚠ NFA只能识别正则语言RE，然而RE&lt;LR(0). 所以这里的NFA只是用于辅助记录栈顶识别进度。</p>\n</blockquote>\n<p>新增开始符号S’，并加入产生式” S’-&gt;S$ “</p>\n<ul>\n<li>NFA起始状态：$S’\\rightarrow \\bullet S$ $ </li>\n<li>NFA终结状态：$S’\\rightarrow S\\bullet$ $ </li>\n<li>转移：<ul>\n<li>$A\\rightarrow \\bullet XY $ 读入X就可以转为 $A\\rightarrow X\\bullet Y $</li>\n<li>对于产生式 $ X\\rightarrow \\alpha Y \\beta $ 与 $Y\\rightarrow \\gamma$ 那么 $ X\\rightarrow \\alpha \\bullet Y \\beta $ 可以直接转换（ε-move）到 $ Y \\rightarrow \\bullet \\gamma$ （相当于递归下降法里进入下一层递归，从而分析当前产生式内部的非终结符）</li>\n</ul>\n</li>\n</ul>\n<p>我们更希望能转为DFA. 当然可以使用子集构造法转换，但事实上可以直接构造DFA.<br><img src=\"/compiler-construction-principles/lr-nfa2dfa.png\" loading=\"lazy\"></p>\n<h4 id=\"LR-0-Parsing的DFA与分析表\"><a href=\"#LR-0-Parsing的DFA与分析表\" class=\"headerlink\" title=\"LR(0)Parsing的DFA与分析表\"></a>LR(0)Parsing的DFA与分析表</h4><h5 id=\"DFA构造\"><a href=\"#DFA构造\" class=\"headerlink\" title=\"DFA构造\"></a>DFA构造</h5><p>项集闭包CLOSURE:&#x3D; a <strong>set</strong> of <strong>items</strong>, 记为I<br>任意符号记为X<br>对任意项集Closure(I)求法（其实就是ε-closure）：<br>Closure(I) &#x3D; </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repeat</span><br><span class=\"line\">  for any item A→ α•Xβ in I</span><br><span class=\"line\">    for any production X→ γ</span><br><span class=\"line\">      I ← I + &#123;X→ •γ&#125; </span><br><span class=\"line\">until I does not change. </span><br><span class=\"line\">return I</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>TL;DR: 如果”·”的右边是非终结符X，就把X为LHS的产生式对应的初始项加入。</p>\n</blockquote>\n<p>接下来的构造方式通过类比NFA-&gt;DFA的子集构造法是显然的：<br>GOTO(I,X):&#x3D; I是一个项集，X是一个文法符号，则GOTO(I,X)定义为I中所有形如 $A\\rightarrow \\bullet X \\beta$ 的项所对应的新项 $A\\rightarrow X \\bullet \\beta$ 构成的新集合生成的闭包（I是状态，X是转移，I里符合要求（也就是下一个符号是X）的产生式前移一位越过X加入转移到的新状态，不符合的被丢弃；当然考虑到ε-moves要再求一遍新状态的闭包）<br><img src=\"/compiler-construction-principles/lr-dfa.png\" loading=\"lazy\"><br><img src=\"/compiler-construction-principles/lr-dfa-eg.png\" loading=\"lazy\"></p>\n<h5 id=\"DFA到分析表\"><a href=\"#DFA到分析表\" class=\"headerlink\" title=\"DFA到分析表\"></a>DFA到分析表</h5><p>分析表T类似LL(1)中的表M，但是行列的含义与内容都发生了很大变化：</p>\n<ul>\n<li>Action表项：<ul>\n<li>每一行对应一个状态i</li>\n<li>每一列对应一个<strong>终结符t</strong></li>\n<li>表中的一格T[i,t]代表要做的操作action，有以下几种可能：<ul>\n<li>$s_n$ &#x3D; shift n :&#x3D; 从状态i经过<strong>终结符t</strong>转移到状态n<ul>\n<li>从输入流中取一个终结符t压入状态栈</li>\n<li>将n压入状态栈</li>\n</ul>\n</li>\n<li>$r_k$ &#x3D; reduce k :&#x3D; 确定使用第k个产生式进行规约（此时状态i没有出边）<ul>\n<li>弹出状态栈顶的几个状态（数量对应产生式#k的RHS长度）</li>\n<li>符号栈压入产生式#k的LHS，也即一个非终结符X</li>\n<li>查询Goto表（见下文）T[i,X]将对应的下一个状态压入状态栈</li>\n</ul>\n</li>\n<li>accept :&#x3D; 该状态包含 $S’\\rightarrow S \\bullet $ $, 接受字符串，运行完毕</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Goto表项：<ul>\n<li>每一行对应一个状态i</li>\n<li>每一列对应一个<strong>非终结符X</strong></li>\n<li>表中的一格T[i,X]表明经过<strong>非终结符X</strong>下一个状态是什么</li>\n<li>格中的$g_n$ &#x3D; goto n :&#x3D; 从状态i经过<strong>非终结符X</strong>转移到状态n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/compiler-construction-principles/dfa2table.png\" loading=\"lazy\"></p>\n<blockquote>\n<p>LR实际实现只有状态栈，符号信息可从相应状态中获取</p>\n</blockquote>\n<p>以下是一个例子：<br><img src=\"/compiler-construction-principles/lr0-stack-table.png\" loading=\"lazy\"></p>\n<p>如何理解”LR(0)”中的”0”: </p>\n<ul>\n<li>Item中没有Lookahead terminal等信息，不关心后面的token</li>\n<li>是否规约&#x2F;使用何产生式规约完全取决于栈顶状态</li>\n</ul>\n<p>局限性：由于只要有产生式能规约就立刻规约，很容易产生冲突（也就是表中一格有多个$s_n$,$r_n$，不知道应该直接规约还是需要接受更多符号来完成另一个产生式，这被称作<strong>shift-reduce conflict</strong>）<br>我们引入新的文法，放宽一些限制。</p>\n<h3 id=\"SLR-1-Parsing\"><a href=\"#SLR-1-Parsing\" class=\"headerlink\" title=\"SLR(1) Parsing\"></a>SLR(1) Parsing</h3><p>SLR(1) &#x3D; Simple LR(1)</p>\n<p>我们说过k省略时默认为1，所以称为SLR文法即可。其实就是LR(0)稍微改改。</p>\n<p>考虑每次规约，都会使用一个产生式 $E\\rightarrow \\alpha$<br>“LR分析是最右推导的逆过程”，因此每步归约都应该满足：<br>$$ t \\in \\text{Follow}(E) $$其中t指的是<strong>输入流中下一个token</strong>, E指的是用于<strong>此规约用到的产生式的左部(LHS)</strong>.<br>因此对于SLR文法来说，SLR的DFA和LR(0)一样；但LR(0)的分析表中有一些rn&#x2F;sn是非法的，需要删去。<br>在生成分析表的具体步骤上：</p>\n<ul>\n<li>LR(0)的某些状态包含可规约的Item，那么这个状态I在对应的Action表中T[I,_]这一行的每一个格子（无论终结符t是什么）无论如何都会有对应的$r_n$项</li>\n<li>SLR会关心后面的终结符是什么，因此如果t不在Follow集中，这不能是一个合法的规约，Action表对应的t列就不会有这个$r_n$</li>\n</ul>\n<p>例如，图中被划去的部分即为从LR(0)分析表到SLR分析表的变化：<br><img src=\"/compiler-construction-principles/slr-table.png\" alt=\"SLR分析表：删去了部分规约项\" loading=\"lazy\"></p>\n<p>规约的条件更严格，也就“自动”消除了一些冲突，也就允许了更多语言被纳入该文法，因此 $\\text{LR(0)} \\in \\text{SLR}$</p>\n<p>局限性：显然不能消除所有shift-reduce冲突。如果产生冲突对应的终结符t恰好在Follow集里，就无法消除。例如考虑如下文法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">S’ -&gt; S$</span><br><span class=\"line\">S -&gt; L=R | R</span><br><span class=\"line\">L -&gt; *R | id</span><br><span class=\"line\">R -&gt; L</span><br></pre></td></tr></table></figure>\n<p>由于<code>R-&gt;L</code>这一产生式，容易看出Follow(R)&#x3D;Follow(L)<br>然而’&#x3D;’在Follow(L)中，因此我们遇到’L&#x3D;…’时仍然不知道应该接受等于号进行shift(这样就可以进一步在<code>S-&gt;L=R</code>这个产生式中前进)，还是直接使用<code>R-&gt;L</code>进行reduce.<br><img src=\"/compiler-construction-principles/slr-conflict.png\" loading=\"lazy\"></p>\n<p>我们需要更多、更精确的限制才能进一步降低冲突的可能。</p>\n<h3 id=\"LR-1-Parsing\"><a href=\"#LR-1-Parsing\" class=\"headerlink\" title=\"LR(1) Parsing\"></a>LR(1) Parsing</h3><p>包含更多信息（后继token）来消除一些归约动作。<br>相当于“分裂”一些LR(0)状态，精确指明何时应该归约。</p>\n<p>LR(1)项(item)的形式：$ A \\rightarrow \\alpha \\bullet \\beta,\\ a$</p>\n<ul>\n<li>逗号后的a是**向前看符号(lookahead symbol)**即表明向前看一个终结符，可以是$</li>\n<li>和LR(0)对比，处理ε-move时记录合法的向前看符号w.</li>\n</ul>\n<h4 id=\"计算Closure\"><a href=\"#计算Closure\" class=\"headerlink\" title=\"计算Closure\"></a>计算Closure</h4><p>对于状态I中的一个item $$A\\rightarrow \\alpha X \\beta,\\ z$$ 以及一个产生式 $$X\\rightarrow \\gamma$$<br>我们寻找所有 $w\\in \\text{First}(\\beta z)$ 然后加入I：$I\\leftarrow I \\cup {(X\\rightarrow \\bullet \\gamma,\\ w)}$<br>起始状态 $S’\\rightarrow \\bullet S $,\\ ?$ 的闭包里不关心”?”处是什么，因为我们不会移进$<br>（所以一种可行的表示是把$都移到产生式外部，而非真的要产生一个”$“符号： $S’\\rightarrow \\bullet S,\\ $$）</p>\n<h4 id=\"计算Goto表\"><a href=\"#计算Goto表\" class=\"headerlink\" title=\"计算Goto表\"></a>计算Goto表</h4><p>基本和LR(0)算法保持相同，移入动作不考虑向前看符号z<br>也就是对于转移X，转移前后项的变换是：<br>$$A \\rightarrow \\alpha \\bullet X \\beta,\\ z \\ \\ \\Rightarrow\\ \\ A \\rightarrow \\alpha X \\bullet \\beta,\\ z$$</p>\n<h4 id=\"计算Action表：Reduce操作\"><a href=\"#计算Action表：Reduce操作\" class=\"headerlink\" title=\"计算Action表：Reduce操作\"></a>计算Action表：Reduce操作</h4><p>规约操作是变换较大的部分。<br>在LR(1)中，Action表项中Reduce操作形如$(I, z, A\\rightarrow \\alpha)$</p>\n<ul>\n<li>I: 代表状态I对应的行</li>\n<li>z: 代表向前看符号</li>\n<li>$ A\\rightarrow \\alpha $ 为规约所采用的产生式<br>这就限制了从某个可规约项规约时，必须向前看一个符号以确保它是lookahead symbol.</li>\n</ul>\n<p><img src=\"/compiler-construction-principles/lr1-items.png\" loading=\"lazy\"></p>\n<hr>\n<p>局限性：这样的文法限制过少，过于灵活，导致状态数量过多，状态表过于庞大。<br><img src=\"/compiler-construction-principles/lr1-con.png\" loading=\"lazy\"></p>\n<p>因此我们在SLR(1)&#x3D;Simple LR(1)与LR(1)之间折中，可以得到一个新文法LALR(1).</p>\n<h3 id=\"LALR-1-Parsing\"><a href=\"#LALR-1-Parsing\" class=\"headerlink\" title=\"LALR(1) Parsing\"></a>LALR(1) Parsing</h3><p>动机：发现很多LR(1)中的状态都只有lookahead symbol的区别。能否合并？</p>\n<p><strong>LALR(1): 把LR(1)中只有lookahead symbol不同的item合并。</strong></p>\n<p>定义：把LR(1)中item的集合里所有lookahead symbol去掉，剩下的称为<strong>核(core)</strong><br>把LR(1)中所有核相同的状态两两合并为一个状态。每次合并都删除两个旧状态，新增一个新状态，入边出边的连接方式是显然的，直接接在新状态上即可。<br>新状态的item是两个旧状态的item的并（其实就是把每个item的lookahead symbol合并一下）。</p>\n<p><img src=\"/compiler-construction-principles/lr1-lalr1.png\" loading=\"lazy\"></p>\n<p>这样得到的表将会小很多：与SLR的分析表<strong>一样大</strong>！通常状态数只有LR(1)的十分之一。付出的微小代价：规约-规约冲突(reduce-reduce conflict)<br>例如对于如下文法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">S -&gt; a E c</span><br><span class=\"line\">   | a F d</span><br><span class=\"line\">   | b F c</span><br><span class=\"line\">   | b E d</span><br><span class=\"line\">E -&gt; e</span><br><span class=\"line\">F -&gt; e</span><br></pre></td></tr></table></figure>\n<p>在LALR分析表中有两个状态会被合并成一个。而之后的下个字符将会出现歧义。这个冲突对应的状态：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">E -&gt; e, &#123;c,d&#125;</span><br><span class=\"line\">F -&gt; e, &#123;c,d&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>LR(1)分析器：将产生两个不同的状态(图中的状态#6与#9)，不会产生冲突：<img src=\"/compiler-construction-principles/lr1-eg.png\" loading=\"lazy\"></li>\n<li>LALR(1)分析器：只会产生一个状态，产生冲突<ul>\n<li>若下个输入字符为c或d，可以归约成E或F</li>\n</ul>\n</li>\n</ul>\n<p>因此，上述文法对于LALR(1)是二义的。<br>但这是可以接受的：LALR(1)足以处理绝大部分程序设计语言。</p>\n<h2 id=\"Part-6-语法分析杂项与小结\"><a href=\"#Part-6-语法分析杂项与小结\" class=\"headerlink\" title=\"Part 6: 语法分析杂项与小结\"></a>Part 6: 语法分析杂项与小结</h2><p><em>&gt;&gt;&gt; To be continued…</em></p>\n<h3 id=\"语法分析器的生成器：YACC\"><a href=\"#语法分析器的生成器：YACC\" class=\"headerlink\" title=\"语法分析器的生成器：YACC\"></a>语法分析器的生成器：YACC</h3><h3 id=\"错误恢复-1\"><a href=\"#错误恢复-1\" class=\"headerlink\" title=\"错误恢复\"></a>错误恢复</h3><h4 id=\"局部错误恢复\"><a href=\"#局部错误恢复\" class=\"headerlink\" title=\"局部错误恢复\"></a>局部错误恢复</h4><h4 id=\"全局错误恢复\"><a href=\"#全局错误恢复\" class=\"headerlink\" title=\"全局错误恢复\"></a>全局错误恢复</h4><h4 id=\"语法分析小结\"><a href=\"#语法分析小结\" class=\"headerlink\" title=\"语法分析小结\"></a>语法分析小结</h4><h2 id=\"Part-7-抽象语法\"><a href=\"#Part-7-抽象语法\" class=\"headerlink\" title=\"Part 7: 抽象语法\"></a>Part 7: 抽象语法</h2><h2 id=\"Part-8-语义分析\"><a href=\"#Part-8-语义分析\" class=\"headerlink\" title=\"Part 8: 语义分析\"></a>Part 8: 语义分析</h2><h2 id=\"Part-9-活动记录Activation-Record\"><a href=\"#Part-9-活动记录Activation-Record\" class=\"headerlink\" title=\"Part 9: 活动记录Activation Record\"></a>Part 9: 活动记录Activation Record</h2>",
            "tags": [
                "Compiler",
                "Computer Science",
                "On Going"
            ]
        }
    ]
}