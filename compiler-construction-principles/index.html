<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="编译原理Part 0: 课程信息使用教材：Modern Compiler Implementation in C, Andrew W. Appel （A.K.A 虎书） 相关课程：  Stanford课程主页 MIT课程主页 UCBerkeley课程主页  分数构成：  课程作业(课后小型练习题) &#x3D; 10% 随堂测验&#x3D; 10% 期中考试&#x3D; 15% 综合性课程设计&amp;#">
<meta property="og:type" content="article">
<meta property="og:title" content="编译原理课程笔记">
<meta property="og:url" content="http://cubicy.icu/compiler-construction-principles/index.html">
<meta property="og:site_name" content="Cubic Y³">
<meta property="og:description" content="编译原理Part 0: 课程信息使用教材：Modern Compiler Implementation in C, Andrew W. Appel （A.K.A 虎书） 相关课程：  Stanford课程主页 MIT课程主页 UCBerkeley课程主页  分数构成：  课程作业(课后小型练习题) &#x3D; 10% 随堂测验&#x3D; 10% 期中考试&#x3D; 15% 综合性课程设计&amp;#">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://cubicy.icu/compiler-construction-principles/nfa2dfa.png">
<meta property="og:image" content="http://cubicy.icu/compiler-construction-principles/DFA-simplify-diverge.png">
<meta property="og:image" content="http://cubicy.icu/compiler-construction-principles/DFA-simplify.png">
<meta property="og:image" content="http://cubicy.icu/compiler-construction-principles/lmrm.png">
<meta property="og:image" content="http://cubicy.icu/compiler-construction-principles/priority.png">
<meta property="og:image" content="http://cubicy.icu/compiler-construction-principles/grammars.png">
<meta property="og:image" content="http://cubicy.icu/compiler-construction-principles/tableM.png">
<meta property="article:published_time" content="2024-04-13T17:10:20.000Z">
<meta property="article:modified_time" content="2024-04-15T01:14:16.558Z">
<meta property="article:author" content="Cubic Y^3">
<meta property="article:tag" content="Compiler">
<meta property="article:tag" content="Computer Science">
<meta property="article:tag" content="On Going">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://cubicy.icu/compiler-construction-principles/nfa2dfa.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon.ico" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
        
      
    
    <!-- title -->
    <title>编译原理课程笔记</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/cubicYYY/">GitHub</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2024/04/12/%E8%B5%9B%E5%8D%9A%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%E8%8D%AF%E6%96%B9/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://cubicy.icu/compiler-construction-principles/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://cubicy.icu/compiler-construction-principles/&text=编译原理课程笔记"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://cubicy.icu/compiler-construction-principles/&title=编译原理课程笔记"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://cubicy.icu/compiler-construction-principles/&is_video=false&description=编译原理课程笔记"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=编译原理课程笔记&body=Check out this article: http://cubicy.icu/compiler-construction-principles/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://cubicy.icu/compiler-construction-principles/&title=编译原理课程笔记"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://cubicy.icu/compiler-construction-principles/&title=编译原理课程笔记"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://cubicy.icu/compiler-construction-principles/&title=编译原理课程笔记"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://cubicy.icu/compiler-construction-principles/&title=编译原理课程笔记"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://cubicy.icu/compiler-construction-principles/&name=编译原理课程笔记&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://cubicy.icu/compiler-construction-principles/&t=编译原理课程笔记"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">编译原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-0-%E8%AF%BE%E7%A8%8B%E4%BF%A1%E6%81%AF"><span class="toc-number">1.1.</span> <span class="toc-text">Part 0: 课程信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-1-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.2.</span> <span class="toc-text">Part 1: 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-2-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.3.</span> <span class="toc-text">Part 2: 词法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E6%A6%82%E8%BF%B0"><span class="toc-number">1.3.1.</span> <span class="toc-text">词法分析概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.3.2.</span> <span class="toc-text">正则表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-number">1.3.3.</span> <span class="toc-text">有穷自动机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90"><span class="toc-number">1.3.4.</span> <span class="toc-text">词法分析器自动生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lex%E5%B7%A5%E5%85%B7"><span class="toc-number">1.3.5.</span> <span class="toc-text">Lex工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-3-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-CFG-amp-Parsing"><span class="toc-number">1.4.</span> <span class="toc-text">Part 3: 语法分析 - CFG &amp; Parsing</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">1.4.1.</span> <span class="toc-text">语法分析器概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95CFG-x3D-Context-Free-Language"><span class="toc-number">1.4.2.</span> <span class="toc-text">上下文无关文法CFG&#x3D;Context Free Language</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E5%AF%BCDerivation%E5%92%8C%E8%A7%84%E7%BA%A6Reduction"><span class="toc-number">1.4.3.</span> <span class="toc-text">推导Derivation和规约Reduction</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B7%A6%E6%8E%A8%E5%AF%BCLeft-most-Derivation"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">最左推导Left-most Derivation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%A5%E5%9E%8B-Sentential-form-%E5%8F%A5%E5%AD%90-Sentence-%E8%AF%AD%E8%A8%80-Language"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">句型(Sentential form) 句子(Sentence) 语言(Language)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E6%96%87%E6%B3%95-RE-%E4%B8%8E-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95-CFG"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">正则文法(RE) 与 上下文无关文法(CFG)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CFG%E7%9A%84%E5%88%86%E6%9E%90%E6%A0%91Parse-Tree"><span class="toc-number">1.4.4.</span> <span class="toc-text">CFG的分析树Parse Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-Parsing-%E4%B8%AD%E7%9A%84%E6%8C%91%E6%88%98"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">语法分析(Parsing)中的挑战</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E6%96%87%E6%B3%95%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">编程语言的文法设计</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-4-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B"><span class="toc-number">1.5.</span> <span class="toc-text">Part 4: 语法分析 - 自顶向下</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LL-1-%E5%92%8C%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E6%B3%95-Predictive-parsing"><span class="toc-number">1.5.1.</span> <span class="toc-text">LL(1)和预测分析法(Predictive parsing)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#First%E9%9B%86%E5%92%8CFollow%E9%9B%86"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">First集和Follow集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E8%AE%A1%E7%AE%97First-Follow"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">第一步：计算First, Follow</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Nullable%E9%9B%86"><span class="toc-number">1.5.1.2.1.</span> <span class="toc-text">Nullable集</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E6%9E%84%E9%80%A0%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E8%A1%A8"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">第二步：构造预测分析表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90"><span class="toc-number">1.5.1.4.</span> <span class="toc-text">第三步：预测分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E9%99%A4%E5%B7%A6%E9%80%92%E5%BD%92%E3%80%81%E6%8F%90%E5%B7%A6%E5%85%AC%E5%9B%A0%E5%AD%90"><span class="toc-number">1.5.2.</span> <span class="toc-text">消除左递归、提左公因子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E6%81%A2%E5%A4%8D"><span class="toc-number">1.5.3.</span> <span class="toc-text">错误恢复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-5-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A"><span class="toc-number">1.6.</span> <span class="toc-text">Part 5: 语法分析 - 自底向上</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-6-%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95"><span class="toc-number">1.7.</span> <span class="toc-text">Part 6: 抽象语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-7-%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90"><span class="toc-number">1.8.</span> <span class="toc-text">Part 7: 语义分析</span></a></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        编译原理课程笔记
    </h1>



      <div class="meta">
        <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <span class="p-name" itemprop="name">
            Cubic Y^3
                    
          </span>
        </span>
        
    <div class="postdate">
      
        <time datetime="2024-04-13T17:10:20.000Z" class="dt-published" itemprop="datePublished">2024-04-14</time>
        
        (Updated: <time datetime="2024-04-15T01:14:16.558Z" class="dt-updated" itemprop="dateModified">2024-04-15</time>)
        
      
    </div>


          
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/Course-Notes/">Course Notes</a> › <a class="category-link" href="/categories/Course-Notes/Compiler-Construction-Principles/">Compiler Construction Principles</a>
    </div>


            
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/Compiler/" rel="tag">Compiler</a>, <a class="p-category" href="/tags/Computer-Science/" rel="tag">Computer Science</a>, <a class="p-category" href="/tags/On-Going/" rel="tag">On Going</a>
    </div>


      </div>
  </header>
  

    <div class="content e-content" itemprop="articleBody">
      <script async src="https://npm.elemecdn.com/penndu@1.0.0/bsz.js"></script>
      <div class="views" style="display: flex; text-align:center; gap: 8px;">
        <i class="fa-solid fa-eye" style="align-content: center; margin-right: 12px;"></i>
        <span id="busuanzi_value_page_pv"></span>views
      </div>
      <span class="post-count">
        Word count: 4.2k
          (~16 mins to read)
      </span>
      <h1 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h1><h2 id="Part-0-课程信息"><a href="#Part-0-课程信息" class="headerlink" title="Part 0: 课程信息"></a>Part 0: 课程信息</h2><p>使用教材：<em>Modern Compiler Implementation in C</em>, Andrew W. Appel （A.K.A 虎书）</p>
<p>相关课程：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://web.stanford.edu/class/cs143/">Stanford课程主页</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/6035/sp21">MIT课程主页</a></li>
<li><a target="_blank" rel="noopener" href="https://inst.eecs.berkeley.edu/~cs164/fa21/">UCBerkeley课程主页</a></li>
</ul>
<p>分数构成：</p>
<ul>
<li>课程作业(课后小型练习题) &#x3D; 10%</li>
<li>随堂测验&#x3D; 10%</li>
<li>期中考试&#x3D; 15%</li>
<li>综合性课程设计&#x3D; 25%</li>
<li>期末考试&#x3D; 40% （斩杀线40&#x2F;100）</li>
</ul>
<p>前置知识：计算理论（笔记参考<a target="_blank" rel="noopener" href="https://note.tonycrane.cc/cs/tcs/toc/">https://note.tonycrane.cc/cs/tcs/toc/</a>）</p>
<h2 id="Part-1-简介"><a href="#Part-1-简介" class="headerlink" title="Part 1: 简介"></a>Part 1: 简介</h2><p>基本概念：</p>
<ul>
<li>中间代码&#x3D;Intermediate Code</li>
<li>词法分析&#x3D;Lexing&#x2F;Scanning&#x2F;LexicalAnalysis</li>
<li>语法分析&#x3D;Parsing&#x2F;SyntaxAnalysis</li>
<li>中间表示&#x3D;IR&#x3D;Intermediate Representation</li>
<li>树型中间表示&#x3D;IR Tree</li>
<li>前端&#x3D;，后端&#x3D;<br>略。</li>
</ul>
<h2 id="Part-2-词法分析"><a href="#Part-2-词法分析" class="headerlink" title="Part 2: 词法分析"></a>Part 2: 词法分析</h2><h3 id="词法分析概述"><a href="#词法分析概述" class="headerlink" title="词法分析概述"></a>词法分析概述</h3><p>将输入字符串识别为有意义的子串。（把基本单元划分好）<br>(Token单词, Lexeme词素(可选)) e.g. (IF, ) (ELSE, ) (BINARY_OP, &gt;&#x3D;) (UNARY_OP, &amp;)</p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>Regex Expression &#x3D; RE<br>运算：连接concatenation + 幂Power<br>e.g.: $ ab(a|b)^3c^* $<br>下略。</p>
<h3 id="有穷自动机"><a href="#有穷自动机" class="headerlink" title="有穷自动机"></a>有穷自动机</h3><p>相关概念：</p>
<ul>
<li><p>NFA&#x2F;DFA：略</p>
</li>
<li><p>子集构造法subsetconstruction(NFA-&gt;DFA)</p>
<ul>
<li>DFA的每个状态是NFA的状态集合的一个子集</li>
<li>读了输入ai后NFA能到达的所有状态：s1,s2,…,sk，则DFA到达一个状态，对应于NFA的{s1,s2,…,sk}</li>
<li>NFA状态(集)上的一些操作定义<ul>
<li>ε-closure(s):&#x3D; NFA状态s的ε-闭包&#x3D;s经ε转换所能到达的状态集合</li>
<li>ε-closure(T):&#x3D; T中所有状态的ε-闭包的并集,即 $ \cup_{s\in T}{\epsilon-closure(s)} $</li>
</ul>
</li>
<li>过程<ol>
<li>NFA的初始状态S的ε-闭包对应于DFA的初始状态</li>
<li>针对每个DFA状态(对应NFA状态子集A)，求输入每个可能输入ai后能到达的NFA状态的ε-闭包并集（NFA从状态集A出发，读入ai后能到达的状态集合） $$ S&#x3D;\epsilon-closure(move(A,a_i)) $$</li>
<li>该集合S要么对应于DFA中的一个已有状态，要么令其成为一个新加的DFA状态</li>
<li>重复上述两步，逐步构造DFA的状态转换表（每个状态集合S与每个输入ai），直到不动点（不再新增状态，且状态转移表完全求出，即对任一状态集合S已知分别接受所有输入ai将分别转移到何状态）</li>
<li>在DFA中，只要状态集合S包含至少一个原来NFA中的终止状态，就把S标记为终止状态</li>
</ol>
</li>
<li>示例（TODO）<ul>
<li><img src="/compiler-construction-principles/nfa2dfa.png" loading="lazy"></li>
</ul>
</li>
</ul>
</li>
<li><p>Thumpson构造法(RE-&gt;NFA)：略</p>
</li>
</ul>
<h3 id="词法分析器自动生成"><a href="#词法分析器自动生成" class="headerlink" title="词法分析器自动生成"></a>词法分析器自动生成</h3><ul>
<li>DFA最小化（-&gt;状态最小的DFA，在同构意义下唯一）</li>
<li>可区分状态：存在串s使其分别从状态s、t出发，一个接受串s，一个拒绝串s，则s与t可区分</li>
<li>步骤：<ol>
<li>初始等价类，仅由接受状态集合和非接受状态两个集合构成</li>
<li>用所有可能的输入ai应用于各个集合（走一步）<ul>
<li>只有集合G的每个状态读入同一字符后，都落入（包含在）相同的某个集合，该集合G在这一步才不用细分</li>
<li>否则集合G要被细分：落入不同集合的对应状态需要被分割进不同集合</li>
</ul>
</li>
<li>不断重复2直到不动点（任一集合分别对所有输入ai都不可细分）</li>
<li>此时等价类中的每个集合即对应最小DFA的一个状态。在其上可以轻松构建min-DFA，该过程是trivial的（可以每个组中选择一个状态作代表）。</li>
</ol>
</li>
<li>示例（TODO）<ul>
<li><img src="/compiler-construction-principles/DFA-simplify-diverge.png" loading="lazy"></li>
<li><img src="/compiler-construction-principles/DFA-simplify.png" loading="lazy"></li>
</ul>
</li>
</ul>
<h3 id="Lex工具"><a href="#Lex工具" class="headerlink" title="Lex工具"></a>Lex工具</h3><p>通常和Yacc一起使用，生成编译器的前端。</p>
<ul>
<li>声明部分<ul>
<li>常量：常数标识符</li>
<li>正则规则定义</li>
</ul>
</li>
<li>转换规则模式{动作}<ul>
<li>模式&#x3D;正则表达式</li>
<li>动作&#x3D;识别到相应模式时应调用的处理函数（一般以C语言代码表示）</li>
</ul>
</li>
<li>辅助函数：动作中使用的函数</li>
</ul>
<p>解决冲突：最长匹配，较前规则优先</p>
<h2 id="Part-3-语法分析-CFG-amp-Parsing"><a href="#Part-3-语法分析-CFG-amp-Parsing" class="headerlink" title="Part 3: 语法分析 - CFG &amp; Parsing"></a>Part 3: 语法分析 - CFG &amp; Parsing</h2><h3 id="语法分析器概述"><a href="#语法分析器概述" class="headerlink" title="语法分析器概述"></a>语法分析器概述</h3><p>从词法分析器获得Token序列，确认该序列是否可以由语言的文法生成</p>
<ul>
<li>对于语法错误的程序，报告错误信息</li>
<li>对于语法正确的程序，生成语法分析树(简称语法树) e.g. 抽象语法树AST</li>
</ul>
<p>实现：手动 or 自动(使用Parse generator&#x3D;{Yacc, Bison, ANTLR, mehir…})</p>
<h3 id="上下文无关文法CFG-x3D-Context-Free-Language"><a href="#上下文无关文法CFG-x3D-Context-Free-Language" class="headerlink" title="上下文无关文法CFG&#x3D;Context Free Language"></a>上下文无关文法CFG&#x3D;Context Free Language</h3><p>$$ G&#x3D;(T,N,P,S) $$<br>T：终结符集合(Terminals)<br>N：非终结符集合(Non-terminals)<br>P：产生式集合(Productions) $ A\rightarrow a, A \in N, a \in (T \cup N)^*$<br>S：开始符号(Startsymbol): $ S \in N $</p>
<blockquote>
<p>📕“上下文无关”体现在：产生式左侧只有一个非终结符，因此类似 $xAy\rightarrow xay$这样，需要关心符号前后别的符号是什么才能应用的产生式是不能在CFG里的。</p>
</blockquote>
<ul>
<li>特殊符号：$ &#x3D;end of file(EOF)<br>添加一个新符号S’与一条新规则以表明必须在尾部：<ul>
<li>$ S’ \rightarrow S$ $</li>
</ul>
</li>
<li>产生式缩写：左侧一样的产生式可以把右侧使用”|”合并。例如 $E\rightarrow E+E|(E)|id$</li>
</ul>
<h3 id="推导Derivation和规约Reduction"><a href="#推导Derivation和规约Reduction" class="headerlink" title="推导Derivation和规约Reduction"></a>推导Derivation和规约Reduction</h3><p>例如有产生式 $A\rightarrow \gamma$，我们可以有 $\alpha A \beta \Rightarrow \alpha \gamma \beta$<br>那么我们说：</p>
<ul>
<li>$\alpha A \beta $ <strong>直接推导</strong>到 $ \alpha \gamma \beta$</li>
<li>$\alpha \gamma \beta $ <strong>直接规约</strong>到 $  \alpha A \beta$<br>不言而喻的<strong>多步推导记号</strong>：$\Rightarrow^5$ $\Rightarrow^+$ $\Rightarrow^*$<br>分别代表五步推导，至少一步推导，0次或更多次推导</li>
<li>推导&#x3D;从文法生成语言里的句子，规约&#x3D;识别句子成分并逐渐规约到开始符号</li>
</ul>
<h4 id="最左推导Left-most-Derivation"><a href="#最左推导Left-most-Derivation" class="headerlink" title="最左推导Left-most Derivation"></a>最左推导Left-most Derivation</h4><ul>
<li>最左推导&#x3D;每步代换最左边的非终结符。逆过程为最右规约</li>
<li>类比可得出最右推导、最左规约的定义</li>
<li>在自顶向下的分析中，总是采用<strong>最左推导</strong>；在自底向上的分析中，总是采用<strong>最左归约</strong></li>
</ul>
<p><img src="/compiler-construction-principles/lmrm.png" loading="lazy"></p>
<h4 id="句型-Sentential-form-句子-Sentence-语言-Language"><a href="#句型-Sentential-form-句子-Sentence-语言-Language" class="headerlink" title="句型(Sentential form) 句子(Sentence) 语言(Language)"></a>句型(Sentential form) 句子(Sentence) 语言(Language)</h4><ul>
<li>句型 &#x3D; 文法G下可能推导出的一个符号序列：可能包含终结符&#x2F;非终结符，可为空</li>
<li>句子 &#x3D; 不含非终结符的句型（仅含终结符）</li>
<li>语言 &#x3D; 文法G可产生的所有句子的集合</li>
</ul>
<h4 id="正则文法-RE-与-上下文无关文法-CFG"><a href="#正则文法-RE-与-上下文无关文法-CFG" class="headerlink" title="正则文法(RE) 与 上下文无关文法(CFG)"></a>正则文法(RE) 与 上下文无关文法(CFG)</h4><ul>
<li>上下文无关语言L(G) :&#x3D; CFG产生的所有句子的集合</li>
<li>正则语言L(r) :&#x3D; RE产生的所有句子的集合<ul>
<li>RE &#x3D; Regex Expression &#x3D; 正则表达式</li>
<li>正则表达式r定义正则语言L(r)</li>
<li>$ L(r) \in L(G) $：因为正则对产生式限制更大，必须为( $A,B \in N, a \in T\cup {\epsilon} $ )：<ul>
<li>左线性文法：形如 $A\rightarrow aB$ 或 $A\rightarrow a$</li>
<li>右线性文法：形如 $A\rightarrow Ba$ 或 $A\rightarrow a$</li>
</ul>
</li>
<li>正则语言可用于词法分析，上下文无关语言可用于语法分析（语言描述能力、复杂性决定的）</li>
<li>Chomsky（计算理论课程内容）: <ul>
<li>0型文法&#x3D;短语结构文法 递归可枚举</li>
<li>1型文法&#x3D;上下文有关文法</li>
<li>2型文法&#x3D;CFG</li>
<li>3型文法&#x3D;RE</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="CFG的分析树Parse-Tree"><a href="#CFG的分析树Parse-Tree" class="headerlink" title="CFG的分析树Parse Tree"></a>CFG的分析树Parse Tree</h3><p>分析树性质</p>
<ul>
<li>根节点&#x3D;文法初始符号</li>
<li>叶节点&#x3D;终结符</li>
<li>内部节点&#x3D;非终结符</li>
<li>父节点→{叶节点}&#x3D;产生式</li>
</ul>
<h4 id="语法分析-Parsing-中的挑战"><a href="#语法分析-Parsing-中的挑战" class="headerlink" title="语法分析(Parsing)中的挑战"></a>语法分析(Parsing)中的挑战</h4><p><strong>核心目标：对于终结符号串x，要么从S推导出x，要么设法将x规约到S</strong></p>
<ul>
<li>自顶向下(Top-down) S-&gt;x, 从<strong>根节点</strong>开始构造Parse Tree</li>
<li>自底向上(Bottom-up) x-&gt;S, 从<strong>叶节点</strong>开始构造Parse Tree</li>
</ul>
<p>作为搜索问题：搜索空间大-&gt;空间大小受文法产生式限制</p>
<ul>
<li>无限制：时间复杂度 $O(n^3)$</li>
<li>上下文无关语言CFL 的子集需要的典型时间为 $O(n)$，例如<ul>
<li>Predictive parsing using LL(1) grammars</li>
<li>Shift-Reduce parsing using LR(1) grammars</li>
<li>…</li>
</ul>
</li>
</ul>
<h4 id="编程语言的文法设计"><a href="#编程语言的文法设计" class="headerlink" title="编程语言的文法设计"></a>编程语言的文法设计</h4><p><strong>核心：无二义性</strong><br>二义性来源：某些句子存在不止一棵分析树&#x3D;有两个不同的最左推导&#x3D;<strong>多种可选推导处于文法同一层</strong><br>例如：$$E \Rightarrow E<em>E \Rightarrow id</em>E \Rightarrow id<em>E+E$$ 与 $$E \Rightarrow E+E \Rightarrow E</em>E+E \Rightarrow id<em>E+E $$<br>对于”3*4+5”，前者给出3*(4+5)&#x3D;27（错误），后者给出3</em>4+5&#x3D;17（正确）。</p>
<p>解决办法：确保只有一种最左推导&#x3D;将同一层文法分层</p>
<ul>
<li>规定符号优先级（”*“” &gt; “+”,”-“）<ul>
<li>越接近开始符号S的文法符号优先级越低</li>
</ul>
</li>
<li>规定符号结合性（左结合&#x2F;右结合）<ul>
<li>递归非终结符在终结符左边，运算就左结合</li>
<li><img src="/compiler-construction-principles/priority.png" loading="lazy"></li>
</ul>
</li>
</ul>
<p>判定CFG二义性：不可判定问题</p>
<ul>
<li>但可以通过给定充分条件（无二义文法）确保无二义性<ul>
<li>自顶向下：LL(1)</li>
<li>自底向上：LR(1), LALR(1)<br><img src="/compiler-construction-principles/grammars.png" loading="lazy"></li>
</ul>
</li>
</ul>
<h2 id="Part-4-语法分析-自顶向下"><a href="#Part-4-语法分析-自顶向下" class="headerlink" title="Part 4: 语法分析 - 自顶向下"></a>Part 4: 语法分析 - 自顶向下</h2><p>自顶向下每一步的推导都需要做出<strong>两个选择</strong>：</p>
<ul>
<li>替换哪个非终结符？</li>
<li>应用哪个（左侧为该终结符的）产生式替换？</li>
</ul>
<p>通用形式：<strong>递归下降分析(Recursive-Descent Parsing)</strong></p>
<ul>
<li>发生错误（没有产生式可以产生合法的子节点）就回溯</li>
<li>问题：太慢！</li>
<li>该过程类似NFA，能否构造类似DFA的分析方法？</li>
</ul>
<h3 id="LL-1-和预测分析法-Predictive-parsing"><a href="#LL-1-和预测分析法-Predictive-parsing" class="headerlink" title="LL(1)和预测分析法(Predictive parsing)"></a>LL(1)和预测分析法(Predictive parsing)</h3><p>预测分析法：接受LL(k)文法</p>
<ul>
<li>第一个L: “left to right” 从左到右扫描</li>
<li>第二个L: “left-most derivation” 最左推导</li>
<li>k: 向前看k个token确定推导选用的产生式（一般k&#x3D;1）</li>
</ul>
<p>接下来需要添加约束使其无需回溯。我们先引入几个概念：</p>
<h4 id="First集和Follow集"><a href="#First集和Follow集" class="headerlink" title="First集和Follow集"></a>First集和Follow集</h4><p>给定 $ G&#x3D;(T,N,P,S),\alpha \in (T\cup N)^* $<br><strong>记空串为$\epsilon$</strong></p>
<ul>
<li><p>First集：可从$\alpha$推导得到的串的首个终结符的集合（也就是说，$\alpha$自己推导出的第一个终结符可能是什么）<br>$$ \text{First}(\alpha)&#x3D;{a| \alpha \Rightarrow^*a…\ ,a\in T} $$</p>
</li>
<li><p>Follow集：从S出发，可能在推导过程中跟在A右边的终结符号集<br>$$ \text{Follow}(A)&#x3D;{a|S\Rightarrow^*…Aa…\ ,a\in T} $$</p>
<ul>
<li>例如:S→αAaβ，终结符号 $ a\in \text{Follow}(A) $</li>
</ul>
</li>
</ul>
<p>我们至此可以使用两个条件保证产生式的选择是唯一的：</p>
<ol>
<li>$ \text{First}(\alpha)\cap \text{First}(\beta)&#x3D; \emptyset $ （α和β推导不出以同一个单词为首的串）<ul>
<li>意义：显然的。这样看终结符是哪个就知道应该用哪个产生式。</li>
</ul>
</li>
<li>若$\beta \Rightarrow^* \epsilon$，那么$\alpha \nRightarrow^* \epsilon$，且 $ \text{First}(\alpha) \cap Follow(A) &#x3D; \emptyset $ （α和β不能同时推出$\epsilon$;First(α)不应在Follow(A) 中）<ul>
<li>意义：其实就是考虑如果有空串时，最后终结符因为空串没了则转而考虑Follow集以实现再向后看一个的效果。假设下一个输入是b,且$\beta \Rightarrow^* \epsilon$<ul>
<li>如果b∈First(α)，则选择A → α(属于上面1的情况)</li>
<li>如果b∈Follow(A)，则选择A → β ,因为A最终到达了$\epsilon$，而后面紧跟着b</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>接下来我们会看到具体的实现方式以实现LL(1)预测分析。三步走：计算First,Follow-&gt;构造预测分析表-&gt;预测分析</p>
<h4 id="第一步：计算First-Follow"><a href="#第一步：计算First-Follow" class="headerlink" title="第一步：计算First, Follow"></a>第一步：计算First, Follow</h4><h5 id="Nullable集"><a href="#Nullable集" class="headerlink" title="Nullable集"></a>Nullable集</h5><p>由于刚刚提到了空串，我们需要引入一个简单的新定义：Nullable集&#x3D;{可推导出空串的符号}。<br>定义是递归的：</p>
<ul>
<li>Base Case: 如果有产生式 $ X\rightarrow \epsilon$, 那么X当然是Nullable的</li>
<li>Inductive Case: 如果有产生式 $ X\rightarrow Y_1 Y_2 Y_3 … Y_n$, 且 $Y_1,Y_2,Y_3,…,Y_n$<strong>每个都能</strong>推导出空串，则X是Nullable的</li>
</ul>
<p>对于每个产生式，我们可以循环用它们不断更新Nullable集直到不动点。这同样适用于First集与Follow集。</p>
<p>First集：</p>
<ul>
<li>Base Case: 如果X是终结符terminal: First(X)&#x3D;{X}</li>
<li>Inductive Case: 如果有产生式 $ X\rightarrow Y_1 Y_2 Y_3 … Y_n$<ul>
<li>$\text{First}(X) \cup &#x3D; \text{First}(Y_1)$ ($ a\cup &#x3D; b$意为$ a \leftarrow a\cup b$)</li>
<li>如果$Y_1 \in \text{Nullable}: $$\text{First}(X) \cup &#x3D; \text{First}(Y_1)$</li>
<li>如果$Y_1,Y_2 \in \text{Nullable}: $$\text{First}(X) \cup &#x3D; \text{First}(Y_2)$</li>
<li>…</li>
<li>直到某个$Y_i \notin \text{Nullable}$则停止</li>
</ul>
</li>
</ul>
<p>对于每个产生式，我们可以循环用它们不断更新First集直到不动点。</p>
<p>Follow集：</p>
<ul>
<li>Base Case: $ \text{Follow}(A)&#x3D;\emptyset $</li>
<li>Inductive Case: 如果有产生式 $ B\rightarrow s_1 A\ s_2 $<ul>
<li>$\text{Follow}(A) \cup &#x3D; \text{First}(s_2)$</li>
<li>如果$s_2 \in \text{Nullable}$, $\text{Follow}(A) \cup &#x3D; \text{Follow}(B)$</li>
</ul>
</li>
</ul>
<p>对于每个产生式，我们可以循环用它们不断更新Follow集直到不动点。</p>
<p>Tips(不要求掌握):Tiger book algorithm 3.13指出他们可以同时计算，感兴趣可以看看。</p>
<h4 id="第二步：构造预测分析表"><a href="#第二步：构造预测分析表" class="headerlink" title="第二步：构造预测分析表"></a>第二步：构造预测分析表</h4><p><del>打开网站即可<a target="_blank" rel="noopener" href="https://jsmachines.sourceforge.net/machines/ll1.html">LL(1) Parser Generator</a></del><br>不过这个网站对于理解第三步中PDA相关过程很有帮助。</p>
<p>回顾自顶向下推导的两个选择题：</p>
<ul>
<li>替换当前句型中的哪个非终结符?<ul>
<li>“Left-most”一词说明：总是选择每个句型的最左非终结符进行替换</li>
</ul>
</li>
<li>用该非终结符的哪个产生式进行替换? <ul>
<li>构建二维表M, 通过当前非终结符和看到的终结符决定选取何种产生式</li>
</ul>
</li>
</ul>
<p>M的构造：</p>
<ul>
<li>每一行A对应一个非终结符</li>
<li>每一列a对应某个终结符或输入结束符$</li>
<li>表中的某一格M[A,a]表示：针对当前非终结符A，下一个输入Token为终结符a时，可选的产生式集合</li>
<li><img src="/compiler-construction-principles/tableM.png" loading="lazy"></li>
</ul>
<p>构造：对于每个产生式 $X\rightarrow \gamma$</p>
<ul>
<li>如果 $ t\in \text{First}(\gamma)$, 插入产生式 $X\rightarrow \gamma$ 到M[X,t]</li>
<li>如果 $ \gamma \in \text{Nullable} $ 且 $t \in \text{Follow}(X)$, 插入产生式 $X\rightarrow \gamma$ 到M[X,t]</li>
</ul>
<p><strong>如果某一格存在多个产生式，就说明无法确定选取哪个产生式，也就说明不是LL(1)文法！</strong></p>
<h4 id="第三步：预测分析"><a href="#第三步：预测分析" class="headerlink" title="第三步：预测分析"></a>第三步：预测分析</h4><ul>
<li>递归下降<ul>
<li>例如对于文法：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">S -&gt; E $</span><br><span class="line">E -&gt; E + T</span><br><span class="line">E -&gt; E – T</span><br><span class="line">E -&gt; T</span><br><span class="line">T -&gt; T * F</span><br><span class="line">T -&gt; T / F</span><br><span class="line">T -&gt; F</span><br><span class="line">F -&gt; id</span><br><span class="line">F -&gt; num</span><br><span class="line">F -&gt; ( E )</span><br></pre></td></tr></table></figure>
形如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">S</span><span class="params">(<span class="type">void</span>)</span> &#123; E(); eat(EOF); &#125; </span><br><span class="line"><span class="type">void</span> <span class="title function_">E</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(tok) &#123; </span><br><span class="line">    <span class="keyword">case</span> ?: E(); eat(PLUS); T(); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ?: E(); eat(MINUS); T(); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ?: T(); <span class="keyword">break</span>; </span><br><span class="line">    <span class="keyword">default</span>: error();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 问号处内容由预测分析表M决定，读者有兴趣可以帮忙验证一下这个文法是否LL(1)</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>非递归下降（<strong>无需掌握</strong>）<ul>
<li>本质上还是递归下降，只是改写成Pushdown Automata所以相当于模拟一个栈</li>
<li>如果栈顶是非终结符A：利用预测分析表,选择产生式A -&gt; a（也就是将栈顶的非终结符A替换成串a）</li>
<li>如果栈顶是终结符a：将栈顶记号a和输入中的Token匹配并出栈</li>
<li>初态：压入初始符号</li>
<li>终态：输入读取完毕，栈空，此时接受</li>
</ul>
</li>
</ul>
<h3 id="消除左递归、提左公因子"><a href="#消除左递归、提左公因子" class="headerlink" title="消除左递归、提左公因子"></a>消除左递归、提左公因子</h3><p>LL(1)文法的一些性质（可用于判定）：</p>
<ul>
<li>LL(1)文法是无二义的</li>
<li>LL(1)文法是无左递归的</li>
<li>LL(1)文法是无左公因子的</li>
</ul>
<p>左递归(left-recursive)文法:</p>
<ul>
<li>有非终结符A使得 $A \Rightarrow^* A\alpha$</li>
<li>形如 $S\rightarrow Sa$ 的称为直接&#x2F;立即左递归</li>
<li>问题：这会导致递归下降分析进入无限循环<ul>
<li>$S\rightarrow Sa|b$ 分析 $baaaa$</li>
<li>可能永远卡在”a”里而没机会考虑”b”: $ S \Rightarrow Sa \Rightarrow Saa \Rightarrow Saaa \Rightarrow Saaaa …$</li>
</ul>
</li>
<li>解决办法：通过文法变换消除（详见龙书）<ul>
<li>比如我们可以将这一文法：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; A a | b (a,b不以A开头，a不为空)</span><br></pre></td></tr></table></figure>
转为右递归：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; b A&#x27;</span><br><span class="line">A&#x27; -&gt; aA&#x27; | ϵ</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>左公因子的(left-factored)文法:</p>
<ul>
<li>$ P \rightarrow \alpha \beta | \alpha \gamma$</li>
<li>问题：同一非终结符的多个候选式存在共同前缀，可能导致回溯</li>
<li>解决办法：限制文法 或 文法变换<ul>
<li>例如我们可以提取左公因子来“推迟决定”，这样我们可以在读入更多token后进行决策：<br>把<br>$$ P \rightarrow \alpha \beta | \alpha \gamma $$<br>变换为<br>$$ P \rightarrow \alpha Q $$<br>$$ Q \rightarrow \beta | \gamma $$</li>
</ul>
</li>
</ul>
<h3 id="错误恢复"><a href="#错误恢复" class="headerlink" title="错误恢复"></a>错误恢复</h3><p>错误：表M中对应格是空格，没有任何可取的产生式<br>我们不希望遇到错误直接全盘放弃，而是令Parser报错后，尽可能从错误中恢复并继续工作，这样可以一次性尽可能报出程序里全部错误。</p>
<p>可以通过以下几种方式恢复：</p>
<ul>
<li>删除：例如，可以一直跳过token直到遇到当前非终结符对应Follow集中的token</li>
<li>插入：例如，如果左右括号不匹配，我们可以插入一个假装有</li>
<li>替换：例如，变量名错误可以替换为最相近的变量名</li>
</ul>
<h2 id="Part-5-语法分析-自底向上"><a href="#Part-5-语法分析-自底向上" class="headerlink" title="Part 5: 语法分析 - 自底向上"></a>Part 5: 语法分析 - 自底向上</h2><h2 id="Part-6-抽象语法"><a href="#Part-6-抽象语法" class="headerlink" title="Part 6: 抽象语法"></a>Part 6: 抽象语法</h2><h2 id="Part-7-语义分析"><a href="#Part-7-语义分析" class="headerlink" title="Part 7: 语义分析"></a>Part 7: 语义分析</h2><p><em>&gt;&gt;&gt; To be continued…</em></p>

    </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>加载评论需要在浏览器启用 JavaScript 脚本支持。</noscript>
        </div>
    </div>


        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/about/">关于</a></li>
        
          <li><a href="/archives/">归档</a></li>
        
          <li><a href="/categories/">分类</a></li>
        
          <li><a target="_blank" rel="noopener" href="https://github.com/cubicYYY/">GitHub</a></li>
        
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">编译原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-0-%E8%AF%BE%E7%A8%8B%E4%BF%A1%E6%81%AF"><span class="toc-number">1.1.</span> <span class="toc-text">Part 0: 课程信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-1-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.2.</span> <span class="toc-text">Part 1: 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-2-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.3.</span> <span class="toc-text">Part 2: 词法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E6%A6%82%E8%BF%B0"><span class="toc-number">1.3.1.</span> <span class="toc-text">词法分析概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.3.2.</span> <span class="toc-text">正则表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-number">1.3.3.</span> <span class="toc-text">有穷自动机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90"><span class="toc-number">1.3.4.</span> <span class="toc-text">词法分析器自动生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lex%E5%B7%A5%E5%85%B7"><span class="toc-number">1.3.5.</span> <span class="toc-text">Lex工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-3-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-CFG-amp-Parsing"><span class="toc-number">1.4.</span> <span class="toc-text">Part 3: 语法分析 - CFG &amp; Parsing</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">1.4.1.</span> <span class="toc-text">语法分析器概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95CFG-x3D-Context-Free-Language"><span class="toc-number">1.4.2.</span> <span class="toc-text">上下文无关文法CFG&#x3D;Context Free Language</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E5%AF%BCDerivation%E5%92%8C%E8%A7%84%E7%BA%A6Reduction"><span class="toc-number">1.4.3.</span> <span class="toc-text">推导Derivation和规约Reduction</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B7%A6%E6%8E%A8%E5%AF%BCLeft-most-Derivation"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">最左推导Left-most Derivation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%A5%E5%9E%8B-Sentential-form-%E5%8F%A5%E5%AD%90-Sentence-%E8%AF%AD%E8%A8%80-Language"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">句型(Sentential form) 句子(Sentence) 语言(Language)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E6%96%87%E6%B3%95-RE-%E4%B8%8E-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95-CFG"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">正则文法(RE) 与 上下文无关文法(CFG)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CFG%E7%9A%84%E5%88%86%E6%9E%90%E6%A0%91Parse-Tree"><span class="toc-number">1.4.4.</span> <span class="toc-text">CFG的分析树Parse Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-Parsing-%E4%B8%AD%E7%9A%84%E6%8C%91%E6%88%98"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">语法分析(Parsing)中的挑战</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E6%96%87%E6%B3%95%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">编程语言的文法设计</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-4-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B"><span class="toc-number">1.5.</span> <span class="toc-text">Part 4: 语法分析 - 自顶向下</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LL-1-%E5%92%8C%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E6%B3%95-Predictive-parsing"><span class="toc-number">1.5.1.</span> <span class="toc-text">LL(1)和预测分析法(Predictive parsing)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#First%E9%9B%86%E5%92%8CFollow%E9%9B%86"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">First集和Follow集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E8%AE%A1%E7%AE%97First-Follow"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">第一步：计算First, Follow</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Nullable%E9%9B%86"><span class="toc-number">1.5.1.2.1.</span> <span class="toc-text">Nullable集</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E6%9E%84%E9%80%A0%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E8%A1%A8"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">第二步：构造预测分析表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90"><span class="toc-number">1.5.1.4.</span> <span class="toc-text">第三步：预测分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E9%99%A4%E5%B7%A6%E9%80%92%E5%BD%92%E3%80%81%E6%8F%90%E5%B7%A6%E5%85%AC%E5%9B%A0%E5%AD%90"><span class="toc-number">1.5.2.</span> <span class="toc-text">消除左递归、提左公因子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E6%81%A2%E5%A4%8D"><span class="toc-number">1.5.3.</span> <span class="toc-text">错误恢复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-5-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A"><span class="toc-number">1.6.</span> <span class="toc-text">Part 5: 语法分析 - 自底向上</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-6-%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95"><span class="toc-number">1.7.</span> <span class="toc-text">Part 6: 抽象语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-7-%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90"><span class="toc-number">1.8.</span> <span class="toc-text">Part 7: 语义分析</span></a></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://cubicy.icu/compiler-construction-principles/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://cubicy.icu/compiler-construction-principles/&text=编译原理课程笔记"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://cubicy.icu/compiler-construction-principles/&title=编译原理课程笔记"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://cubicy.icu/compiler-construction-principles/&is_video=false&description=编译原理课程笔记"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=编译原理课程笔记&body=Check out this article: http://cubicy.icu/compiler-construction-principles/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://cubicy.icu/compiler-construction-principles/&title=编译原理课程笔记"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://cubicy.icu/compiler-construction-principles/&title=编译原理课程笔记"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://cubicy.icu/compiler-construction-principles/&title=编译原理课程笔记"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://cubicy.icu/compiler-construction-principles/&title=编译原理课程笔记"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://cubicy.icu/compiler-construction-principles/&name=编译原理课程笔记&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://cubicy.icu/compiler-construction-principles/&t=编译原理课程笔记"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2024
    Cubic Y^3
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/cubicYYY/">GitHub</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'cubicy';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>

<!-- utterances Comments -->

</body>
</html>
