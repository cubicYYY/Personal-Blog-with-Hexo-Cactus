<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Cubic Y³ • Posts by &#34;compiler&#34; tag</title>
        <link>http://cubicy.icu</link>
        <description>Notes, CTF, DIY, thoughts and waifus.

I&#39;m CubicYYY, an undergraduate student majoring in Computer Science at Zhejiang University.
Learning: Electric guitar
❤❤❤ CTF, toy projects, anime
✖✖✖ Technological supremacy
Resume is [here](https://latexonline.cc/compile?git=https://github.com/cubicYYY/resume&amp;target=resume.tex&amp;command=xelatex).</description>
        <language>zh-CN</language>
        <pubDate>Sun, 14 Apr 2024 01:10:20 +0800</pubDate>
        <lastBuildDate>Sun, 14 Apr 2024 01:10:20 +0800</lastBuildDate>
        <category>Misc</category>
        <category>Write-Up</category>
        <category>出题</category>
        <category>CISCN</category>
        <category>web</category>
        <category>Hackergame</category>
        <category>SchoolBus</category>
        <category>Rust</category>
        <category>Lifetime</category>
        <category>Code</category>
        <category>Programming</category>
        <category>冰菓</category>
        <category>古籍研究社</category>
        <category>Treap</category>
        <category>BST</category>
        <category>图论</category>
        <category>Kruskal</category>
        <category>Stack</category>
        <category>Splay</category>
        <category>数链剖分</category>
        <category>持久化</category>
        <category>线段树</category>
        <category>树状数组</category>
        <category>LCA</category>
        <category>分块</category>
        <category>哈希</category>
        <category>Phar</category>
        <category>反序列化</category>
        <category>PHP</category>
        <category>Compiler</category>
        <category>Computer Science</category>
        <category>On Going</category>
        <category>NLP</category>
        <category>Fuzzing</category>
        <category>AFL</category>
        <category>Math</category>
        <category>Translation</category>
        <category>Yoneda Lemma</category>
        <category>Miscellaneous</category>
        <item>
            <guid isPermalink="true">http://cubicy.icu/compiler-construction-principles/</guid>
            <title>编译原理课程笔记</title>
            <link>http://cubicy.icu/compiler-construction-principles/</link>
            <category>Compiler</category>
            <category>Computer Science</category>
            <category>On Going</category>
            <pubDate>Sun, 14 Apr 2024 01:10:20 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;编译原理&#34;&gt;&lt;a href=&#34;#编译原理&#34; class=&#34;headerlink&#34; title=&#34;编译原理&#34;&gt;&lt;/a&gt;编译原理&lt;/h1&gt;&lt;p&gt;以&lt;strong&gt;快速复习&lt;/strong&gt;为目的。&lt;br&gt;文中部分图片与文字来自于姚老师(ZJU, pyaoaa at zju.edu.cn)&lt;/p&gt;
&lt;h2 id=&#34;Part-0-课程信息&#34;&gt;&lt;a href=&#34;#Part-0-课程信息&#34; class=&#34;headerlink&#34; title=&#34;Part 0: 课程信息&#34;&gt;&lt;/a&gt;Part 0: 课程信息&lt;/h2&gt;&lt;p&gt;使用教材：&lt;em&gt;Modern Compiler Implementation in C&lt;/em&gt;, Andrew W. Appel （A.K.A 虎书）&lt;/p&gt;
&lt;p&gt;相关课程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://web.stanford.edu/class/cs143/&#34;&gt;Stanford课程主页&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/6035/sp21&#34;&gt;MIT课程主页&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://inst.eecs.berkeley.edu/~cs164/fa21/&#34;&gt;UCBerkeley课程主页&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分数构成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;课程作业(课后小型练习题) &amp;#x3D; 10%&lt;/li&gt;
&lt;li&gt;随堂测验&amp;#x3D; 10%&lt;/li&gt;
&lt;li&gt;期中考试&amp;#x3D; 15%&lt;/li&gt;
&lt;li&gt;综合性课程设计&amp;#x3D; 25%&lt;/li&gt;
&lt;li&gt;期末考试&amp;#x3D; 40% （斩杀线40&amp;#x2F;100）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前置知识：计算理论（笔记参考&lt;a href=&#34;https://note.tonycrane.cc/cs/tcs/toc/&#34;&gt;https://note.tonycrane.cc/cs/tcs/toc/&lt;/a&gt;）&lt;/p&gt;
&lt;h2 id=&#34;Part-1-简介&#34;&gt;&lt;a href=&#34;#Part-1-简介&#34; class=&#34;headerlink&#34; title=&#34;Part 1: 简介&#34;&gt;&lt;/a&gt;Part 1: 简介&lt;/h2&gt;&lt;p&gt;基本概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中间代码&amp;#x3D;Intermediate Code&lt;/li&gt;
&lt;li&gt;词法分析&amp;#x3D;Lexing&amp;#x2F;Scanning&amp;#x2F;LexicalAnalysis&lt;/li&gt;
&lt;li&gt;语法分析&amp;#x3D;Parsing&amp;#x2F;SyntaxAnalysis&lt;/li&gt;
&lt;li&gt;中间表示&amp;#x3D;IR&amp;#x3D;Intermediate Representation&lt;/li&gt;
&lt;li&gt;树型中间表示&amp;#x3D;IR Tree&lt;/li&gt;
&lt;li&gt;前端，后端&lt;br&gt;略。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Part-2-词法分析&#34;&gt;&lt;a href=&#34;#Part-2-词法分析&#34; class=&#34;headerlink&#34; title=&#34;Part 2: 词法分析&#34;&gt;&lt;/a&gt;Part 2: 词法分析&lt;/h2&gt;&lt;h3 id=&#34;词法分析概述&#34;&gt;&lt;a href=&#34;#词法分析概述&#34; class=&#34;headerlink&#34; title=&#34;词法分析概述&#34;&gt;&lt;/a&gt;词法分析概述&lt;/h3&gt;&lt;p&gt;将输入字符串识别为有意义的子串。（把基本单元划分好）&lt;br&gt;(Token单词, Lexeme词素(可选)) e.g. (IF, ) (ELSE, ) (BINARY_OP, &amp;gt;&amp;#x3D;) (UNARY_OP, &amp;amp;)&lt;/p&gt;
&lt;h3 id=&#34;正则表达式&#34;&gt;&lt;a href=&#34;#正则表达式&#34; class=&#34;headerlink&#34; title=&#34;正则表达式&#34;&gt;&lt;/a&gt;正则表达式&lt;/h3&gt;&lt;p&gt;Regex Expression &amp;#x3D; RE&lt;br&gt;运算：连接concatenation + 幂Power&lt;br&gt;e.g.: $ ab(a|b)^3c^* $&lt;br&gt;下略。&lt;/p&gt;
&lt;h3 id=&#34;有穷自动机&#34;&gt;&lt;a href=&#34;#有穷自动机&#34; class=&#34;headerlink&#34; title=&#34;有穷自动机&#34;&gt;&lt;/a&gt;有穷自动机&lt;/h3&gt;&lt;p&gt;相关概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;NFA&amp;#x2F;DFA：略&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;子集构造法subsetconstruction(NFA-&amp;gt;DFA)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DFA的每个状态是NFA的状态集合的一个子集&lt;/li&gt;
&lt;li&gt;读了输入ai后NFA能到达的所有状态：s1,s2,…,sk，则DFA到达一个状态，对应于NFA的{s1,s2,…,sk}&lt;/li&gt;
&lt;li&gt;NFA状态(集)上的一些操作定义&lt;ul&gt;
&lt;li&gt;ε-closure(s):&amp;#x3D; NFA状态s的ε-闭包&amp;#x3D;s经ε转换所能到达的状态集合&lt;/li&gt;
&lt;li&gt;ε-closure(T):&amp;#x3D; T中所有状态的ε-闭包的并集,即 $ \cup_{s\in T}{\epsilon-closure(s)} $&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;过程&lt;ol&gt;
&lt;li&gt;NFA的初始状态S的ε-闭包对应于DFA的初始状态&lt;/li&gt;
&lt;li&gt;针对每个DFA状态(对应NFA状态子集A)，求输入每个可能输入ai后能到达的NFA状态的ε-闭包并集（NFA从状态集A出发，读入ai后能到达的状态集合） $$ S&amp;#x3D;\epsilon-closure(move(A,a_i)) $$&lt;/li&gt;
&lt;li&gt;该集合S要么对应于DFA中的一个已有状态，要么令其成为一个新加的DFA状态&lt;/li&gt;
&lt;li&gt;重复上述两步，逐步构造DFA的状态转换表（每个状态集合S与每个输入ai），直到不动点（不再新增状态，且状态转移表完全求出，即对任一状态集合S已知分别接受所有输入ai将分别转移到何状态）&lt;/li&gt;
&lt;li&gt;在DFA中，只要状态集合S包含至少一个原来NFA中的终止状态，就把S标记为终止状态&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;示例（TODO）&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;/compiler-construction-principles/nfa2dfa.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Thumpson构造法(RE-&amp;gt;NFA)：略&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;词法分析器自动生成&#34;&gt;&lt;a href=&#34;#词法分析器自动生成&#34; class=&#34;headerlink&#34; title=&#34;词法分析器自动生成&#34;&gt;&lt;/a&gt;词法分析器自动生成&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;DFA最小化（-&amp;gt;状态最小的DFA，在同构意义下唯一）&lt;/li&gt;
&lt;li&gt;可区分状态：存在串s使其分别从状态s、t出发，一个接受串s，一个拒绝串s，则s与t可区分&lt;/li&gt;
&lt;li&gt;步骤：&lt;ol&gt;
&lt;li&gt;初始等价类，仅由接受状态集合和非接受状态两个集合构成&lt;/li&gt;
&lt;li&gt;用所有可能的输入ai应用于各个集合（走一步）&lt;ul&gt;
&lt;li&gt;只有集合G的每个状态读入同一字符后，都落入（包含在）相同的某个集合，该集合G在这一步才不用细分&lt;/li&gt;
&lt;li&gt;否则集合G要被细分：落入不同集合的对应状态需要被分割进不同集合&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不断重复2直到不动点（任一集合分别对所有输入ai都不可细分）&lt;/li&gt;
&lt;li&gt;此时等价类中的每个集合即对应最小DFA的一个状态。在其上可以轻松构建min-DFA，该过程是trivial的（可以每个组中选择一个状态作代表）。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;示例（TODO）&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;/compiler-construction-principles/DFA-simplify-diverge.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;/compiler-construction-principles/DFA-simplify.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;Lex工具&#34;&gt;&lt;a href=&#34;#Lex工具&#34; class=&#34;headerlink&#34; title=&#34;Lex工具&#34;&gt;&lt;/a&gt;Lex工具&lt;/h3&gt;&lt;p&gt;通常和Yacc一起使用，生成编译器的前端。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;声明部分&lt;ul&gt;
&lt;li&gt;常量：常数标识符&lt;/li&gt;
&lt;li&gt;正则规则定义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;转换规则模式{动作}&lt;ul&gt;
&lt;li&gt;模式&amp;#x3D;正则表达式&lt;/li&gt;
&lt;li&gt;动作&amp;#x3D;识别到相应模式时应调用的处理函数（一般以C语言代码表示）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;辅助函数：动作中使用的函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解决冲突：最长匹配，较前规则优先&lt;/p&gt;
&lt;h2 id=&#34;Part-3-语法分析-CFG-Parsing&#34;&gt;&lt;a href=&#34;#Part-3-语法分析-CFG-Parsing&#34; class=&#34;headerlink&#34; title=&#34;Part 3: 语法分析 - CFG &amp;amp; Parsing&#34;&gt;&lt;/a&gt;Part 3: 语法分析 - CFG &amp;amp; Parsing&lt;/h2&gt;&lt;h3 id=&#34;语法分析器概述&#34;&gt;&lt;a href=&#34;#语法分析器概述&#34; class=&#34;headerlink&#34; title=&#34;语法分析器概述&#34;&gt;&lt;/a&gt;语法分析器概述&lt;/h3&gt;&lt;p&gt;从词法分析器获得Token序列，确认该序列是否可以由语言的文法生成&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于语法错误的程序，报告错误信息&lt;/li&gt;
&lt;li&gt;对于语法正确的程序，生成语法分析树(简称语法树) e.g. 抽象语法树AST&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现：手动 or 自动(使用Parse generator&amp;#x3D;{Yacc, Bison, ANTLR, mehir…})&lt;/p&gt;
&lt;h3 id=&#34;上下文无关文法CFG&#34;&gt;&lt;a href=&#34;#上下文无关文法CFG&#34; class=&#34;headerlink&#34; title=&#34;上下文无关文法CFG&#34;&gt;&lt;/a&gt;上下文无关文法CFG&lt;/h3&gt;&lt;p&gt;CFG &amp;#x3D; Context Free Language&lt;/p&gt;
&lt;p&gt;$$ G&amp;#x3D;(T,N,P,S) $$&lt;br&gt;T：终结符集合(Terminals)&lt;br&gt;N：非终结符集合(Non-terminals)&lt;br&gt;P：产生式集合(Productions) $ A\rightarrow a, A \in N, a \in (T \cup N)^*$&lt;br&gt;S：开始符号(Startsymbol): $ S \in N $&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;📕“上下文无关”体现在：产生式左侧只有一个非终结符，因此类似 $xAy\rightarrow xay$这样，需要关心符号前后别的符号是什么才能应用的产生式是不能在CFG里的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;特殊符号：$ &amp;#x3D;end of file(EOF)&lt;br&gt;添加一个新符号S’与一条新规则以表明必须在尾部：&lt;ul&gt;
&lt;li&gt;$ S’ \rightarrow S$ $&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;产生式缩写：左侧一样的产生式可以把右侧使用”|”合并。例如 $E\rightarrow E+E|(E)|id$&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;推导Derivation和规约Reduction&#34;&gt;&lt;a href=&#34;#推导Derivation和规约Reduction&#34; class=&#34;headerlink&#34; title=&#34;推导Derivation和规约Reduction&#34;&gt;&lt;/a&gt;推导Derivation和规约Reduction&lt;/h3&gt;&lt;p&gt;例如有产生式 $A\rightarrow \gamma$，我们可以有 $\alpha A \beta \Rightarrow \alpha \gamma \beta$&lt;br&gt;那么我们说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\alpha A \beta $ &lt;strong&gt;直接推导&lt;/strong&gt;到 $ \alpha \gamma \beta$&lt;/li&gt;
&lt;li&gt;$\alpha \gamma \beta $ &lt;strong&gt;直接规约&lt;/strong&gt;到 $  \alpha A \beta$&lt;br&gt;不言而喻的&lt;strong&gt;多步推导记号&lt;/strong&gt;：$\Rightarrow^5$ $\Rightarrow^+$ $\Rightarrow^*$&lt;br&gt;分别代表五步推导，至少一步推导，0次或更多次推导&lt;/li&gt;
&lt;li&gt;推导&amp;#x3D;从文法生成语言里的句子，规约&amp;#x3D;识别句子成分并逐渐规约到开始符号&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;最左推导Left-most-Derivation&#34;&gt;&lt;a href=&#34;#最左推导Left-most-Derivation&#34; class=&#34;headerlink&#34; title=&#34;最左推导Left-most Derivation&#34;&gt;&lt;/a&gt;最左推导Left-most Derivation&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;最左推导&amp;#x3D;每步代换最左边的非终结符。逆过程为最右规约&lt;/li&gt;
&lt;li&gt;类比可得出最右推导、最左规约的定义&lt;/li&gt;
&lt;li&gt;在自顶向下的分析中，总是采用&lt;strong&gt;最左推导&lt;/strong&gt;；在自底向上的分析中，总是采用&lt;strong&gt;最左归约&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/compiler-construction-principles/lmrm.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;句型-Sentential-form-句子-Sentence-语言-Language&#34;&gt;&lt;a href=&#34;#句型-Sentential-form-句子-Sentence-语言-Language&#34; class=&#34;headerlink&#34; title=&#34;句型(Sentential form) 句子(Sentence) 语言(Language)&#34;&gt;&lt;/a&gt;句型(Sentential form) 句子(Sentence) 语言(Language)&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;句型 &amp;#x3D; 文法G下可能推导出的一个符号序列：可能包含终结符&amp;#x2F;非终结符，可为空&lt;/li&gt;
&lt;li&gt;句子 &amp;#x3D; 不含非终结符的句型（仅含终结符）&lt;/li&gt;
&lt;li&gt;语言 &amp;#x3D; 文法G可产生的所有句子的集合&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;正则文法-RE-与-上下文无关文法-CFG&#34;&gt;&lt;a href=&#34;#正则文法-RE-与-上下文无关文法-CFG&#34; class=&#34;headerlink&#34; title=&#34;正则文法(RE) 与 上下文无关文法(CFG)&#34;&gt;&lt;/a&gt;正则文法(RE) 与 上下文无关文法(CFG)&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;上下文无关语言L(G) :&amp;#x3D; CFG产生的所有句子的集合&lt;/li&gt;
&lt;li&gt;正则语言L(r) :&amp;#x3D; RE产生的所有句子的集合&lt;ul&gt;
&lt;li&gt;RE &amp;#x3D; Regex Expression &amp;#x3D; 正则表达式&lt;/li&gt;
&lt;li&gt;正则表达式r定义正则语言L(r)&lt;/li&gt;
&lt;li&gt;$ L(r) \in L(G) $：因为正则对产生式限制更大，必须为( $A,B \in N, a \in T\cup {\epsilon} $ )：&lt;ul&gt;
&lt;li&gt;左线性文法：形如 $A\rightarrow aB$ 或 $A\rightarrow a$&lt;/li&gt;
&lt;li&gt;右线性文法：形如 $A\rightarrow Ba$ 或 $A\rightarrow a$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;正则语言可用于词法分析，上下文无关语言可用于语法分析（语言描述能力、复杂性决定的）&lt;/li&gt;
&lt;li&gt;Chomsky（计算理论课程内容）: &lt;ul&gt;
&lt;li&gt;0型文法&amp;#x3D;短语结构文法 递归可枚举&lt;/li&gt;
&lt;li&gt;1型文法&amp;#x3D;上下文有关文法&lt;/li&gt;
&lt;li&gt;2型文法&amp;#x3D;CFG&lt;/li&gt;
&lt;li&gt;3型文法&amp;#x3D;RE&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;CFG的分析树Parse-Tree&#34;&gt;&lt;a href=&#34;#CFG的分析树Parse-Tree&#34; class=&#34;headerlink&#34; title=&#34;CFG的分析树Parse Tree&#34;&gt;&lt;/a&gt;CFG的分析树Parse Tree&lt;/h3&gt;&lt;p&gt;分析树性质&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根节点&amp;#x3D;文法初始符号&lt;/li&gt;
&lt;li&gt;叶节点&amp;#x3D;终结符&lt;/li&gt;
&lt;li&gt;内部节点&amp;#x3D;非终结符&lt;/li&gt;
&lt;li&gt;父节点→{叶节点}&amp;#x3D;产生式&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;语法分析-Parsing-中的挑战&#34;&gt;&lt;a href=&#34;#语法分析-Parsing-中的挑战&#34; class=&#34;headerlink&#34; title=&#34;语法分析(Parsing)中的挑战&#34;&gt;&lt;/a&gt;语法分析(Parsing)中的挑战&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;核心目标：对于终结符号串x，要么从S推导出x，要么设法将x规约到S&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自顶向下(Top-down) S-&amp;gt;x, 从&lt;strong&gt;根节点&lt;/strong&gt;开始构造Parse Tree&lt;/li&gt;
&lt;li&gt;自底向上(Bottom-up) x-&amp;gt;S, 从&lt;strong&gt;叶节点&lt;/strong&gt;开始构造Parse Tree&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作为搜索问题：搜索空间大-&amp;gt;空间大小受文法产生式限制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无限制：时间复杂度 $O(n^3)$&lt;/li&gt;
&lt;li&gt;上下文无关语言CFL 的子集需要的典型时间为 $O(n)$，例如&lt;ul&gt;
&lt;li&gt;Predictive parsing using LL(1) grammars&lt;/li&gt;
&lt;li&gt;Shift-Reduce parsing using LR(1) grammars&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;编程语言的文法设计&#34;&gt;&lt;a href=&#34;#编程语言的文法设计&#34; class=&#34;headerlink&#34; title=&#34;编程语言的文法设计&#34;&gt;&lt;/a&gt;编程语言的文法设计&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;核心：无二义性&lt;/strong&gt;&lt;br&gt;二义性来源：某些句子存在不止一棵分析树&amp;#x3D;有两个不同的最左推导&amp;#x3D;&lt;strong&gt;多种可选推导处于文法同一层&lt;/strong&gt;&lt;br&gt;例如：$$E \Rightarrow E*E \Rightarrow id*E \Rightarrow id*E+E$$ 与 $$E \Rightarrow E+E \Rightarrow E*E+E \Rightarrow id*E+E $$&lt;br&gt;对于”3*4+5”，前者给出3*(4+5)&amp;#x3D;27（错误），后者给出3*4+5&amp;#x3D;17（正确）。&lt;/p&gt;
&lt;p&gt;解决办法：确保只有一种最左推导&amp;#x3D;将同一层文法分层&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;规定符号优先级（”*“” &amp;gt; “+”,”-“）&lt;ul&gt;
&lt;li&gt;越接近开始符号S的文法符号优先级越低&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;规定符号结合性（左结合&amp;#x2F;右结合）&lt;ul&gt;
&lt;li&gt;递归非终结符（也就是这个终结符在产生式左部右部都出现）在终结符（也就是这个运算符，比如&lt;code&gt;*&lt;/code&gt;,&lt;code&gt;+&lt;/code&gt;）左边，运算就左结合&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;/compiler-construction-principles/priority.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;判定CFG二义性：不可判定问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;但可以通过给定充分条件（无二义文法）确保无二义性&lt;ul&gt;
&lt;li&gt;自顶向下：LL(1)&lt;/li&gt;
&lt;li&gt;自底向上：LR(1), LALR(1)&lt;br&gt;&lt;a name=&#34;grammars-set&#34;&gt;&lt;/a&gt;&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/grammars.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Part-4-语法分析-自顶向下&#34;&gt;&lt;a href=&#34;#Part-4-语法分析-自顶向下&#34; class=&#34;headerlink&#34; title=&#34;Part 4: 语法分析 - 自顶向下&#34;&gt;&lt;/a&gt;Part 4: 语法分析 - 自顶向下&lt;/h2&gt;&lt;p&gt;自顶向下每一步的推导都需要做出&lt;strong&gt;两个选择&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;替换哪个非终结符？&lt;/li&gt;
&lt;li&gt;应用哪个（左侧为该终结符的）产生式替换？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通用形式：&lt;strong&gt;递归下降分析(Recursive-Descent Parsing)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发生错误（没有产生式可以产生合法的子节点）就回溯&lt;/li&gt;
&lt;li&gt;问题：太慢！&lt;/li&gt;
&lt;li&gt;该过程类似NFA，能否构造类似DFA的分析方法？&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;LL-1-和预测分析法&#34;&gt;&lt;a href=&#34;#LL-1-和预测分析法&#34; class=&#34;headerlink&#34; title=&#34;LL(1)和预测分析法&#34;&gt;&lt;/a&gt;LL(1)和预测分析法&lt;/h3&gt;&lt;p&gt;预测分析法(Predictive parsing)：接受LL(k)文法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个L: “left to right” 从左到右扫描&lt;/li&gt;
&lt;li&gt;第二个L: “left-most derivation” 最左推导&lt;/li&gt;
&lt;li&gt;k: 向前看k个token确定推导选用的产生式（一般不明确说k就是k&amp;#x3D;1）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来需要添加约束使其无需回溯。我们先引入几个概念：&lt;/p&gt;
&lt;h4 id=&#34;First集和Follow集&#34;&gt;&lt;a href=&#34;#First集和Follow集&#34; class=&#34;headerlink&#34; title=&#34;First集和Follow集&#34;&gt;&lt;/a&gt;First集和Follow集&lt;/h4&gt;&lt;p&gt;给定 $ G&amp;#x3D;(T,N,P,S),\alpha \in (T\cup N)^* $&lt;br&gt;&lt;strong&gt;记空串为$\epsilon$&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;First集：可从$\alpha$推导得到的串的首个终结符的集合（也就是说，$\alpha$自己推导出的第一个终结符可能是什么）&lt;br&gt;$$ \text{First}(\alpha)&amp;#x3D;{a| \alpha \Rightarrow^*a…\ ,a\in T} $$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Follow集：从S出发，可能在推导过程中跟在A右边的终结符号集&lt;br&gt;$$ \text{Follow}(A)&amp;#x3D;{a|S\Rightarrow^*…Aa…\ ,a\in T} $$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如: $ S\rightarrow \alpha\ A a\ \beta $，终结符号 $ a\in \text{Follow}(A) $ （仔细区分a和α）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们至此可以使用两个条件保证产生式的选择是唯一的：&lt;br&gt;对于产生式 $ A\rightarrow \alpha|\beta $ ,&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$ \text{First}(\alpha)\cap \text{First}(\beta)&amp;#x3D; \emptyset $ （α和β推导不出以同一个单词为首的串）&lt;ul&gt;
&lt;li&gt;意义：显然的。这样看终结符是哪个就知道应该用哪个产生式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;若$\beta \Rightarrow^* \epsilon$，那么$\alpha \nRightarrow^* \epsilon$，且 $ \text{First}(\alpha) \cap Follow(A) &amp;#x3D; \emptyset $ （α和β不能同时推出$\epsilon$;First(α)不应在Follow(A) 中）&lt;ul&gt;
&lt;li&gt;意义：其实就是考虑如果可以推导出空串时，后继终结符因为是空串所以暂时还没法确定，得从Follow集中寻找（再向后看），最终做出哪个产生式的选择。&lt;br&gt;在&lt;strong&gt;满足这条要求的情况下&lt;/strong&gt;，假设下一个输入是b,且$\beta \Rightarrow^* \epsilon$&lt;ul&gt;
&lt;li&gt;如果b∈First(α)，则选择A → α(属于上面1的情况)&lt;/li&gt;
&lt;li&gt;如果b∈Follow(A)，则选择A → β ,这对应A最终到达了$\epsilon$而且后面紧跟着终结符b的情况&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;应试建议：直接列出LL(1)分析表并检查是否有&lt;em&gt;冲突&lt;/em&gt;（见下文）。&lt;/strong&gt;&lt;br&gt;接下来我们会看到具体的实现方式以实现LL(1)预测分析。三步走：计算First,Follow-&amp;gt;构造预测分析表-&amp;gt;预测分析&lt;/p&gt;
&lt;h4 id=&#34;第一步：计算First-Follow&#34;&gt;&lt;a href=&#34;#第一步：计算First-Follow&#34; class=&#34;headerlink&#34; title=&#34;第一步：计算First, Follow&#34;&gt;&lt;/a&gt;第一步：计算First, Follow&lt;/h4&gt;&lt;h5 id=&#34;Nullable集&#34;&gt;&lt;a href=&#34;#Nullable集&#34; class=&#34;headerlink&#34; title=&#34;Nullable集&#34;&gt;&lt;/a&gt;Nullable集&lt;/h5&gt;&lt;p&gt;由于刚刚提到了空串，我们需要引入一个简单的新定义：Nullable集&amp;#x3D;{可推导出空串的符号}。&lt;br&gt;定义是递归的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Base Case: 如果有产生式 $ X\rightarrow \epsilon$, 那么X当然是Nullable的&lt;/li&gt;
&lt;li&gt;Inductive Case: 如果有产生式 $ X\rightarrow Y_1 Y_2 Y_3 … Y_n$, 且 $Y_1,Y_2,Y_3,…,Y_n$&lt;strong&gt;每个都能&lt;/strong&gt;推导出空串，则X是Nullable的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于每个产生式，我们可以循环用它们不断更新Nullable集直到不动点。这同样适用于First集与Follow集。&lt;/p&gt;
&lt;p&gt;First集：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Base Case: 如果X是终结符terminal: First(X)&amp;#x3D;{X}&lt;/li&gt;
&lt;li&gt;Inductive Case: 如果有产生式 $ X\rightarrow Y_1 Y_2 Y_3 … Y_n$&lt;ul&gt;
&lt;li&gt;首先，$\text{First}(X) \cup &amp;#x3D; \text{First}(Y_1)$ ($ a\cup &amp;#x3D; b$意为$ a \leftarrow a\cup b$，也就是把b并进a里)&lt;/li&gt;
&lt;li&gt;如果$Y_1 \in \text{Nullable}: $$\text{First}(X) \cup &amp;#x3D; \text{First}(Y_2)$&lt;/li&gt;
&lt;li&gt;如果$Y_1,Y_2 \in \text{Nullable}: $$\text{First}(X) \cup &amp;#x3D; \text{First}(Y_3)$&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;li&gt;直到某个$Y_i \notin \text{Nullable}$则停止&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于每个产生式，我们可以循环用它们不断更新First集直到不动点。&lt;/p&gt;
&lt;p&gt;Follow集：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Base Case: $ \text{Follow}(A)&amp;#x3D;\emptyset $&lt;/li&gt;
&lt;li&gt;Inductive Case: 如果有产生式 $ B\rightarrow s_1 A\ s_2 $&lt;ul&gt;
&lt;li&gt;$\text{Follow}(A) \cup &amp;#x3D; \text{First}(s_2)$&lt;/li&gt;
&lt;li&gt;如果$s_2 \in \text{Nullable}$, $\text{Follow}(A) \cup &amp;#x3D; \text{Follow}(B)$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于每个产生式，我们可以循环用它们不断更新Follow集直到不动点。&lt;/p&gt;
&lt;p&gt;Tips(不要求掌握):Tiger book algorithm 3.13指出他们可以同时计算，感兴趣可以看看。&lt;/p&gt;
&lt;h4 id=&#34;第二步：构造预测分析表&#34;&gt;&lt;a href=&#34;#第二步：构造预测分析表&#34; class=&#34;headerlink&#34; title=&#34;第二步：构造预测分析表&#34;&gt;&lt;/a&gt;第二步：构造预测分析表&lt;/h4&gt;&lt;p&gt;&lt;del&gt;打开网站即可&lt;a href=&#34;https://jsmachines.sourceforge.net/machines/ll1.html&#34;&gt;LL(1) Parser Generator&lt;/a&gt;&lt;/del&gt;&lt;br&gt;不过这个网站对于理解第三步中PDA相关过程很有帮助。&lt;/p&gt;
&lt;p&gt;回顾自顶向下推导的两个选择题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;替换当前句型中的哪个非终结符?&lt;ul&gt;
&lt;li&gt;“Left-most”一词说明：总是选择每个句型的最左非终结符进行替换&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用该非终结符的哪个产生式进行替换? &lt;ul&gt;
&lt;li&gt;构建二维表M, 通过当前非终结符和看到的终结符决定选取何种产生式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;M的构造：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每一行A对应一个非终结符&lt;/li&gt;
&lt;li&gt;每一列a对应某个终结符或输入结束符$&lt;/li&gt;
&lt;li&gt;表中的某一格M[A,a]表示：针对当前非终结符A，下一个输入Token为终结符a时，可选的产生式集合&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;/compiler-construction-principles/tableM.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;构造：对于每个产生式 $X\rightarrow \gamma$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 $ t\in \text{First}(\gamma)$, 插入产生式 $X\rightarrow \gamma$ 到M[X,t]&lt;/li&gt;
&lt;li&gt;如果 $ \gamma \in \text{Nullable} $ 且 $t \in \text{Follow}(X)$, 插入产生式 $X\rightarrow \gamma$ 到M[X,t]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;如果某一格存在多个产生式，就说明无法确定选取哪个产生式（也即：产生了&lt;em&gt;冲突&lt;/em&gt;），也就说明不是LL(1)文法！&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;第三步：预测分析&#34;&gt;&lt;a href=&#34;#第三步：预测分析&#34; class=&#34;headerlink&#34; title=&#34;第三步：预测分析&#34;&gt;&lt;/a&gt;第三步：预测分析&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;递归下降&lt;ul&gt;
&lt;li&gt;例如对于文法：&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;S -&amp;gt; E $&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;E -&amp;gt; E + T&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;E -&amp;gt; E – T&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;E -&amp;gt; T&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;T -&amp;gt; T * F&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;T -&amp;gt; T / F&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;T -&amp;gt; F&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;F -&amp;gt; id&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;F -&amp;gt; num&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;F -&amp;gt; ( E )&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
形如：&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt;)&lt;/span&gt; &amp;#123; E(); eat(EOF); &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt;)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;switch&lt;/span&gt;(tok) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;case&lt;/span&gt; ?: E(); eat(PLUS); T(); &lt;span class=&#34;keyword&#34;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;case&lt;/span&gt; ?: E(); eat(MINUS); T(); &lt;span class=&#34;keyword&#34;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;case&lt;/span&gt; ?: T(); &lt;span class=&#34;keyword&#34;&gt;break&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;default&lt;/span&gt;: error();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 问号处内容由预测分析表M决定，读者有兴趣可以帮忙验证一下这个文法是否LL(1)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;非递归下降（&lt;strong&gt;无需掌握&lt;/strong&gt;）&lt;ul&gt;
&lt;li&gt;本质上还是递归下降，只是改写成Pushdown Automata所以相当于模拟一个栈&lt;/li&gt;
&lt;li&gt;如果栈顶是非终结符A：利用预测分析表,选择产生式A -&amp;gt; a（也就是将栈顶的非终结符A替换成串a）&lt;/li&gt;
&lt;li&gt;如果栈顶是终结符a：将栈顶记号a和输入中的Token匹配并出栈&lt;/li&gt;
&lt;li&gt;初态：压入初始符号&lt;/li&gt;
&lt;li&gt;终态：输入读取完毕，栈空，此时接受&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;消除左递归、提左公因子&#34;&gt;&lt;a href=&#34;#消除左递归、提左公因子&#34; class=&#34;headerlink&#34; title=&#34;消除左递归、提左公因子&#34;&gt;&lt;/a&gt;消除左递归、提左公因子&lt;/h3&gt;&lt;p&gt;LL(1)文法的一些性质（可用于判定）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LL(1)文法是无二义的&lt;/li&gt;
&lt;li&gt;LL(1)文法是无左递归的&lt;/li&gt;
&lt;li&gt;LL(1)文法是无左公因子的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;左递归(left-recursive)文法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有非终结符A使得 $A \Rightarrow^* A\alpha$&lt;/li&gt;
&lt;li&gt;形如 $S\rightarrow Sa$ 的称为直接&amp;#x2F;立即左递归&lt;/li&gt;
&lt;li&gt;问题：这会导致递归下降分析进入无限循环&lt;ul&gt;
&lt;li&gt;$S\rightarrow Sa|b$ 分析 $baaaa$&lt;/li&gt;
&lt;li&gt;可能永远卡在”a”里而没机会考虑”b”: $ S \Rightarrow Sa \Rightarrow Saa \Rightarrow Saaa \Rightarrow Saaaa …$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;解决办法：通过文法变换消除（详见龙书）&lt;ul&gt;
&lt;li&gt;比如我们可以将这一文法：&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;A -&amp;gt; A a | b (a,b不以A开头，a不为空)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
转为右递归：&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;A -&amp;gt; b A&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;A&amp;#x27; -&amp;gt; aA&amp;#x27; | ε&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;左公因子的(left-factored)文法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$ P \rightarrow \alpha \beta | \alpha \gamma$&lt;/li&gt;
&lt;li&gt;问题：同一非终结符的多个候选式存在共同前缀，可能导致回溯&lt;/li&gt;
&lt;li&gt;解决办法：限制文法 或 文法变换&lt;ul&gt;
&lt;li&gt;例如我们可以提取左公因子来“推迟决定”，这样我们可以在读入更多token后进行决策：&lt;br&gt;把&lt;br&gt;$$ P \rightarrow \alpha \beta | \alpha \gamma $$&lt;br&gt;变换为&lt;br&gt;$$ P \rightarrow \alpha Q $$&lt;br&gt;$$ Q \rightarrow \beta | \gamma $$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;错误恢复&#34;&gt;&lt;a href=&#34;#错误恢复&#34; class=&#34;headerlink&#34; title=&#34;错误恢复&#34;&gt;&lt;/a&gt;错误恢复&lt;/h3&gt;&lt;p&gt;错误：表M中对应格是空格，没有任何可取的产生式&lt;br&gt;我们不希望遇到错误直接全盘放弃，而是令Parser报错后，尽可能从错误中恢复并继续工作，这样可以一次性尽可能报出程序里全部错误。&lt;/p&gt;
&lt;p&gt;可以通过以下几种方式恢复：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除：例如，可以一直跳过token直到遇到当前非终结符对应Follow集中的token&lt;/li&gt;
&lt;li&gt;插入：例如，如果左右括号不匹配，我们可以插入一个假装有&lt;/li&gt;
&lt;li&gt;替换：例如，变量名错误可以替换为最相近的变量名&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Part-5-语法分析-自底向上&#34;&gt;&lt;a href=&#34;#Part-5-语法分析-自底向上&#34; class=&#34;headerlink&#34; title=&#34;Part 5: 语法分析 - 自底向上&#34;&gt;&lt;/a&gt;Part 5: 语法分析 - 自底向上&lt;/h2&gt;&lt;p&gt;从串w归约为文法开始符号S的过程。规约时，一个与某产生式体&lt;strong&gt;相匹配的特定子串&lt;/strong&gt;被替换为该产生式头部的&lt;strong&gt;非终结符号&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;何时归约(归约哪些符号串)？&lt;/li&gt;
&lt;li&gt;归约到哪个非终结符号？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;回顾：LL(1)的优势劣势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;+ 运行高效(线性时间)&lt;/li&gt;
&lt;li&gt;+ 递归实现符合文法结构、适合手动构造&amp;amp;自动生成&lt;/li&gt;
&lt;li&gt;- 能分析的文法类型受限&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们提出新文法：LR(k)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表达力: Every LL(k) grammar is also LR(k)&lt;/li&gt;
&lt;li&gt;不要求无左公因式&lt;/li&gt;
&lt;li&gt;可以处理左递归文法&lt;/li&gt;
&lt;li&gt;被广泛采用(Yacc, Bison, …)&lt;/li&gt;
&lt;li&gt;“L”: left-to-right scanning 自左向右扫描&lt;/li&gt;
&lt;li&gt;“R”: right-most derivation in reverse 最右推导的逆&lt;/li&gt;
&lt;li&gt;“k”: 向前看的字符的个数(k省略时取1)&lt;/li&gt;
&lt;li&gt;子集（详见&lt;a href=&#34;#grammars-set&#34;&gt;该图&lt;/a&gt;）：LR(1), LALR(1), SLR, LR(0), …&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;移进-规约-Shift-Reduce&#34;&gt;&lt;a href=&#34;#移进-规约-Shift-Reduce&#34; class=&#34;headerlink&#34; title=&#34;移进-规约 Shift-Reduce&#34;&gt;&lt;/a&gt;移进-规约 Shift-Reduce&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;这是LR(k) Parsing 的一般模式。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;核心思想：将字符串一分为二，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;右侧是未被parser检查过的&lt;/li&gt;
&lt;li&gt;左侧包含终结符与非终结符&lt;br&gt;我们接下来会使用”|”标记分割点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如，考虑该文法： $ E \rightarrow E+(E) | \text{int} $&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;显然并非LL(1)的：存在左递归&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们考虑处理字符串”int+(int)+(int)”，则过程如下：&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/sr.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;可见LR分析采用最右推导的&lt;strong&gt;逆过程&lt;/strong&gt;：最左规约。因此LR分析的每一步都是最右句型。&lt;br&gt;一般实现方式：采用&lt;strong&gt;栈&lt;/strong&gt;进行Shift-Reduce&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;栈：包含左侧字符串&lt;/li&gt;
&lt;li&gt;输入流：包含剩余未处理的右侧字符串&lt;/li&gt;
&lt;li&gt;操作：&lt;ul&gt;
&lt;li&gt;Shift: 从输入读入一个Terminal压入栈&lt;/li&gt;
&lt;li&gt;Reduce: 栈顶的几个元素满足某条产生式的&lt;strong&gt;RHS(Right hand side)&lt;/strong&gt;, 则pop这些元素并压入产生式的&lt;strong&gt;LHS(Left hand side)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Error: 爆！留待后文讨论。&lt;/li&gt;
&lt;li&gt;Accept: shift “$” 并且栈中只剩下文法的开始符号&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;需要解决的问题：&lt;strong&gt;何时shift? 何时reduce?&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;表驱动的LR分析：类似LL文法的表，但行列意义不同，且这个表一般很大（详见后文）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;几个文法的包含关系（仍然是详见&lt;a href=&#34;#grammars-set&#34;&gt;该图&lt;/a&gt;）:&lt;br&gt;$ LR(0) \in SLR(1) \in LALR(1) \in LR(1) $&lt;/p&gt;
&lt;h3 id=&#34;LR-0-Parsing&#34;&gt;&lt;a href=&#34;#LR-0-Parsing&#34; class=&#34;headerlink&#34; title=&#34;LR(0) Parsing&#34;&gt;&lt;/a&gt;LR(0) Parsing&lt;/h3&gt;&lt;p&gt;核心思想：因为需要凑出产生式RHS，维护栈顶内容对于所有产生式右侧的“进度”。&lt;br&gt;项(Item):&amp;#x3D; 一个产生式加上在其中某处的一个点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;产生式 $A\rightarrow XYZ$ 有4个Item: &lt;ul&gt;
&lt;li&gt;$A\rightarrow \bullet XYZ $ &lt;/li&gt;
&lt;li&gt;$A\rightarrow X\bullet YZ $ &lt;/li&gt;
&lt;li&gt;$A\rightarrow XY\bullet Z $ &lt;/li&gt;
&lt;li&gt;$A\rightarrow XYZ \bullet $&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;$ A\rightarrow \alpha \bullet \beta$: 已扫描&amp;#x2F;归约到了α，并期望在接下来的输入中经过扫描&amp;#x2F;归约得到β，然后把αβ归约到A&lt;/li&gt;
&lt;li&gt;$ A\rightarrow \alpha \beta \bullet$: 已扫描&amp;#x2F;归约得到了αβ，此时已经可以把αβ归约为A&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Item类似有穷自动机的状态!&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;一个项读入一个符号后可以转变为另一个项：例如$A\rightarrow \bullet XYZ $ 读入X就可以转为 $A\rightarrow X\bullet YZ $&lt;/li&gt;
&lt;li&gt;显然项的数量是有限的。&lt;/li&gt;
&lt;li&gt;这样的有穷自动机被称为&lt;strong&gt;LR(0)自动机&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;LR-0-Parsing的NFA&#34;&gt;&lt;a href=&#34;#LR-0-Parsing的NFA&#34; class=&#34;headerlink&#34; title=&#34;LR(0)Parsing的NFA&#34;&gt;&lt;/a&gt;LR(0)Parsing的NFA&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;⚠ NFA只能识别正则语言RE，然而RE&amp;lt;LR(0). 所以这里的NFA只是用于辅助记录栈顶识别进度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;新增开始符号S’，并加入产生式” S’-&amp;gt;S$ “&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NFA起始状态：$S’\rightarrow \bullet S$ $ &lt;/li&gt;
&lt;li&gt;NFA终结状态：$S’\rightarrow S\bullet$ $ &lt;/li&gt;
&lt;li&gt;转移：&lt;ul&gt;
&lt;li&gt;$A\rightarrow \bullet XY $ 读入X就可以转为 $A\rightarrow X\bullet Y $&lt;/li&gt;
&lt;li&gt;对于产生式 $ X\rightarrow \alpha Y \beta $ 与 $Y\rightarrow \gamma$ 那么 $ X\rightarrow \alpha \bullet Y \beta $ 可以直接转换（ε-move）到 $ Y \rightarrow \bullet \gamma$ （相当于递归下降法里进入下一层递归，从而分析当前产生式内部的非终结符）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们更希望能转为DFA. 当然可以使用子集构造法转换，但事实上可以直接构造DFA.&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/lr-nfa2dfa.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;LR-0-Parsing的DFA与分析表&#34;&gt;&lt;a href=&#34;#LR-0-Parsing的DFA与分析表&#34; class=&#34;headerlink&#34; title=&#34;LR(0)Parsing的DFA与分析表&#34;&gt;&lt;/a&gt;LR(0)Parsing的DFA与分析表&lt;/h4&gt;&lt;h5 id=&#34;DFA构造&#34;&gt;&lt;a href=&#34;#DFA构造&#34; class=&#34;headerlink&#34; title=&#34;DFA构造&#34;&gt;&lt;/a&gt;DFA构造&lt;/h5&gt;&lt;p&gt;项集闭包CLOSURE:&amp;#x3D; a &lt;strong&gt;set&lt;/strong&gt; of &lt;strong&gt;items&lt;/strong&gt;, 记为I&lt;br&gt;任意符号记为X&lt;br&gt;对任意项集Closure(I)求法（其实就是ε-closure）：&lt;br&gt;Closure(I) &amp;#x3D; &lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;repeat&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  for any item A→ α•Xβ in I&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    for any production X→ γ&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      I ← I + &amp;#123;X→ •γ&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;until I does not change. &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;return I&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;TL;DR: 如果”·”的右边是非终结符X，就把X为LHS的产生式对应的初始项加入。注意这是递归的：加入的新初始项如果也有这个情况还得接着加。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来的构造方式通过类比NFA-&amp;gt;DFA的子集构造法是显然的：&lt;br&gt;GOTO(I,X):&amp;#x3D; I是一个项集，X是一个文法符号，则GOTO(I,X)定义为I中所有形如 $A\rightarrow \bullet X \beta$ 的项所对应的新项 $A\rightarrow X \bullet \beta$ 构成的新集合生成的闭包（I是状态，X是转移，I里符合要求（也就是下一个符号是X）的产生式前移一位越过X加入转移到的新状态，不符合的被丢弃；当然考虑到ε-moves要再求一遍新状态的闭包）&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/lr-dfa.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/lr-dfa-eg.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;DFA到分析表&#34;&gt;&lt;a href=&#34;#DFA到分析表&#34; class=&#34;headerlink&#34; title=&#34;DFA到分析表&#34;&gt;&lt;/a&gt;DFA到分析表&lt;/h5&gt;&lt;p&gt;分析表T类似LL(1)中的表M，但是行列的含义与内容都发生了很大变化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Action表项：&lt;ul&gt;
&lt;li&gt;每一行对应一个状态i&lt;/li&gt;
&lt;li&gt;每一列对应一个&lt;strong&gt;终结符t&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;表中的一格T[i,t]代表要做的操作action，有以下几种可能：&lt;ul&gt;
&lt;li&gt;$s_n$ &amp;#x3D; shift n :&amp;#x3D; 从状态i经过&lt;strong&gt;终结符t&lt;/strong&gt;转移到状态n&lt;ul&gt;
&lt;li&gt;从输入流中取一个终结符t压入状态栈&lt;/li&gt;
&lt;li&gt;将n压入状态栈&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;$r_k$ &amp;#x3D; reduce k :&amp;#x3D; 确定使用第k个产生式进行规约（此时状态i没有出边）&lt;ul&gt;
&lt;li&gt;弹出状态栈顶的几个状态（数量对应产生式#k的RHS长度）&lt;/li&gt;
&lt;li&gt;符号栈压入产生式#k的LHS，也即一个非终结符X&lt;/li&gt;
&lt;li&gt;查询Goto表（见下文）T[i,X]将对应的下一个状态压入状态栈&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;accept :&amp;#x3D; 该状态包含 $S’\rightarrow S \bullet $ $, 接受字符串，运行完毕&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Goto表项：&lt;ul&gt;
&lt;li&gt;每一行对应一个状态i&lt;/li&gt;
&lt;li&gt;每一列对应一个&lt;strong&gt;非终结符X&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;表中的一格T[i,X]表明经过&lt;strong&gt;非终结符X&lt;/strong&gt;下一个状态是什么&lt;/li&gt;
&lt;li&gt;格中的$g_n$ &amp;#x3D; goto n :&amp;#x3D; 从状态i经过&lt;strong&gt;非终结符X&lt;/strong&gt;转移到状态n&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/compiler-construction-principles/dfa2table.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;LR实际实现只有状态栈，符号信息可从相应状态中获取&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下是一个例子：&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/lr0-stack-table.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;如何理解”LR(0)”中的”0”: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Item中没有Lookahead terminal等信息，不关心后面的token&lt;/li&gt;
&lt;li&gt;是否规约&amp;#x2F;使用何产生式规约完全取决于栈顶状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;局限性：由于只要有产生式能规约就立刻规约，很容易产生冲突（也就是表中一格有多个$s_n$,$r_n$，不知道应该直接规约还是需要接受更多符号来完成另一个产生式，这被称作&lt;strong&gt;shift-reduce conflict&lt;/strong&gt;）&lt;br&gt;我们引入新的文法，放宽一些限制。&lt;/p&gt;
&lt;h3 id=&#34;SLR-1-Parsing&#34;&gt;&lt;a href=&#34;#SLR-1-Parsing&#34; class=&#34;headerlink&#34; title=&#34;SLR(1) Parsing&#34;&gt;&lt;/a&gt;SLR(1) Parsing&lt;/h3&gt;&lt;p&gt;SLR(1) &amp;#x3D; Simple LR(1)&lt;/p&gt;
&lt;p&gt;我们说过k省略时默认为1，所以称为SLR文法即可。其实就是LR(0)稍微改改。&lt;/p&gt;
&lt;p&gt;考虑每次规约，都会使用一个产生式 $E\rightarrow \alpha$&lt;br&gt;“LR分析是最右推导的逆过程”，因此每步归约都应该满足：&lt;br&gt;$$ t \in \text{Follow}(E) $$其中t指的是&lt;strong&gt;输入流中下一个token&lt;/strong&gt;, E指的是用于&lt;strong&gt;此规约用到的产生式的左部(LHS)&lt;/strong&gt;.&lt;br&gt;因此对于SLR文法来说，SLR的DFA和LR(0)一样；但LR(0)的分析表中有一些$r_n$是非法的，需要删去。&lt;br&gt;在生成分析表的具体步骤上：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LR(0)的某些状态包含可规约的Item，那么这个状态I在对应的Action表中T[I,_]这一行的每一个格子（无论终结符t是什么）无论如何都会有对应的$r_n$项&lt;/li&gt;
&lt;li&gt;SLR会关心后面的终结符是什么，因此如果t不在Follow集中，这不能是一个合法的规约，Action表对应的t列就不会有这个$r_n$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如，图中被划去的部分即为从LR(0)分析表到SLR分析表的变化：&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/slr-table.png&#34; alt=&#34;SLR分析表：删去了部分规约项&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;规约的条件更严格，也就“自动”消除了一些冲突，也就允许了更多语言被纳入该文法，因此 $\text{LR(0)} \in \text{SLR}$&lt;/p&gt;
&lt;p&gt;局限性：显然不能消除所有shift-reduce冲突。如果产生冲突对应的终结符t恰好在Follow集里，就无法消除。例如考虑如下文法：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;S&amp;#x27; -&amp;gt; S $&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;S -&amp;gt; L = R&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;S -&amp;gt; R&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;L -&amp;gt; id&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;L -&amp;gt; * R&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;R -&amp;gt; L&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由最后两条规则&lt;code&gt;L -&amp;gt; * R&lt;/code&gt; &lt;code&gt;R -&amp;gt; L&lt;/code&gt;可以看出Follow(R)与Follow(L)两个集合互相包含，即相等，即Follow(R)&amp;#x3D;Follow(L)&lt;br&gt;然而’&amp;#x3D;’在Follow(L)&amp;#x3D;{&lt;code&gt;=&lt;/code&gt;,&lt;code&gt;$&lt;/code&gt;}中，因此我们遇到’L&amp;#x3D;…’时仍然不知道应该接受等于号进行shift(这样就可以进一步在&lt;code&gt;S-&amp;gt;L=R&lt;/code&gt;这个产生式中前进)，还是直接使用&lt;code&gt;R-&amp;gt;L&lt;/code&gt;进行reduce.&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/slr-conflict.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/slr-conflict-table.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们需要更多、更精确的限制才能进一步降低冲突的可能。&lt;/p&gt;
&lt;h3 id=&#34;LR-1-Parsing&#34;&gt;&lt;a href=&#34;#LR-1-Parsing&#34; class=&#34;headerlink&#34; title=&#34;LR(1) Parsing&#34;&gt;&lt;/a&gt;LR(1) Parsing&lt;/h3&gt;&lt;p&gt;包含更多信息（后继token）来消除一些归约动作。&lt;br&gt;相当于“分裂”一些LR(0)状态，精确指明何时应该归约。&lt;/p&gt;
&lt;p&gt;LR(1)项(item)的形式：$ A \rightarrow \alpha \bullet \beta,\ a$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;逗号后的a是 &lt;strong&gt;向前看符号(lookahead symbol)&lt;/strong&gt; 即表明向前看一个终结符，可以是$&lt;/li&gt;
&lt;li&gt;和LR(0)对比，处理ε-move时记录合法的向前看符号w.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;计算Closure&#34;&gt;&lt;a href=&#34;#计算Closure&#34; class=&#34;headerlink&#34; title=&#34;计算Closure&#34;&gt;&lt;/a&gt;计算Closure&lt;/h4&gt;&lt;p&gt;对于状态I中的一个item $$A\rightarrow \alpha \bullet X \beta,\ z$$ 以及一个产生式 $$X\rightarrow \gamma$$&lt;br&gt;我们&lt;strong&gt;递归地&lt;/strong&gt;寻找所有 $w\in \text{First}(\beta z)$ 然后加入I：$I\cup&amp;#x3D;{(X\rightarrow \bullet \gamma,\ w) | \forall w\in \text{First}(\beta z) }$（直到不动点为止）&lt;br&gt;起始状态是 $S’\rightarrow \bullet S \$,\ ?$ 的闭包&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们不关心”?”处是什么，因为我们永远不会移进&lt;code&gt;$&lt;/code&gt;.&lt;ul&gt;
&lt;li&gt;所以一种可行的表示是把&lt;code&gt;$&lt;/code&gt;都移到产生式外部，而非真的要产生一个&lt;code&gt;$&lt;/code&gt;符号： $S’\rightarrow \bullet S,\ \$$）&lt;/li&gt;
&lt;li&gt;或者你也可以直接写作：$S’\rightarrow \bullet S\$,\ ?$ （推荐）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;计算Goto表&#34;&gt;&lt;a href=&#34;#计算Goto表&#34; class=&#34;headerlink&#34; title=&#34;计算Goto表&#34;&gt;&lt;/a&gt;计算Goto表&lt;/h4&gt;&lt;p&gt;基本和LR(0)算法保持相同，移入动作不考虑向前看符号z&lt;br&gt;也就是对于转移X，转移前后项的变换是：&lt;br&gt;$$A \rightarrow \alpha \bullet X \beta,\ z \ \ \Rightarrow\ \ A \rightarrow \alpha X \bullet \beta,\ z$$&lt;/p&gt;
&lt;h4 id=&#34;计算Action表：Reduce操作&#34;&gt;&lt;a href=&#34;#计算Action表：Reduce操作&#34; class=&#34;headerlink&#34; title=&#34;计算Action表：Reduce操作&#34;&gt;&lt;/a&gt;计算Action表：Reduce操作&lt;/h4&gt;&lt;p&gt;规约操作是变换较大的部分。&lt;br&gt;在LR(1)中，Action表项中Reduce操作形如$(I, z, A\rightarrow \alpha)$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I: 代表状态I对应的行&lt;/li&gt;
&lt;li&gt;z: 代表向前看符号&lt;/li&gt;
&lt;li&gt;$ A\rightarrow \alpha $ 为规约所采用的产生式&lt;br&gt;这就限制了从某个可规约项规约时，必须向前看一个符号以确保它是lookahead symbol.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/compiler-construction-principles/lr1-items.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;局限性：这样的文法限制过少，过于灵活，导致状态数量过多，状态表过于庞大。&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/lr1-con.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/lr1-dfa.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：话虽如此，文法仍然可能因为R-R冲突与S-R冲突从而导致其不属于LR(1)！这样的例子可以在LR(k)且k&amp;gt;1的文法中大量找到。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此我们在SLR(1)&amp;#x3D;Simple LR(1)与LR(1)之间折中，可以得到一个新文法LALR(1).&lt;/p&gt;
&lt;h3 id=&#34;LALR-1-Parsing&#34;&gt;&lt;a href=&#34;#LALR-1-Parsing&#34; class=&#34;headerlink&#34; title=&#34;LALR(1) Parsing&#34;&gt;&lt;/a&gt;LALR(1) Parsing&lt;/h3&gt;&lt;p&gt;LALR &amp;#x3D; Look-Ahead LR&lt;/p&gt;
&lt;p&gt;动机：发现很多LR(1)中的状态都只有lookahead symbol的区别。能否合并？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LALR(1): 把LR(1)中只有lookahead symbol不同的item合并。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义：把LR(1)中item的集合里所有lookahead symbol去掉，剩下的称为&lt;strong&gt;核(core)&lt;/strong&gt;&lt;br&gt;把LR(1)中所有核相同的状态两两合并为一个状态。每次合并都删除两个旧状态，新增一个新状态，入边出边的连接方式是显然的，直接接在新状态上即可。&lt;br&gt;新状态的item是两个旧状态的item的并（其实就是把每个item的lookahead symbol合并一下）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/compiler-construction-principles/lr1-lalr1.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;这样得到的表将会小很多：与SLR的分析表&lt;strong&gt;一样大&lt;/strong&gt;！通常状态数只有LR(1)的十分之一。付出的微小代价：规约-规约冲突(reduce-reduce conflict)&lt;br&gt;例如对于如下文法：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;S -&amp;gt; a E c&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   | a F d&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   | b F c&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   | b E d&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;E -&amp;gt; e&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;F -&amp;gt; e&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在LALR分析表中有两个状态会被合并成一个。而之后的下个字符将会出现歧义。这个冲突对应的状态：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;E -&amp;gt; e, &amp;#123;c,d&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;F -&amp;gt; e, &amp;#123;c,d&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;LR(1)分析器：将产生两个不同的状态(图中的状态#6与#9)，不会产生冲突：&lt;img src=&#34;/compiler-construction-principles/lr1-eg.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;LALR(1)分析器：只会产生一个状态，产生冲突&lt;ul&gt;
&lt;li&gt;若下个输入字符为c或d，可以归约成E或F&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，上述文法对于LALR(1)是二义的。&lt;br&gt;但这是可以接受的：LALR(1)足以处理绝大部分程序设计语言。&lt;/p&gt;
&lt;h2 id=&#34;Part-6-语法分析杂项&#34;&gt;&lt;a href=&#34;#Part-6-语法分析杂项&#34; class=&#34;headerlink&#34; title=&#34;Part 6: 语法分析杂项&#34;&gt;&lt;/a&gt;Part 6: 语法分析杂项&lt;/h2&gt;&lt;h3 id=&#34;语法分析器的生成器：YACC&#34;&gt;&lt;a href=&#34;#语法分析器的生成器：YACC&#34; class=&#34;headerlink&#34; title=&#34;语法分析器的生成器：YACC&#34;&gt;&lt;/a&gt;语法分析器的生成器：YACC&lt;/h3&gt;&lt;p&gt;Yacc &amp;#x3D; yet another compiler-compiler&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于LALR(1)&lt;/li&gt;
&lt;li&gt;BNF(Backus Naur Form)范式&lt;/li&gt;
&lt;li&gt;GNU版本名为&lt;em&gt;Bison&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;流程：&lt;ol&gt;
&lt;li&gt;Yacc源程序(*.y) &amp;gt;&amp;gt; Yacc Compiler &amp;gt;&amp;gt; C语言实现的LALR分析器(y.tab.c)&lt;/li&gt;
&lt;li&gt;y.tab.c &amp;gt;&amp;gt; C Compiler &amp;gt;&amp;gt; 分析器可执行文件(&lt;em&gt;.exe&amp;#x2F;&lt;/em&gt;.out)&lt;/li&gt;
&lt;li&gt;输入 &amp;gt;&amp;gt; 分析器可执行文件 &amp;gt;&amp;gt; 输出&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lex: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种词法分析器的生成器，将词法转化为词法解析器yylex()&lt;/li&gt;
&lt;li&gt;Yacc生成的yyparse()可以接受yylex()进而生成语法分析器&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;Yacc源程序结构&#34;&gt;&lt;a href=&#34;#Yacc源程序结构&#34; class=&#34;headerlink&#34; title=&#34;Yacc源程序结构&#34;&gt;&lt;/a&gt;Yacc源程序结构&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;声明&lt;ul&gt;
&lt;li&gt;C语言的声明&lt;/li&gt;
&lt;li&gt;词法单元的声明&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;翻译规则&lt;ul&gt;
&lt;li&gt;产生式&lt;/li&gt;
&lt;li&gt;产生式相关语义动作（例如编译时计算）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;辅助性C语言例程&lt;ul&gt;
&lt;li&gt;直接拷贝到生成的*.tab.c中&lt;/li&gt;
&lt;li&gt;可以在语义动作中调用&lt;/li&gt;
&lt;li&gt;Lex生成的yylex()就是其中之一，可以返回词法单元&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于示例文法：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;exp → exp addop term | term&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;addop → + | -&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;term → term mulop factor | factor&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;mulop → *&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;factor → ( exp ) | number&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;有示例程序：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;%&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;#include &amp;lt;ctype.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;int yylex(void);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;int yyerror (char * s);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;%&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;%token NUMBER&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;%%&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;command: exp &amp;#123;printf(&amp;quot;%d\n&amp;quot;, $1);&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;exp: exp &amp;#x27;+&amp;#x27; term &amp;#123;$$ = $1 + $3;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   | exp &amp;#x27;-&amp;#x27; term &amp;#123;$$ = $1 - $3;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   | term &amp;#123;$$ = $1&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;term: term &amp;#x27;*&amp;#x27; factor &amp;#123;$$ = $1 * $3;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    | factor &amp;#123;$$ = $1;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;factor: NUMBER &amp;#123;$$ = $1;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      | &amp;#x27;(&amp;#x27; exp &amp;#x27;)&amp;#x27; &amp;#123;$$ = $2;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中翻译规则Rule的格式为 &lt;code&gt;Rule &amp;#123;Action Code&amp;#125;&lt;/code&gt;，使用规则规约后Action Code就会被执行&lt;br&gt;语义动作形如 &lt;code&gt;$$ = $1 + $3&lt;/code&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$$&lt;/code&gt; 表示和产生式头(LHS)相关的属性值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$i&lt;/code&gt; 表示产生式体中第i个文法符号（终结符&amp;#x2F;非终结符）的属性值&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;消除二义性与冲突解决&#34;&gt;&lt;a href=&#34;#消除二义性与冲突解决&#34; class=&#34;headerlink&#34; title=&#34;消除二义性与冲突解决&#34;&gt;&lt;/a&gt;消除二义性与冲突解决&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;消除二义性：&lt;ul&gt;
&lt;li&gt;指定运算符优先级：先出现的优先&lt;/li&gt;
&lt;li&gt;指定运算符结合律：&lt;code&gt;%left&lt;/code&gt;（左结合，例如乘法加法） &lt;code&gt;%right&lt;/code&gt;（右结合，例如一元运算符负号）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;冲突解决&lt;ul&gt;
&lt;li&gt;规约-规约冲突：先出现的产生式优先采用&lt;/li&gt;
&lt;li&gt;移进-规约冲突：移进优先采用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更通用的办法：通过改写文法，可以在消除冲突的同时减少二义性&lt;/p&gt;
&lt;h3 id=&#34;错误恢复-1&#34;&gt;&lt;a href=&#34;#错误恢复-1&#34; class=&#34;headerlink&#34; title=&#34;错误恢复&#34;&gt;&lt;/a&gt;错误恢复&lt;/h3&gt;&lt;p&gt;动机：一次性报告所有错误，而非遇到第一个就停下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;局部错误恢复：调整Parse过程的栈，使其恢复到正常从而继续进行Parsing&lt;/li&gt;
&lt;li&gt;全局错误恢复：删除&amp;#x2F;插入尽可能少的字符，使得源字符串成为合法的字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;局部错误恢复&#34;&gt;&lt;a href=&#34;#局部错误恢复&#34; class=&#34;headerlink&#34; title=&#34;局部错误恢复&#34;&gt;&lt;/a&gt;局部错误恢复&lt;/h4&gt;&lt;p&gt;Yacc中的一个方法：使用特殊的&lt;code&gt;error&lt;/code&gt;符号（终结符）控制恢复过程。&lt;br&gt;例如：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;exp -&amp;gt; ( error )&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;exp -&amp;gt; error ; exp&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;于是通过这样的产生式，我们可以把错误的影响范围控制在右括号处&amp;#x2F;分号处。如果语法处理时遇到错误，可以一路跳过直到右括号和分号，然后继续处理。&lt;br&gt;分号、右括号这样的符号就被叫做synchronizing token.&lt;/p&gt;
&lt;p&gt;当语法分析器遇到错误时&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不断弹出栈中状态，直到栈顶状态包含项 $ A \rightarrow \bullet error\ \alpha$&lt;/li&gt;
&lt;li&gt;分析器将error移入栈中&lt;/li&gt;
&lt;li&gt;如果α为空，分析器直接执行归约，并调用相关的语义&lt;br&gt;动作；否则跳过一些符号，找到可以归约为α的串为止&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;流程示例：&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/local-recovery.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;全局错误恢复&#34;&gt;&lt;a href=&#34;#全局错误恢复&#34; class=&#34;headerlink&#34; title=&#34;全局错误恢复&#34;&gt;&lt;/a&gt;全局错误恢复&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;不要求掌握。&lt;/strong&gt;&lt;br&gt;Burke-Fisher 错误恢复: 对于在发生错误处之前的K个token，每一处都允许插入&amp;#x2F;删除&amp;#x2F;修改一个token，直到修复成功。&lt;br&gt;优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不引入新产生式，不改变文法&lt;/li&gt;
&lt;li&gt;也不改变分析表&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何判定修复是否成功：修复后，在报告错误处继续Parsing直到下一个错误发生的距离最长（一般来说，修复后能从本来由于错误卡住的地方继续前进4个token就算成功了）。&lt;/p&gt;
&lt;p&gt;实现：维护K个token前的旧栈，以及K个token组成的队列。遇到错误后基于旧栈和增删改后的token队列（不一定是K个了）试图parse. 尝试不同的增删改方案直到修复成功：&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/burke-fisher.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;语义动作需要延迟到进入旧栈中（进入旧栈说明在解析流程中已经确定了）再进行&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;否则如果遇到错误，错误恢复发现原来的parsing方式不对时，文法符号的属性已经按照错误的方式运算了，回天乏术。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;语法分析小结：文法对比&#34;&gt;&lt;a href=&#34;#语法分析小结：文法对比&#34; class=&#34;headerlink&#34; title=&#34;语法分析小结：文法对比&#34;&gt;&lt;/a&gt;语法分析小结：文法对比&lt;/h2&gt;&lt;h3 id=&#34;SLR-与-LR-1&#34;&gt;&lt;a href=&#34;#SLR-与-LR-1&#34; class=&#34;headerlink&#34; title=&#34;SLR 与 LR(1)&#34;&gt;&lt;/a&gt;SLR 与 LR(1)&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;SLR&lt;/th&gt;
&lt;th&gt;LR(1)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;移   进&lt;/td&gt;
&lt;td&gt;$ A\rightarrow \alpha \bullet a \beta \in I_i \\ \text{Goto}(I_i,a)&amp;#x3D;I_j \\ \text{Action}[i,a]&amp;#x3D;s_j $&lt;/td&gt;
&lt;td&gt;$ A\rightarrow \alpha \bullet a \beta \in I_i \\ \text{Goto}(I_i,a)&amp;#x3D;I_j \\ \text{Action}[i,a]&amp;#x3D;s_j $&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;规   约&lt;/td&gt;
&lt;td&gt;$ A\rightarrow \alpha \bullet \in I_i \\ \alpha \in \text{Follow}(A) \\ \text{Action}[i,a]&amp;#x3D;r_j$&lt;/td&gt;
&lt;td&gt;$ A\rightarrow \alpha \bullet \in I_i \\ \text{Action}[i,a]&amp;#x3D;r_j $&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;可见唯一的区别就是SLR在规约时要求后继token是在Follow集里的。&lt;/p&gt;
&lt;h3 id=&#34;LL-1-与-LR-1&#34;&gt;&lt;a href=&#34;#LL-1-与-LR-1&#34; class=&#34;headerlink&#34; title=&#34;LL(1) 与 LR(1)&#34;&gt;&lt;/a&gt;LL(1) 与 LR(1)&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;LR(1)&lt;/th&gt;
&lt;th&gt;LL(1)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;建立分析树&lt;/td&gt;
&lt;td&gt;自底而上&lt;/td&gt;
&lt;td&gt;自顶而下&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;归约or推导&lt;/td&gt;
&lt;td&gt;规范归约(最右推导的逆)&lt;/td&gt;
&lt;td&gt;最左推导&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;分析表（行x列）&lt;/td&gt;
&lt;td&gt;状态×文法符号，大&lt;/td&gt;
&lt;td&gt;非终结符×终结符，小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;分析栈&lt;/td&gt;
&lt;td&gt;状态栈，信息更多&lt;/td&gt;
&lt;td&gt;文法符号栈&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;LL(1): 对于多个可选产生式 $A\rightarrow \alpha_1|\alpha_2|…$ 向前看下一个输入根据First,Follow确定使用哪条产生式推导&lt;/li&gt;
&lt;li&gt;LR(1): 对于多个可选产生式 $A\rightarrow \alpha,\ B\rightarrow \alpha,… $ 在识别出整个$\alpha$后，再往前看1个符号，然后确定使用哪条产生式归约&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;LL-1-LR-1-SLR&#34;&gt;&lt;a href=&#34;#LL-1-LR-1-SLR&#34; class=&#34;headerlink&#34; title=&#34;LL(1) LR(1) SLR&#34;&gt;&lt;/a&gt;LL(1) LR(1) SLR&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;/compiler-construction-principles/grammar-compare.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;Part-7-抽象语法&#34;&gt;&lt;a href=&#34;#Part-7-抽象语法&#34; class=&#34;headerlink&#34; title=&#34;Part 7: 抽象语法&#34;&gt;&lt;/a&gt;Part 7: 抽象语法&lt;/h2&gt;&lt;p&gt;编程语言 &amp;#x3D; 语法（识别一个合法的程序） + 语义（这个合法的程序对应的实际行为）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语法：已经在之前章节讨论过。&lt;/li&gt;
&lt;li&gt;语义：&lt;ul&gt;
&lt;li&gt;操作语义：如何执行程序？&lt;/li&gt;
&lt;li&gt;&lt;del&gt;公理语义：我们可以证明程序的那些性质？&lt;/del&gt;（该部分不在本课讨论）&lt;/li&gt;
&lt;li&gt;指称语义：程序是做什么的？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;属性文法Attribute-Grammar&#34;&gt;&lt;a href=&#34;#属性文法Attribute-Grammar&#34; class=&#34;headerlink&#34; title=&#34;属性文法Attribute Grammar&#34;&gt;&lt;/a&gt;属性文法Attribute Grammar&lt;/h3&gt;&lt;p&gt;属性文法&amp;#x3D;&lt;strong&gt;上下文无关文法+属性+属性计算规则&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;属性:&amp;#x3D; 描述文法符号的语义特征，比如表达式E的值我们可以记为E.val&lt;/li&gt;
&lt;li&gt;属性计算规则(语义规则):&amp;#x3D; 与产生式相关联、反映文法符号属性之间关系的规则，比如在乘法表达式中左侧的E.val要如何计算&lt;ul&gt;
&lt;li&gt;仅表明属性间“抽象”关系，不涉及计算次序等具体实现细节&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;应用：&lt;ul&gt;
&lt;li&gt;“推导类”：例如很多语言的&lt;strong&gt;编译期求值&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;“生成类”：生成AST， 中间代码等&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实现：例如在先前章节中Yacc等Parser生成器的&lt;strong&gt;语义动作&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;语义动作Semantic-Action&#34;&gt;&lt;a href=&#34;#语义动作Semantic-Action&#34; class=&#34;headerlink&#34; title=&#34;语义动作Semantic Action&#34;&gt;&lt;/a&gt;语义动作Semantic Action&lt;/h3&gt;&lt;p&gt;我们可以给产生式绑定一个语义动作，使得按照这个产生式规约时&amp;#x2F;推导时完成特定操作。&lt;/p&gt;
&lt;p&gt;每个token都可能有独属于自己的**语义值(Semantic Value)**。每种token的语义值类型可以不同，我们把A的语义值的类型称为“A的关联类型”。&lt;br&gt;例如对于产生式 $A\rightarrow B\ C\ D$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语义动作返回值必须是&lt;em&gt;A的关联类型&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;这个值可以通过B C D各自的语义值进行运算得出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如我们通过如下语义动作可以在编译期直接evaluate表达式的值：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;E-&amp;gt;E1 + T   &amp;#123; E.val= E1.val + T.val &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;E-&amp;gt;E1 – T   &amp;#123; E.val= E1.val - T.val &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;E-&amp;gt;T        &amp;#123; E.val= T.val &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;T-&amp;gt;(E)      &amp;#123; T.val= E.val &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;T-&amp;gt;num      &amp;#123; T.val= num.val &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在递归下降法中，语义动作体现为每个符号对应的parsing函数。这里我们同时关心函数的&lt;strong&gt;返回值&lt;/strong&gt;与&lt;strong&gt;副作用&lt;/strong&gt;。&lt;br&gt;因此假设T和F两个token的关联类型都是&lt;code&gt;int&lt;/code&gt;，对于表达式 $T\rightarrow T * F$ 我们可以如此实现语义动作：&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; a= T();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;eat(TIMES); &lt;span class=&#34;comment&#34;&gt;// &amp;#x27;*&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; b= F();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; a*b;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;而对于Parser生成器来说，其实现方式有所不同，以Yacc为例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用一个栈储存语义值，这个栈和状态栈是同步的&lt;/li&gt;
&lt;li&gt;当进行&lt;strong&gt;规约&lt;/strong&gt;操作时，需要执行相应的语义动作（C语言实现）&lt;ul&gt;
&lt;li&gt;可能用到的值一定可以通过多次pop语义值栈获得（和状态栈pop同步）&lt;/li&gt;
&lt;li&gt;pop完毕后运算得到的新值压入该栈（和状态栈压入新状态同步）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;抽象解析树Abstract-Parse-Tree&#34;&gt;&lt;a href=&#34;#抽象解析树Abstract-Parse-Tree&#34; class=&#34;headerlink&#34; title=&#34;抽象解析树Abstract Parse Tree&#34;&gt;&lt;/a&gt;抽象解析树Abstract Parse Tree&lt;/h3&gt;&lt;p&gt;语义动作的一种应用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;⚠和抽象语法树(Abstract Syntax Tree)的区别请参阅&lt;a href=&#34;https://stackoverflow.com/questions/5026517/whats-the-difference-between-parse-trees-and-abstract-syntax-trees-asts&#34;&gt;https://stackoverflow.com/questions/5026517/whats-the-difference-between-parse-trees-and-abstract-syntax-trees-asts&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;能否&lt;strong&gt;通过描述语义动作直接实现整个编译器&lt;/strong&gt;？可以，但是难以维护，且必须保证这些语义值的计算顺序和Parsing顺序完全一致。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;考虑分离语法解析（Parsing）和语义动作：一个可行方案是Parsing得到树，而后遍历以进行语义相关的操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们可以很容易得到一棵树：叶节点对应输入的token，内部节点对应一个语法规则。这被称为&lt;strong&gt;concrete parse tree&lt;/strong&gt;.&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/concrete-pt.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缺点：太“啰嗦”。例如括号相关产生式只是为了解析顺序正确才有的，没必要放进树里。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;抽象语法树Abstract-Syntax-Tree&#34;&gt;&lt;a href=&#34;#抽象语法树Abstract-Syntax-Tree&#34; class=&#34;headerlink&#34; title=&#34;抽象语法树Abstract Syntax Tree&#34;&gt;&lt;/a&gt;抽象语法树Abstract Syntax Tree&lt;/h3&gt;&lt;p&gt;可以提供一个&lt;em&gt;干净的&lt;/em&gt;（不包含Parsing的那些繁文缛节）接口用于后续编译流程的实现或优化（编译器后端）。&lt;br&gt;生成方式：用&lt;strong&gt;具体语法&lt;/strong&gt;（Parser生成器能懂的）为&lt;strong&gt;抽象语法&lt;/strong&gt;（我们想要的、更可读的）生成抽象语法树&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/AST.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为每一个非终结符定义一个类型声明，用于表示其关联类型&lt;/li&gt;
&lt;li&gt;产生式统一放进一个union（如果是Rust就是Option直接解决，&lt;del&gt;C语言太坏了&lt;/del&gt;）里，每一个产生式就是union里的一个结构体，这个结构体用于储存其子节点 &lt;img src=&#34;/compiler-construction-principles/AST-def.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;为每个产生式定义一个函数，除了计算需要的语义值返回以外，还将申请空间、分配新的树节点并设置好其子节点 &lt;img src=&#34;/compiler-construction-principles/AST-impl.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;以Yacc为例，把这些函数放入对应产生式的语义动作块中即可在规约时自动调用。随着Parsing的逐步推进，每次规约都可以产生一个新的内部节点，最终逐步构建出整颗AST&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外，通过遍历AST还能做很多：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过一些“变形”缩小树的规模，减少最终代码的大小&lt;/li&gt;
&lt;li&gt;通过一些“变形”优化树的结构，提高最终代码的性能&lt;/li&gt;
&lt;li&gt;代码内联优化&lt;/li&gt;
&lt;li&gt;静态分析，编译期推导值&lt;/li&gt;
&lt;li&gt;类型系统检查等安全检查&lt;/li&gt;
&lt;li&gt;翻译到中间表示，虽然&lt;strong&gt;AST也常被视作一种“中间表示”&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;位置Position&#34;&gt;&lt;a href=&#34;#位置Position&#34; class=&#34;headerlink&#34; title=&#34;位置Position&#34;&gt;&lt;/a&gt;位置Position&lt;/h3&gt;&lt;p&gt;在one-pass编译器中，词法分析、语法分析、语义分析是同步进行的。而错误发生时，&lt;strong&gt;词法分析器lexer&lt;/strong&gt;的位置可以用来作为错误发生位置的合理估计反馈给用户。所以，lexer存有一个全局变量维护当前位置信息。&lt;/p&gt;
&lt;p&gt;然而，对于使用AST的编译器，词法分析结束后才开始语法分析，因此这是不可行的。&lt;br&gt;解决方案：AST每个节点记录自己在源文件中的&lt;strong&gt;位置&lt;/strong&gt;，标记自己是具体哪几个字符派生而来的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lexer把每个token的起始位置、结束位置传递给parser&lt;/li&gt;
&lt;li&gt;parser维护&lt;em&gt;位置栈&lt;/em&gt;与&lt;em&gt;语义值栈&lt;/em&gt;，这样语义操作就知道位置信息了&lt;ul&gt;
&lt;li&gt;不是所有的Parser生成器都可以做到这一点：例如Bison可以但Yacc不行&lt;/li&gt;
&lt;li&gt;对于Yacc等无法直接实现的，可以引入新的非终结符pos（其语义值包含需要的位置信息）并改写文法。例如我们可以如此改写PLUS表达式以利用位置信息：&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;%&amp;#123; extern A_OpExp(A_exp, A_binop, A_exp, position); %&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;%union &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    int num;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    string id;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    position pos;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;%type &amp;lt;pos&amp;gt; pos&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;pos: &amp;#123; $$ = EM_tokpos; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;exp: exp PLUS pos exp &amp;#123; $$ = A_OpExp($1, A_plus, $4, $3); &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Part-8-语义分析&#34;&gt;&lt;a href=&#34;#Part-8-语义分析&#34; class=&#34;headerlink&#34; title=&#34;Part 8: 语义分析&#34;&gt;&lt;/a&gt;Part 8: 语义分析&lt;/h2&gt;&lt;p&gt;我们注意到上述的属性文法等内容只适用于上下文无关文法CFG.&lt;br&gt;然而CFG有很多不足，例如我们不可能完成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;检查数组引用的维度是否匹配&lt;/li&gt;
&lt;li&gt;检查数组越界&lt;/li&gt;
&lt;li&gt;确定变量应储存于栈上还是堆上&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是因为，这些检查和值有关（涉及语义），而非语法本身。因此我们需要通过检查、遍历&lt;strong&gt;程序表示(Program Representation)&lt;strong&gt;来完成&lt;/strong&gt;（广义的）语义分析&lt;/strong&gt;。&lt;br&gt;常用的程序表示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;abstract syntax tree (AST)&lt;/li&gt;
&lt;li&gt;control flow graph (CFG)&lt;/li&gt;
&lt;li&gt;programdependence graph (PDG)&lt;/li&gt;
&lt;li&gt;valueflowgraph (VFG)&lt;/li&gt;
&lt;li&gt;single static assignment (SSA)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后我们就可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类型检查&lt;/li&gt;
&lt;li&gt;代码生成&lt;/li&gt;
&lt;li&gt;去除dead code&lt;/li&gt;
&lt;li&gt;寄存器分配&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在本课中，我们重点关注的（狭义的）语义分析指的是通过检查AST获知程序的静态属性，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作用域(Scope)与变量可见性&lt;/li&gt;
&lt;li&gt;变量、函数、表达式的类型&lt;br&gt;以及将AST转为中间代码(Intermediate Code)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;符号表Symbol-Table&#34;&gt;&lt;a href=&#34;#符号表Symbol-Table&#34; class=&#34;headerlink&#34; title=&#34;符号表Symbol Table&#34;&gt;&lt;/a&gt;符号表Symbol Table&lt;/h3&gt;&lt;p&gt;Binding:&amp;#x3D; 把类型、值等信息绑定到一个identifier上&lt;br&gt;Environment:&amp;#x3D; 一些绑定的集合，体现了程序当前环境下已声明的一些变量&amp;#x2F;函数&amp;#x2F;…&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;符号表&lt;/strong&gt;就是Environment的一种实现方式。我们在遍历AST的过程中可以维护一个符号表用于语义分析。&lt;br&gt;符号表中的重要组成部分就是各个局部变量及其作用域。当退出作用域时，自然就需要丢弃内部的一些binding.&lt;br&gt;变量在scope内重新定义时需要覆盖（屏蔽）掉更大作用域的，退出时则还原。&lt;br&gt;因此可见我们需要为符号表实现的接口包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;insert: 将名称绑定到相关信息(type, value, …), 且将覆盖已有的绑定关系（如果存在）&lt;/li&gt;
&lt;li&gt;lookup: 用名称查找信息&lt;/li&gt;
&lt;li&gt;beginScope: 进入作用域&lt;/li&gt;
&lt;li&gt;endScope: 退出作用域，将符号表恢复到进入之前的状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Java等语言中，可能有多个环境同时活跃（对应不同的module, class等），他们都需要一个符号表。这被称为多符号表。&lt;/p&gt;
&lt;h4 id=&#34;符号表的实现：Imperative-Style-Functional-Style&#34;&gt;&lt;a href=&#34;#符号表的实现：Imperative-Style-Functional-Style&#34; class=&#34;headerlink&#34; title=&#34;符号表的实现：Imperative Style &amp;amp; Functional Style&#34;&gt;&lt;/a&gt;符号表的实现：Imperative Style &amp;amp; Functional Style&lt;/h4&gt;&lt;p&gt;绑定时，如果遇到了符号已经存在的情况，我们有两种策略：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Imperative Style: 直接覆盖旧的绑定，这样我们不可能lookup到旧的信息。当这个新的绑定不再有效时，需要复原旧的绑定。&lt;ul&gt;
&lt;li&gt;如何快速lookup且支持删除和复原(restore): 使用哈希表套链表储存每对binding. 我们称哈希表中的元素为bucket&lt;/li&gt;
&lt;li&gt;insert: 直接插入对应bucket的链表头。如果已经存在，由于这使得新的binding关系更靠前，这样做可以成功覆盖&lt;/li&gt;
&lt;li&gt;restore: 对应bucket的链表头弹出头部的一些元素&lt;/li&gt;
&lt;li&gt;我们会发现需要维护一些必要的额外信息（比如scope变化时应该要弹出几次）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Functional Style: 永远保留老的，只是查询时做一些额外处理（可以理解为只是renaming）。这样还原更简单。&lt;ul&gt;
&lt;li&gt;直接使用BST（红黑树等）实现查找&lt;/li&gt;
&lt;li&gt;可以使用可持久化数据结构完成删除、复原等操作，进一步降低单次操作的空间复杂度，非常方便&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;两种方法均可使用。&lt;/p&gt;
&lt;h3 id=&#34;Tiger编译器符号相关的实现&#34;&gt;&lt;a href=&#34;#Tiger编译器符号相关的实现&#34; class=&#34;headerlink&#34; title=&#34;Tiger编译器符号相关的实现&#34;&gt;&lt;/a&gt;Tiger编译器符号相关的实现&lt;/h3&gt;&lt;p&gt;在哈希表中的链表进行lookup时，不断进行字符串比较是很耗时的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解决办法：使用新的数据结构将符号对象关联到一个整数上（哈希值）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Tiger编译器的environment是destructive-update的。也就是说，我们有两个函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;S_beginScope&lt;/code&gt;: 记下当前符号表的状态&lt;/li&gt;
&lt;li&gt;&lt;code&gt;S_endScope&lt;/code&gt;: 恢复到最近的、还未被恢复的&lt;code&gt;S_beginScope&lt;/code&gt;记下的状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们引入一个**辅助栈(Auxiliary stack)**来维护上文提到的必要的额外信息:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;符号入栈时，会将binding联动地插入对应bucket的链表头&lt;/li&gt;
&lt;li&gt;弹出栈顶符号时，对应bucket的链表头也会联动地被移除&lt;/li&gt;
&lt;li&gt;beginScope: 压入一个特殊标记到辅助栈中&lt;/li&gt;
&lt;li&gt;endScope: 一直弹出符号直到弹出了一个特殊标记&lt;ul&gt;
&lt;li&gt;我们可以由此标记推断：此次因为退出scope引发的restore操作可以就此结束&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;类型检查&#34;&gt;&lt;a href=&#34;#类型检查&#34; class=&#34;headerlink&#34; title=&#34;类型检查&#34;&gt;&lt;/a&gt;类型检查&lt;/h3&gt;&lt;h4 id=&#34;类型及其作用&#34;&gt;&lt;a href=&#34;#类型及其作用&#34; class=&#34;headerlink&#34; title=&#34;类型及其作用&#34;&gt;&lt;/a&gt;类型及其作用&lt;/h4&gt;&lt;p&gt;类型限定了变量的取值范围以及部分运算规则。&lt;br&gt;可以大致把编程语言分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类型化的(typed): C&amp;#x2F;C++ Java Go&lt;/li&gt;
&lt;li&gt;非类型化的(untyped): LISP JavaScript&lt;ul&gt;
&lt;li&gt;不是没有类型，而是类型可变&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作用：提高开发效率（高层抽象&amp;amp;指称语义），提高运行性能（指导编译优化），提高安全性（内存安全等）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事实上，我们可以理解为每引入一种类型就能&lt;strong&gt;完全&lt;/strong&gt;消除某一类特定错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;形式化的类型系统可用于数学领域，参见Coq以及&lt;a href=&#34;https://leanprover-community.github.io/&#34;&gt;LEAN&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;Tiger的类型系统&#34;&gt;&lt;a href=&#34;#Tiger的类型系统&#34; class=&#34;headerlink&#34; title=&#34;Tiger的类型系统&#34;&gt;&lt;/a&gt;Tiger的类型系统&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;原始类型(primitive type): &lt;code&gt;int&lt;/code&gt;和&lt;code&gt;string&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;构造类型(constructed type): &lt;code&gt;record&lt;/code&gt;（类似结构体） 和&lt;code&gt;array&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据不同的判别法，&lt;strong&gt;类型等价&lt;/strong&gt;这一关系分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Name equivalence (NE): 必须声明是同一个类型才是同一类型&lt;/li&gt;
&lt;li&gt;Structure equivalence (SE): “长得一样”（内部结构一样）就是同一类型&lt;br&gt;显然前者被广泛采用，Tiger语言也不例外。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Tiger存在两个独立的命名空间，不同命名空间的同名identifier不会互相遮蔽(hide)对方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Types&lt;/li&gt;
&lt;li&gt;Functions and variables&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;Tiger的类型检查&#34;&gt;&lt;a href=&#34;#Tiger的类型检查&#34; class=&#34;headerlink&#34; title=&#34;Tiger的类型检查&#34;&gt;&lt;/a&gt;Tiger的类型检查&lt;/h4&gt;&lt;p&gt;Tiger的语义分析需要两个环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Type&lt;/code&gt;: 把类型符号映射到其表示的具体类型对应的数据结构&lt;ul&gt;
&lt;li&gt;初始时包含primitive type对应的映射 int $\mapsto$ Ty_int, string $\mapsto$ Ty_string,&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Value&lt;/code&gt;: 把变量名映射到具体类型，把函数名映射到(参数类型, 返回值类型)（也就是函数签名）&lt;ul&gt;
&lt;li&gt;初始时包含Tiger中预定义的一些函数定义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;semant&lt;/code&gt;模块包含类型检查等语义分析相关操作。类型检查分为两部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Type-checking expressions&lt;ul&gt;
&lt;li&gt;&lt;code&gt;transExp&lt;/code&gt;可以在给定的两个环境下将输入的表达式标记上type（如果发现非法则报错）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Type-checking declarations&lt;ul&gt;
&lt;li&gt;在Tiger语言中声明只可能在&lt;code&gt;let&lt;/code&gt;语句中出现&lt;/li&gt;
&lt;li&gt;变量声明：如果提供了变量类型，则检查初始化表达式类型是否匹配；否则直接通过初始化表达式类型获得变量类型&lt;/li&gt;
&lt;li&gt;类型声明：&lt;strong&gt;递归地&lt;/strong&gt;获取类型别名对应的实际类型。&lt;ul&gt;
&lt;li&gt;Q: 如何处理递归声明 &lt;code&gt;type list = &amp;#123;first: int, rest: list&amp;#125;&lt;/code&gt;？A: 不使用one-pass而是two-pass: pass#1: 记录声明头部（左侧）放入环境；pass#2: 完成&lt;/li&gt;
&lt;li&gt;不允许类型的直接循环引用(&lt;code&gt;type a=b;type b=a&lt;/code&gt;)：必须通过record或array完成(&lt;code&gt;type a=b;type b=&amp;#123;i:a&amp;#125;&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;函数声明：检查形参、返回值与函数体&lt;ul&gt;
&lt;li&gt;Q: 如何处理递归声明？A: 不使用one-pass而是two-pass: pass#1: 记录函数声明（签名）放入环境；pass#2: 处理函数题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;以上所有内容为期中考覆盖范围&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;&amp;gt;&amp;gt;&amp;gt; To be continued…&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;Part-9-活动记录Activation-Record&#34;&gt;&lt;a href=&#34;#Part-9-活动记录Activation-Record&#34; class=&#34;headerlink&#34; title=&#34;Part 9: 活动记录Activation Record&#34;&gt;&lt;/a&gt;Part 9: 活动记录Activation Record&lt;/h2&gt; ]]></description>
        </item>
    </channel>
</rss>
