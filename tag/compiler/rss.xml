<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Cubic Y³ • Posts by &#34;compiler&#34; tag</title>
        <link>http://cubicy.icu</link>
        <description>Notes, CTF, DIY, thoughts and waifus.

I&#39;m CubicYYY, an undergraduate student majoring in Computer Science at Zhejiang University.
Learning: Electric guitar
❤❤❤ CTF, toy projects, anime
✖✖✖ Technological supremacy
Resume is [here](https://latexonline.cc/compile?git=https://github.com/cubicYYY/resume&amp;target=resume.tex&amp;command=xelatex).</description>
        <language>zh-CN</language>
        <pubDate>Sun, 14 Apr 2024 01:10:20 +0800</pubDate>
        <lastBuildDate>Sun, 14 Apr 2024 01:10:20 +0800</lastBuildDate>
        <category>Misc</category>
        <category>Write-Up</category>
        <category>出题</category>
        <category>CISCN</category>
        <category>web</category>
        <category>Hackergame</category>
        <category>SchoolBus</category>
        <category>Rust</category>
        <category>Lifetime</category>
        <category>Code</category>
        <category>Programming</category>
        <category>冰菓</category>
        <category>古籍研究社</category>
        <category>Treap</category>
        <category>BST</category>
        <category>Stack</category>
        <category>图论</category>
        <category>Kruskal</category>
        <category>Splay</category>
        <category>数链剖分</category>
        <category>持久化</category>
        <category>线段树</category>
        <category>树状数组</category>
        <category>LCA</category>
        <category>分块</category>
        <category>哈希</category>
        <category>Phar</category>
        <category>反序列化</category>
        <category>PHP</category>
        <category>Compiler</category>
        <category>Computer Science</category>
        <category>On Going</category>
        <category>NLP</category>
        <category>Fuzzing</category>
        <category>AFL</category>
        <category>Miscellaneous</category>
        <category>Math</category>
        <category>Translation</category>
        <category>Yoneda Lemma</category>
        <item>
            <guid isPermalink="true">http://cubicy.icu/compiler-construction-principles/</guid>
            <title>编译原理课程笔记</title>
            <link>http://cubicy.icu/compiler-construction-principles/</link>
            <category>Compiler</category>
            <category>Computer Science</category>
            <category>On Going</category>
            <pubDate>Sun, 14 Apr 2024 01:10:20 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;编译原理&#34;&gt;&lt;a href=&#34;#编译原理&#34; class=&#34;headerlink&#34; title=&#34;编译原理&#34;&gt;&lt;/a&gt;编译原理&lt;/h1&gt;&lt;h2 id=&#34;Part-0-课程信息&#34;&gt;&lt;a href=&#34;#Part-0-课程信息&#34; class=&#34;headerlink&#34; title=&#34;Part 0: 课程信息&#34;&gt;&lt;/a&gt;Part 0: 课程信息&lt;/h2&gt;&lt;p&gt;使用教材：&lt;em&gt;Modern Compiler Implementation in C&lt;/em&gt;, Andrew W. Appel （A.K.A 虎书）&lt;/p&gt;
&lt;p&gt;相关课程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://web.stanford.edu/class/cs143/&#34;&gt;Stanford课程主页&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/6035/sp21&#34;&gt;MIT课程主页&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://inst.eecs.berkeley.edu/~cs164/fa21/&#34;&gt;UCBerkeley课程主页&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分数构成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;课程作业(课后小型练习题) &amp;#x3D; 10%&lt;/li&gt;
&lt;li&gt;随堂测验&amp;#x3D; 10%&lt;/li&gt;
&lt;li&gt;期中考试&amp;#x3D; 15%&lt;/li&gt;
&lt;li&gt;综合性课程设计&amp;#x3D; 25%&lt;/li&gt;
&lt;li&gt;期末考试&amp;#x3D; 40% （斩杀线40&amp;#x2F;100）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前置知识：计算理论（笔记参考&lt;a href=&#34;https://note.tonycrane.cc/cs/tcs/toc/&#34;&gt;https://note.tonycrane.cc/cs/tcs/toc/&lt;/a&gt;）&lt;/p&gt;
&lt;h2 id=&#34;Part-1-简介&#34;&gt;&lt;a href=&#34;#Part-1-简介&#34; class=&#34;headerlink&#34; title=&#34;Part 1: 简介&#34;&gt;&lt;/a&gt;Part 1: 简介&lt;/h2&gt;&lt;p&gt;基本概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中间代码&amp;#x3D;Intermediate Code&lt;/li&gt;
&lt;li&gt;词法分析&amp;#x3D;Lexing&amp;#x2F;Scanning&amp;#x2F;LexicalAnalysis&lt;/li&gt;
&lt;li&gt;语法分析&amp;#x3D;Parsing&amp;#x2F;SyntaxAnalysis&lt;/li&gt;
&lt;li&gt;中间表示&amp;#x3D;IR&amp;#x3D;Intermediate Representation&lt;/li&gt;
&lt;li&gt;树型中间表示&amp;#x3D;IR Tree&lt;/li&gt;
&lt;li&gt;前端&amp;#x3D;，后端&amp;#x3D;&lt;br&gt;略。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Part-2-词法分析&#34;&gt;&lt;a href=&#34;#Part-2-词法分析&#34; class=&#34;headerlink&#34; title=&#34;Part 2: 词法分析&#34;&gt;&lt;/a&gt;Part 2: 词法分析&lt;/h2&gt;&lt;h3 id=&#34;词法分析概述&#34;&gt;&lt;a href=&#34;#词法分析概述&#34; class=&#34;headerlink&#34; title=&#34;词法分析概述&#34;&gt;&lt;/a&gt;词法分析概述&lt;/h3&gt;&lt;p&gt;将输入字符串识别为有意义的子串。（把基本单元划分好）&lt;br&gt;(Token单词, Lexeme词素(可选)) e.g. (IF, ) (ELSE, ) (BINARY_OP, &amp;gt;&amp;#x3D;) (UNARY_OP, &amp;amp;)&lt;/p&gt;
&lt;h3 id=&#34;正则表达式&#34;&gt;&lt;a href=&#34;#正则表达式&#34; class=&#34;headerlink&#34; title=&#34;正则表达式&#34;&gt;&lt;/a&gt;正则表达式&lt;/h3&gt;&lt;p&gt;Regex Expression &amp;#x3D; RE&lt;br&gt;运算：连接concatenation + 幂Power&lt;br&gt;e.g.: $ ab(a|b)^3c^* $&lt;br&gt;下略。&lt;/p&gt;
&lt;h3 id=&#34;有穷自动机&#34;&gt;&lt;a href=&#34;#有穷自动机&#34; class=&#34;headerlink&#34; title=&#34;有穷自动机&#34;&gt;&lt;/a&gt;有穷自动机&lt;/h3&gt;&lt;p&gt;相关概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;NFA&amp;#x2F;DFA：略&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;子集构造法subsetconstruction(NFA-&amp;gt;DFA)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DFA的每个状态是NFA的状态集合的一个子集&lt;/li&gt;
&lt;li&gt;读了输入ai后NFA能到达的所有状态：s1,s2,…,sk，则DFA到达一个状态，对应于NFA的{s1,s2,…,sk}&lt;/li&gt;
&lt;li&gt;NFA状态(集)上的一些操作定义&lt;ul&gt;
&lt;li&gt;ε-closure(s):&amp;#x3D; NFA状态s的ε-闭包&amp;#x3D;s经ε转换所能到达的状态集合&lt;/li&gt;
&lt;li&gt;ε-closure(T):&amp;#x3D; T中所有状态的ε-闭包的并集,即 $ \cup_{s\in T}{\epsilon-closure(s)} $&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;过程&lt;ol&gt;
&lt;li&gt;NFA的初始状态S的ε-闭包对应于DFA的初始状态&lt;/li&gt;
&lt;li&gt;针对每个DFA状态(对应NFA状态子集A)，求输入每个可能输入ai后能到达的NFA状态的ε-闭包并集（NFA从状态集A出发，读入ai后能到达的状态集合） $$ S&amp;#x3D;\epsilon-closure(move(A,a_i)) $$&lt;/li&gt;
&lt;li&gt;该集合S要么对应于DFA中的一个已有状态，要么令其成为一个新加的DFA状态&lt;/li&gt;
&lt;li&gt;重复上述两步，逐步构造DFA的状态转换表（每个状态集合S与每个输入ai），直到不动点（不再新增状态，且状态转移表完全求出，即对任一状态集合S已知分别接受所有输入ai将分别转移到何状态）&lt;/li&gt;
&lt;li&gt;在DFA中，只要状态集合S包含至少一个原来NFA中的终止状态，就把S标记为终止状态&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;示例（TODO）&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;/compiler-construction-principles/nfa2dfa.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Thumpson构造法(RE-&amp;gt;NFA)：略&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;词法分析器自动生成&#34;&gt;&lt;a href=&#34;#词法分析器自动生成&#34; class=&#34;headerlink&#34; title=&#34;词法分析器自动生成&#34;&gt;&lt;/a&gt;词法分析器自动生成&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;DFA最小化（-&amp;gt;状态最小的DFA，在同构意义下唯一）&lt;/li&gt;
&lt;li&gt;可区分状态：存在串s使其分别从状态s、t出发，一个接受串s，一个拒绝串s，则s与t可区分&lt;/li&gt;
&lt;li&gt;步骤：&lt;ol&gt;
&lt;li&gt;初始等价类，仅由接受状态集合和非接受状态两个集合构成&lt;/li&gt;
&lt;li&gt;用所有可能的输入ai应用于各个集合（走一步）&lt;ul&gt;
&lt;li&gt;只有集合G的每个状态读入同一字符后，都落入（包含在）相同的某个集合，该集合G在这一步才不用细分&lt;/li&gt;
&lt;li&gt;否则集合G要被细分：落入不同集合的对应状态需要被分割进不同集合&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不断重复2直到不动点（任一集合分别对所有输入ai都不可细分）&lt;/li&gt;
&lt;li&gt;此时等价类中的每个集合即对应最小DFA的一个状态。在其上可以轻松构建min-DFA，该过程是trivial的（可以每个组中选择一个状态作代表）。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;示例（TODO）&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;/compiler-construction-principles/DFA-simplify-diverge.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;/compiler-construction-principles/DFA-simplify.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;Lex工具&#34;&gt;&lt;a href=&#34;#Lex工具&#34; class=&#34;headerlink&#34; title=&#34;Lex工具&#34;&gt;&lt;/a&gt;Lex工具&lt;/h3&gt;&lt;p&gt;通常和Yacc一起使用，生成编译器的前端。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;声明部分&lt;ul&gt;
&lt;li&gt;常量：常数标识符&lt;/li&gt;
&lt;li&gt;正则规则定义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;转换规则模式{动作}&lt;ul&gt;
&lt;li&gt;模式&amp;#x3D;正则表达式&lt;/li&gt;
&lt;li&gt;动作&amp;#x3D;识别到相应模式时应调用的处理函数（一般以C语言代码表示）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;辅助函数：动作中使用的函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解决冲突：最长匹配，较前规则优先&lt;/p&gt;
&lt;h2 id=&#34;Part-3-语法分析-CFG-amp-Parsing&#34;&gt;&lt;a href=&#34;#Part-3-语法分析-CFG-amp-Parsing&#34; class=&#34;headerlink&#34; title=&#34;Part 3: 语法分析 - CFG &amp;amp; Parsing&#34;&gt;&lt;/a&gt;Part 3: 语法分析 - CFG &amp;amp; Parsing&lt;/h2&gt;&lt;h3 id=&#34;语法分析器概述&#34;&gt;&lt;a href=&#34;#语法分析器概述&#34; class=&#34;headerlink&#34; title=&#34;语法分析器概述&#34;&gt;&lt;/a&gt;语法分析器概述&lt;/h3&gt;&lt;p&gt;从词法分析器获得Token序列，确认该序列是否可以由语言的文法生成&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于语法错误的程序，报告错误信息&lt;/li&gt;
&lt;li&gt;对于语法正确的程序，生成语法分析树(简称语法树) e.g. 抽象语法树AST&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现：手动 or 自动(使用Parse generator&amp;#x3D;{Yacc, Bison, ANTLR, mehir…})&lt;/p&gt;
&lt;h3 id=&#34;上下文无关文法CFG-x3D-Context-Free-Language&#34;&gt;&lt;a href=&#34;#上下文无关文法CFG-x3D-Context-Free-Language&#34; class=&#34;headerlink&#34; title=&#34;上下文无关文法CFG&amp;#x3D;Context Free Language&#34;&gt;&lt;/a&gt;上下文无关文法CFG&amp;#x3D;Context Free Language&lt;/h3&gt;&lt;p&gt;$$ G&amp;#x3D;(T,N,P,S) $$&lt;br&gt;T：终结符集合(Terminals)&lt;br&gt;N：非终结符集合(Non-terminals)&lt;br&gt;P：产生式集合(Productions) $ A\rightarrow a, A \in N, a \in (T \cup N)^*$&lt;br&gt;S：开始符号(Startsymbol): $ S \in N $&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;📕“上下文无关”体现在：产生式左侧只有一个非终结符，因此类似 $xAy\rightarrow xay$这样，需要关心符号前后别的符号是什么才能应用的产生式是不能在CFG里的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;特殊符号：$ &amp;#x3D;end of file(EOF)&lt;br&gt;添加一个新符号S’与一条新规则以表明必须在尾部：&lt;ul&gt;
&lt;li&gt;$ S’ \rightarrow S$ $&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;产生式缩写：左侧一样的产生式可以把右侧使用”|”合并。例如 $E\rightarrow E+E|(E)|id$&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;推导Derivation和规约Reduction&#34;&gt;&lt;a href=&#34;#推导Derivation和规约Reduction&#34; class=&#34;headerlink&#34; title=&#34;推导Derivation和规约Reduction&#34;&gt;&lt;/a&gt;推导Derivation和规约Reduction&lt;/h3&gt;&lt;p&gt;例如有产生式 $A\rightarrow \gamma$，我们可以有 $\alpha A \beta \Rightarrow \alpha \gamma \beta$&lt;br&gt;那么我们说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\alpha A \beta $ &lt;strong&gt;直接推导&lt;/strong&gt;到 $ \alpha \gamma \beta$&lt;/li&gt;
&lt;li&gt;$\alpha \gamma \beta $ &lt;strong&gt;直接规约&lt;/strong&gt;到 $  \alpha A \beta$&lt;br&gt;不言而喻的&lt;strong&gt;多步推导记号&lt;/strong&gt;：$\Rightarrow^5$ $\Rightarrow^+$ $\Rightarrow^*$&lt;br&gt;分别代表五步推导，至少一步推导，0次或更多次推导&lt;/li&gt;
&lt;li&gt;推导&amp;#x3D;从文法生成语言里的句子，规约&amp;#x3D;识别句子成分并逐渐规约到开始符号&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;最左推导Left-most-Derivation&#34;&gt;&lt;a href=&#34;#最左推导Left-most-Derivation&#34; class=&#34;headerlink&#34; title=&#34;最左推导Left-most Derivation&#34;&gt;&lt;/a&gt;最左推导Left-most Derivation&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;最左推导&amp;#x3D;每步代换最左边的非终结符。逆过程为最右规约&lt;/li&gt;
&lt;li&gt;类比可得出最右推导、最左规约的定义&lt;/li&gt;
&lt;li&gt;在自顶向下的分析中，总是采用&lt;strong&gt;最左推导&lt;/strong&gt;；在自底向上的分析中，总是采用&lt;strong&gt;最左归约&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/compiler-construction-principles/lmrm.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;句型-Sentential-form-句子-Sentence-语言-Language&#34;&gt;&lt;a href=&#34;#句型-Sentential-form-句子-Sentence-语言-Language&#34; class=&#34;headerlink&#34; title=&#34;句型(Sentential form) 句子(Sentence) 语言(Language)&#34;&gt;&lt;/a&gt;句型(Sentential form) 句子(Sentence) 语言(Language)&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;句型 &amp;#x3D; 文法G下可能推导出的一个符号序列：可能包含终结符&amp;#x2F;非终结符，可为空&lt;/li&gt;
&lt;li&gt;句子 &amp;#x3D; 不含非终结符的句型（仅含终结符）&lt;/li&gt;
&lt;li&gt;语言 &amp;#x3D; 文法G可产生的所有句子的集合&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;正则文法-RE-与-上下文无关文法-CFG&#34;&gt;&lt;a href=&#34;#正则文法-RE-与-上下文无关文法-CFG&#34; class=&#34;headerlink&#34; title=&#34;正则文法(RE) 与 上下文无关文法(CFG)&#34;&gt;&lt;/a&gt;正则文法(RE) 与 上下文无关文法(CFG)&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;上下文无关语言L(G) :&amp;#x3D; CFG产生的所有句子的集合&lt;/li&gt;
&lt;li&gt;正则语言L(r) :&amp;#x3D; RE产生的所有句子的集合&lt;ul&gt;
&lt;li&gt;RE &amp;#x3D; Regex Expression &amp;#x3D; 正则表达式&lt;/li&gt;
&lt;li&gt;正则表达式r定义正则语言L(r)&lt;/li&gt;
&lt;li&gt;$ L(r) \in L(G) $：因为正则对产生式限制更大，必须为( $A,B \in N, a \in T\cup {\epsilon} $ )：&lt;ul&gt;
&lt;li&gt;左线性文法：形如 $A\rightarrow aB$ 或 $A\rightarrow a$&lt;/li&gt;
&lt;li&gt;右线性文法：形如 $A\rightarrow Ba$ 或 $A\rightarrow a$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;正则语言可用于词法分析，上下文无关语言可用于语法分析（语言描述能力、复杂性决定的）&lt;/li&gt;
&lt;li&gt;Chomsky（计算理论课程内容）: &lt;ul&gt;
&lt;li&gt;0型文法&amp;#x3D;短语结构文法 递归可枚举&lt;/li&gt;
&lt;li&gt;1型文法&amp;#x3D;上下文有关文法&lt;/li&gt;
&lt;li&gt;2型文法&amp;#x3D;CFG&lt;/li&gt;
&lt;li&gt;3型文法&amp;#x3D;RE&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;CFG的分析树Parse-Tree&#34;&gt;&lt;a href=&#34;#CFG的分析树Parse-Tree&#34; class=&#34;headerlink&#34; title=&#34;CFG的分析树Parse Tree&#34;&gt;&lt;/a&gt;CFG的分析树Parse Tree&lt;/h3&gt;&lt;p&gt;分析树性质&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根节点&amp;#x3D;文法初始符号&lt;/li&gt;
&lt;li&gt;叶节点&amp;#x3D;终结符&lt;/li&gt;
&lt;li&gt;内部节点&amp;#x3D;非终结符&lt;/li&gt;
&lt;li&gt;父节点→{叶节点}&amp;#x3D;产生式&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;语法分析-Parsing-中的挑战&#34;&gt;&lt;a href=&#34;#语法分析-Parsing-中的挑战&#34; class=&#34;headerlink&#34; title=&#34;语法分析(Parsing)中的挑战&#34;&gt;&lt;/a&gt;语法分析(Parsing)中的挑战&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;核心目标：对于终结符号串x，要么从S推导出x，要么设法将x规约到S&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自顶向下(Top-down) S-&amp;gt;x, 从&lt;strong&gt;根节点&lt;/strong&gt;开始构造Parse Tree&lt;/li&gt;
&lt;li&gt;自底向上(Bottom-up) x-&amp;gt;S, 从&lt;strong&gt;叶节点&lt;/strong&gt;开始构造Parse Tree&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作为搜索问题：搜索空间大-&amp;gt;空间大小受文法产生式限制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无限制：时间复杂度 $O(n^3)$&lt;/li&gt;
&lt;li&gt;上下文无关语言CFL 的子集需要的典型时间为 $O(n)$，例如&lt;ul&gt;
&lt;li&gt;Predictive parsing using LL(1) grammars&lt;/li&gt;
&lt;li&gt;Shift-Reduce parsing using LR(1) grammars&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;编程语言的文法设计&#34;&gt;&lt;a href=&#34;#编程语言的文法设计&#34; class=&#34;headerlink&#34; title=&#34;编程语言的文法设计&#34;&gt;&lt;/a&gt;编程语言的文法设计&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;核心：无二义性&lt;/strong&gt;&lt;br&gt;二义性来源：某些句子存在不止一棵分析树&amp;#x3D;有两个不同的最左推导&amp;#x3D;&lt;strong&gt;多种可选推导处于文法同一层&lt;/strong&gt;&lt;br&gt;例如：$$E \Rightarrow E&lt;em&gt;E \Rightarrow id&lt;/em&gt;E \Rightarrow id&lt;em&gt;E+E$$ 与 $$E \Rightarrow E+E \Rightarrow E&lt;/em&gt;E+E \Rightarrow id&lt;em&gt;E+E $$&lt;br&gt;对于”3*4+5”，前者给出3*(4+5)&amp;#x3D;27（错误），后者给出3&lt;/em&gt;4+5&amp;#x3D;17（正确）。&lt;/p&gt;
&lt;p&gt;解决办法：确保只有一种最左推导&amp;#x3D;将同一层文法分层&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;规定符号优先级（”*“” &amp;gt; “+”,”-“）&lt;ul&gt;
&lt;li&gt;越接近开始符号S的文法符号优先级越低&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;规定符号结合性（左结合&amp;#x2F;右结合）&lt;ul&gt;
&lt;li&gt;递归非终结符在终结符左边，运算就左结合&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;/compiler-construction-principles/priority.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;判定CFG二义性：不可判定问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;但可以通过给定充分条件（无二义文法）确保无二义性&lt;ul&gt;
&lt;li&gt;自顶向下：LL(1)&lt;/li&gt;
&lt;li&gt;自底向上：LR(1), LALR(1)&lt;br&gt;&lt;img src=&#34;/compiler-construction-principles/grammars.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Part-4-语法分析-自顶向下&#34;&gt;&lt;a href=&#34;#Part-4-语法分析-自顶向下&#34; class=&#34;headerlink&#34; title=&#34;Part 4: 语法分析 - 自顶向下&#34;&gt;&lt;/a&gt;Part 4: 语法分析 - 自顶向下&lt;/h2&gt;&lt;p&gt;自顶向下每一步的推导都需要做出&lt;strong&gt;两个选择&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;替换哪个非终结符？&lt;/li&gt;
&lt;li&gt;应用哪个（左侧为该终结符的）产生式替换？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通用形式：&lt;strong&gt;递归下降分析(Recursive-Descent Parsing)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发生错误（没有产生式可以产生合法的子节点）就回溯&lt;/li&gt;
&lt;li&gt;问题：太慢！&lt;/li&gt;
&lt;li&gt;该过程类似NFA，能否构造类似DFA的分析方法？&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;LL-1-和预测分析法-Predictive-parsing&#34;&gt;&lt;a href=&#34;#LL-1-和预测分析法-Predictive-parsing&#34; class=&#34;headerlink&#34; title=&#34;LL(1)和预测分析法(Predictive parsing)&#34;&gt;&lt;/a&gt;LL(1)和预测分析法(Predictive parsing)&lt;/h3&gt;&lt;p&gt;预测分析法：接受LL(k)文法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个L: “left to right” 从左到右扫描&lt;/li&gt;
&lt;li&gt;第二个L: “left-most derivation” 最左推导&lt;/li&gt;
&lt;li&gt;k: 向前看k个token确定推导选用的产生式（一般k&amp;#x3D;1）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来需要添加约束使其无需回溯。我们先引入几个概念：&lt;/p&gt;
&lt;h4 id=&#34;First集和Follow集&#34;&gt;&lt;a href=&#34;#First集和Follow集&#34; class=&#34;headerlink&#34; title=&#34;First集和Follow集&#34;&gt;&lt;/a&gt;First集和Follow集&lt;/h4&gt;&lt;p&gt;给定 $ G&amp;#x3D;(T,N,P,S),\alpha \in (T\cup N)^* $&lt;br&gt;&lt;strong&gt;记空串为$\epsilon$&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;First集：可从$\alpha$推导得到的串的首个终结符的集合（也就是说，$\alpha$自己推导出的第一个终结符可能是什么）&lt;br&gt;$$ \text{First}(\alpha)&amp;#x3D;{a| \alpha \Rightarrow^*a…\ ,a\in T} $$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Follow集：从S出发，可能在推导过程中跟在A右边的终结符号集&lt;br&gt;$$ \text{Follow}(A)&amp;#x3D;{a|S\Rightarrow^*…Aa…\ ,a\in T} $$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如:S→αAaβ，终结符号 $ a\in \text{Follow}(A) $&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们至此可以使用两个条件保证产生式的选择是唯一的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$ \text{First}(\alpha)\cap \text{First}(\beta)&amp;#x3D; \emptyset $ （α和β推导不出以同一个单词为首的串）&lt;ul&gt;
&lt;li&gt;意义：显然的。这样看终结符是哪个就知道应该用哪个产生式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;若$\beta \Rightarrow^* \epsilon$，那么$\alpha \nRightarrow^* \epsilon$，且 $ \text{First}(\alpha) \cap Follow(A) &amp;#x3D; \emptyset $ （α和β不能同时推出$\epsilon$;First(α)不应在Follow(A) 中）&lt;ul&gt;
&lt;li&gt;意义：其实就是考虑如果有空串时，最后终结符因为空串没了则转而考虑Follow集以实现再向后看一个的效果。假设下一个输入是b,且$\beta \Rightarrow^* \epsilon$&lt;ul&gt;
&lt;li&gt;如果b∈First(α)，则选择A → α(属于上面1的情况)&lt;/li&gt;
&lt;li&gt;如果b∈Follow(A)，则选择A → β ,因为A最终到达了$\epsilon$，而后面紧跟着b&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下来我们会看到具体的实现方式以实现LL(1)预测分析。三步走：计算First,Follow-&amp;gt;构造预测分析表-&amp;gt;预测分析&lt;/p&gt;
&lt;h4 id=&#34;第一步：计算First-Follow&#34;&gt;&lt;a href=&#34;#第一步：计算First-Follow&#34; class=&#34;headerlink&#34; title=&#34;第一步：计算First, Follow&#34;&gt;&lt;/a&gt;第一步：计算First, Follow&lt;/h4&gt;&lt;h5 id=&#34;Nullable集&#34;&gt;&lt;a href=&#34;#Nullable集&#34; class=&#34;headerlink&#34; title=&#34;Nullable集&#34;&gt;&lt;/a&gt;Nullable集&lt;/h5&gt;&lt;p&gt;由于刚刚提到了空串，我们需要引入一个简单的新定义：Nullable集&amp;#x3D;{可推导出空串的符号}。&lt;br&gt;定义是递归的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Base Case: 如果有产生式 $ X\rightarrow \epsilon$, 那么X当然是Nullable的&lt;/li&gt;
&lt;li&gt;Inductive Case: 如果有产生式 $ X\rightarrow Y_1 Y_2 Y_3 … Y_n$, 且 $Y_1,Y_2,Y_3,…,Y_n$&lt;strong&gt;每个都能&lt;/strong&gt;推导出空串，则X是Nullable的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于每个产生式，我们可以循环用它们不断更新Nullable集直到不动点。这同样适用于First集与Follow集。&lt;/p&gt;
&lt;p&gt;First集：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Base Case: 如果X是终结符terminal: First(X)&amp;#x3D;{X}&lt;/li&gt;
&lt;li&gt;Inductive Case: 如果有产生式 $ X\rightarrow Y_1 Y_2 Y_3 … Y_n$&lt;ul&gt;
&lt;li&gt;$\text{First}(X) \cup &amp;#x3D; \text{First}(Y_1)$ ($ a\cup &amp;#x3D; b$意为$ a \leftarrow a\cup b$)&lt;/li&gt;
&lt;li&gt;如果$Y_1 \in \text{Nullable}: $$\text{First}(X) \cup &amp;#x3D; \text{First}(Y_1)$&lt;/li&gt;
&lt;li&gt;如果$Y_1,Y_2 \in \text{Nullable}: $$\text{First}(X) \cup &amp;#x3D; \text{First}(Y_2)$&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;li&gt;直到某个$Y_i \notin \text{Nullable}$则停止&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于每个产生式，我们可以循环用它们不断更新First集直到不动点。&lt;/p&gt;
&lt;p&gt;Follow集：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Base Case: $ \text{Follow}(A)&amp;#x3D;\emptyset $&lt;/li&gt;
&lt;li&gt;Inductive Case: 如果有产生式 $ B\rightarrow s_1 A\ s_2 $&lt;ul&gt;
&lt;li&gt;$\text{Follow}(A) \cup &amp;#x3D; \text{First}(s_2)$&lt;/li&gt;
&lt;li&gt;如果$s_2 \in \text{Nullable}$, $\text{Follow}(A) \cup &amp;#x3D; \text{Follow}(B)$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于每个产生式，我们可以循环用它们不断更新Follow集直到不动点。&lt;/p&gt;
&lt;p&gt;Tips(不要求掌握):Tiger book algorithm 3.13指出他们可以同时计算，感兴趣可以看看。&lt;/p&gt;
&lt;h4 id=&#34;第二步：构造预测分析表&#34;&gt;&lt;a href=&#34;#第二步：构造预测分析表&#34; class=&#34;headerlink&#34; title=&#34;第二步：构造预测分析表&#34;&gt;&lt;/a&gt;第二步：构造预测分析表&lt;/h4&gt;&lt;p&gt;&lt;del&gt;打开网站即可&lt;a href=&#34;https://jsmachines.sourceforge.net/machines/ll1.html&#34;&gt;LL(1) Parser Generator&lt;/a&gt;&lt;/del&gt;&lt;br&gt;不过这个网站对于理解第三步中PDA相关过程很有帮助。&lt;/p&gt;
&lt;p&gt;回顾自顶向下推导的两个选择题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;替换当前句型中的哪个非终结符?&lt;ul&gt;
&lt;li&gt;“Left-most”一词说明：总是选择每个句型的最左非终结符进行替换&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用该非终结符的哪个产生式进行替换? &lt;ul&gt;
&lt;li&gt;构建二维表M, 通过当前非终结符和看到的终结符决定选取何种产生式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;M的构造：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每一行A对应一个非终结符&lt;/li&gt;
&lt;li&gt;每一列a对应某个终结符或输入结束符$&lt;/li&gt;
&lt;li&gt;表中的某一格M[A,a]表示：针对当前非终结符A，下一个输入Token为终结符a时，可选的产生式集合&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;/compiler-construction-principles/tableM.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;构造：对于每个产生式 $X\rightarrow \gamma$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 $ t\in \text{First}(\gamma)$, 插入产生式 $X\rightarrow \gamma$ 到M[X,t]&lt;/li&gt;
&lt;li&gt;如果 $ \gamma \in \text{Nullable} $ 且 $t \in \text{Follow}(X)$, 插入产生式 $X\rightarrow \gamma$ 到M[X,t]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;如果某一格存在多个产生式，就说明无法确定选取哪个产生式，也就说明不是LL(1)文法！&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;第三步：预测分析&#34;&gt;&lt;a href=&#34;#第三步：预测分析&#34; class=&#34;headerlink&#34; title=&#34;第三步：预测分析&#34;&gt;&lt;/a&gt;第三步：预测分析&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;递归下降&lt;ul&gt;
&lt;li&gt;例如对于文法：&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;S -&amp;gt; E $&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;E -&amp;gt; E + T&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;E -&amp;gt; E – T&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;E -&amp;gt; T&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;T -&amp;gt; T * F&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;T -&amp;gt; T / F&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;T -&amp;gt; F&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;F -&amp;gt; id&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;F -&amp;gt; num&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;F -&amp;gt; ( E )&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
形如：&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt;)&lt;/span&gt; &amp;#123; E(); eat(EOF); &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt;)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;switch&lt;/span&gt;(tok) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;case&lt;/span&gt; ?: E(); eat(PLUS); T(); &lt;span class=&#34;keyword&#34;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;case&lt;/span&gt; ?: E(); eat(MINUS); T(); &lt;span class=&#34;keyword&#34;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;case&lt;/span&gt; ?: T(); &lt;span class=&#34;keyword&#34;&gt;break&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;default&lt;/span&gt;: error();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 问号处内容由预测分析表M决定，读者有兴趣可以帮忙验证一下这个文法是否LL(1)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;非递归下降（&lt;strong&gt;无需掌握&lt;/strong&gt;）&lt;ul&gt;
&lt;li&gt;本质上还是递归下降，只是改写成Pushdown Automata所以相当于模拟一个栈&lt;/li&gt;
&lt;li&gt;如果栈顶是非终结符A：利用预测分析表,选择产生式A -&amp;gt; a（也就是将栈顶的非终结符A替换成串a）&lt;/li&gt;
&lt;li&gt;如果栈顶是终结符a：将栈顶记号a和输入中的Token匹配并出栈&lt;/li&gt;
&lt;li&gt;初态：压入初始符号&lt;/li&gt;
&lt;li&gt;终态：输入读取完毕，栈空，此时接受&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;消除左递归、提左公因子&#34;&gt;&lt;a href=&#34;#消除左递归、提左公因子&#34; class=&#34;headerlink&#34; title=&#34;消除左递归、提左公因子&#34;&gt;&lt;/a&gt;消除左递归、提左公因子&lt;/h3&gt;&lt;p&gt;LL(1)文法的一些性质（可用于判定）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LL(1)文法是无二义的&lt;/li&gt;
&lt;li&gt;LL(1)文法是无左递归的&lt;/li&gt;
&lt;li&gt;LL(1)文法是无左公因子的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;左递归(left-recursive)文法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有非终结符A使得 $A \Rightarrow^* A\alpha$&lt;/li&gt;
&lt;li&gt;形如 $S\rightarrow Sa$ 的称为直接&amp;#x2F;立即左递归&lt;/li&gt;
&lt;li&gt;问题：这会导致递归下降分析进入无限循环&lt;ul&gt;
&lt;li&gt;$S\rightarrow Sa|b$ 分析 $baaaa$&lt;/li&gt;
&lt;li&gt;可能永远卡在”a”里而没机会考虑”b”: $ S \Rightarrow Sa \Rightarrow Saa \Rightarrow Saaa \Rightarrow Saaaa …$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;解决办法：通过文法变换消除（详见龙书）&lt;ul&gt;
&lt;li&gt;比如我们可以将这一文法：&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;A -&amp;gt; A a | b (a,b不以A开头，a不为空)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
转为右递归：&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;A -&amp;gt; b A&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;A&amp;#x27; -&amp;gt; aA&amp;#x27; | ϵ&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;左公因子的(left-factored)文法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$ P \rightarrow \alpha \beta | \alpha \gamma$&lt;/li&gt;
&lt;li&gt;问题：同一非终结符的多个候选式存在共同前缀，可能导致回溯&lt;/li&gt;
&lt;li&gt;解决办法：限制文法 或 文法变换&lt;ul&gt;
&lt;li&gt;例如我们可以提取左公因子来“推迟决定”，这样我们可以在读入更多token后进行决策：&lt;br&gt;把&lt;br&gt;$$ P \rightarrow \alpha \beta | \alpha \gamma $$&lt;br&gt;变换为&lt;br&gt;$$ P \rightarrow \alpha Q $$&lt;br&gt;$$ Q \rightarrow \beta | \gamma $$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;错误恢复&#34;&gt;&lt;a href=&#34;#错误恢复&#34; class=&#34;headerlink&#34; title=&#34;错误恢复&#34;&gt;&lt;/a&gt;错误恢复&lt;/h3&gt;&lt;p&gt;错误：表M中对应格是空格，没有任何可取的产生式&lt;br&gt;我们不希望遇到错误直接全盘放弃，而是令Parser报错后，尽可能从错误中恢复并继续工作，这样可以一次性尽可能报出程序里全部错误。&lt;/p&gt;
&lt;p&gt;可以通过以下几种方式恢复：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除：例如，可以一直跳过token直到遇到当前非终结符对应Follow集中的token&lt;/li&gt;
&lt;li&gt;插入：例如，如果左右括号不匹配，我们可以插入一个假装有&lt;/li&gt;
&lt;li&gt;替换：例如，变量名错误可以替换为最相近的变量名&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Part-5-语法分析-自底向上&#34;&gt;&lt;a href=&#34;#Part-5-语法分析-自底向上&#34; class=&#34;headerlink&#34; title=&#34;Part 5: 语法分析 - 自底向上&#34;&gt;&lt;/a&gt;Part 5: 语法分析 - 自底向上&lt;/h2&gt;&lt;h2 id=&#34;Part-6-抽象语法&#34;&gt;&lt;a href=&#34;#Part-6-抽象语法&#34; class=&#34;headerlink&#34; title=&#34;Part 6: 抽象语法&#34;&gt;&lt;/a&gt;Part 6: 抽象语法&lt;/h2&gt;&lt;h2 id=&#34;Part-7-语义分析&#34;&gt;&lt;a href=&#34;#Part-7-语义分析&#34; class=&#34;headerlink&#34; title=&#34;Part 7: 语义分析&#34;&gt;&lt;/a&gt;Part 7: 语义分析&lt;/h2&gt;&lt;p&gt;&lt;em&gt;&amp;gt;&amp;gt;&amp;gt; To be continued…&lt;/em&gt;&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
