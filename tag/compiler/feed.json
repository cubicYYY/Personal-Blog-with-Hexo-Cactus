{
    "version": "https://jsonfeed.org/version/1",
    "title": "Cubic Y³ • All posts by \"compiler\" tag",
    "description": "Notes, CTF, DIY, thoughts and waifus.\n\nI'm CubicYYY, an undergraduate student majoring in Computer Science at Zhejiang University.\n❤❤❤ CTF, toy projects, electric guitar\n✖✖✖ Technological supremacy\n\nRésumé👉 [here](https://latexonline.cc/compile?git=https://github.com/cubicYYY/resume&target=resume.tex&command=xelatex).",
    "home_page_url": "http://cubicy.icu",
    "items": [
        {
            "id": "http://cubicy.icu/compiler-construction-principles/",
            "url": "http://cubicy.icu/compiler-construction-principles/",
            "title": "编译原理课程笔记（All-in-One速通版）",
            "date_published": "2024-04-13T17:10:20.000Z",
            "content_html": "<h1 id=\"编译原理Speed-run-any\"><a href=\"#编译原理Speed-run-any\" class=\"headerlink\" title=\"编译原理Speed-run any%\"></a>编译原理<code>Speed-run any%</code></h1><p>以<strong>快速复习</strong>为目的，尽可能对缺乏动机(intuition)的一些概念<strong>提供课堂外的例子以简明解释</strong>。<br>标题中使用<code>*</code>标记的部分为考试<strong>不</strong>考察的内容。</p>\n<p><strong>包含浙江大学编译原理课程课改后新增部分。</strong></p>\n<p>文中大部分图片来自于姚老师(ZJU, pyaoaa at zju.edu.cn)，在此表示感谢。<br>建议阅读本笔记时配合老师课件&#x2F;讲义作为参照。</p>\n<h2 id=\"Part-0-课程信息\"><a href=\"#Part-0-课程信息\" class=\"headerlink\" title=\"Part 0: 课程信息\"></a>Part 0: 课程信息</h2><p>使用教材：<em>Modern Compiler Implementation in C</em>, Andrew W. Appel （A.K.A. 虎书）</p>\n<p>相关课程：</p>\n<ul>\n<li><a href=\"http://web.stanford.edu/class/cs143/\">Stanford课程主页</a></li>\n<li><a href=\"https://github.com/6035/sp21\">MIT课程主页</a></li>\n<li><a href=\"https://inst.eecs.berkeley.edu/~cs164/fa21/\">UCBerkeley课程主页</a></li>\n</ul>\n<p>分数构成：</p>\n<ul>\n<li>课程作业(课后小型练习题) &#x3D; 10%</li>\n<li>随堂测验&#x3D; 10%</li>\n<li>期中考试&#x3D; 15%</li>\n<li>综合性课程设计&#x3D; 25%</li>\n<li>期末考试&#x3D; 40% （斩杀线40&#x2F;100）</li>\n</ul>\n<p>期末考试：</p>\n<ul>\n<li>半开卷，允许携带<strong>3 张可双面打印或手写的 A4 纸</strong>入场</li>\n<li>考试范围：虎书 1-11 13-14 18 章：<br>Ch.01 Introduction<br>Ch.02 Lexical Analysis<br>Ch.03 Parsing<br>Ch.04 Abstract Syntax<br>Ch.05 Semantic Analysis<br>Ch.06 Activation Record<br>Ch.07 Translating into Intermediate Code<br>Ch.08 Basic Blocks and Traces<br>Ch.09 Instruction Selection<br>Ch.10 Liveness Analysis<br>Ch.11 Register Allocation<br>Ch.13 Garbage Collection<br>Ch.14 Object-oriented Languages<br>Ch.18 Loop Optimizations</li>\n<li>题型：判断30道*1分 选择20道*1分 大题共50分</li>\n<li><strong>复习要点：熟悉重要概念、算法；提高计算题熟练度；确保掌握作业题。</strong></li>\n</ul>\n<p>前置知识：计算理论（笔记参考<a href=\"https://note.tonycrane.cc/cs/tcs/toc/\">https://note.tonycrane.cc/cs/tcs/toc/</a>）</p>\n<h2 id=\"Part-1-简介\"><a href=\"#Part-1-简介\" class=\"headerlink\" title=\"Part 1: 简介\"></a>Part 1: 简介</h2><p>基本概念：</p>\n<ul>\n<li>中间代码&#x3D;Intermediate Code</li>\n<li>词法分析&#x3D;Lexing&#x2F;Scanning&#x2F;LexicalAnalysis</li>\n<li>语法分析&#x3D;Parsing&#x2F;SyntaxAnalysis</li>\n<li>中间表示&#x3D;IR&#x3D;Intermediate Representation</li>\n<li>树型中间表示&#x3D;IR Tree</li>\n<li>前端，后端</li>\n</ul>\n<h2 id=\"Part-2-词法分析\"><a href=\"#Part-2-词法分析\" class=\"headerlink\" title=\"Part 2: 词法分析\"></a>Part 2: 词法分析</h2><h3 id=\"词法分析概述\"><a href=\"#词法分析概述\" class=\"headerlink\" title=\"词法分析概述\"></a>词法分析概述</h3><p>使用分词器(parser &#x2F; tokenizer)将输入字符串切割、识别为有意义的子串（把基本单元划分好）。<br><code>(单词Token, 词素Lexeme(可选))</code><br>e.g.:</p>\n<ul>\n<li><code>(IF, )</code> <code>(ELSE, )</code> <code>(BINARY_OP, &gt;=)</code> <code>(UNARY_OP, &amp;)</code></li>\n</ul>\n<h3 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h3><p><em>读者应当已经在前置课程中掌握了该部分内容。</em></p>\n<p>Regex Expression &#x3D; RE<br>运算：连接concatenation + 幂Power<br>e.g.: $ ab(a|b)^3c^* $</p>\n<h3 id=\"有穷自动机\"><a href=\"#有穷自动机\" class=\"headerlink\" title=\"有穷自动机\"></a>有穷自动机</h3><p><em>读者应当已经在前置课程中掌握了该部分内容。</em></p>\n<p>相关概念：</p>\n<ul>\n<li><p>NFA: 非确定有限状态自动机</p>\n</li>\n<li><p>DFA: 确定有限状态自动机</p>\n</li>\n<li><p>子集构造法subset construction</p>\n<ul>\n<li>用途：NFA-&gt;DFA</li>\n<li>DFA的每个状态是NFA的状态集合的一个子集</li>\n<li>读了输入ai后NFA能到达的所有状态：s1,s2,…,sk，则DFA到达一个状态，对应于NFA的{s1,s2,…,sk}</li>\n<li>NFA状态(集)上的一些操作定义<ul>\n<li>ε-closure(s):&#x3D; NFA状态s的ε-闭包&#x3D;s经ε转换所能到达的状态集合</li>\n<li>ε-closure(T):&#x3D; T中所有状态的ε-闭包的并集,即 $ \\cup_{s\\in T}{\\epsilon-closure(s)} $</li>\n</ul>\n</li>\n<li>过程<ol>\n<li>NFA的初始状态S的ε-闭包对应于DFA的初始状态</li>\n<li>针对每个DFA状态(对应NFA状态子集A)，求输入每个可能输入ai后能到达的NFA状态的ε-闭包并集（NFA从状态集A出发，读入ai后能到达的状态集合） $$ S&#x3D;\\epsilon-closure(move(A,a_i)) $$</li>\n<li>该集合S要么对应于DFA中的一个已有状态，要么令其成为一个新加的DFA状态</li>\n<li>重复上述两步，逐步构造DFA的状态转换表（每个状态集合S与每个输入ai），直到不动点（不再新增状态，且状态转移表完全求出，即对任一状态集合S已知分别接受所有输入ai将分别转移到何状态）</li>\n<li>在DFA中，只要状态集合S包含至少一个原来NFA中的终止状态，就把S标记为终止状态</li>\n</ol>\n</li>\n<li>示例：<ul>\n<li><img src=\"/compiler-construction-principles/nfa2dfa.png\" alt=\"nfa2dfa\" loading=\"lazy\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Thumpson构造法(RE-&gt;NFA)：略。只需要注意<strong>不要自作主张省去一些 ε-move 与状态</strong>即可。</p>\n</li>\n</ul>\n<h3 id=\"词法分析器自动生成\"><a href=\"#词法分析器自动生成\" class=\"headerlink\" title=\"词法分析器自动生成\"></a>词法分析器自动生成</h3><ul>\n<li>DFA最小化（-&gt;状态最小的DFA，在同构意义下唯一）</li>\n<li>可区分状态：存在串s使其分别从状态s、t出发，一个接受串s，一个拒绝串s，则s与t可区分</li>\n<li>步骤：<ol>\n<li>初始等价类，仅由接受状态集合和非接受状态两个集合构成</li>\n<li>用所有可能的输入ai应用于各个集合（走一步）<ul>\n<li>只有集合G的每个状态读入同一字符后，都落入（包含在）相同的某个集合，该集合G在这一步才不用细分</li>\n<li>否则集合G要被细分：落入不同集合的对应状态需要被分割进不同集合</li>\n</ul>\n</li>\n<li>不断重复2直到不动点（任一集合分别对所有输入ai都不可细分）</li>\n<li>此时等价类中的每个集合即对应最小DFA的一个状态。在其上可以轻松构建min-DFA，该过程是trivial的（可以每个组中选择一个状态作代表）。</li>\n</ol>\n</li>\n<li>示例：<ul>\n<li><img src=\"/compiler-construction-principles/DFA-simplify-diverge.png\" alt=\"DFA-simplify-diverge\" loading=\"lazy\"></li>\n<li><img src=\"/compiler-construction-principles/DFA-simplify.png\" alt=\"DFA-simplify\" loading=\"lazy\"></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lex工具\"><a href=\"#Lex工具\" class=\"headerlink\" title=\"Lex工具\"></a>Lex工具</h3><p>通常和Yacc一起使用，生成编译器的前端。</p>\n<ul>\n<li>声明部分<ul>\n<li>常量：常数标识符</li>\n<li>正则规则定义</li>\n</ul>\n</li>\n<li>转换规则模式{动作}<ul>\n<li>模式&#x3D;正则表达式</li>\n<li>动作&#x3D;识别到相应模式时应调用的处理函数（一般以C语言代码表示）</li>\n</ul>\n</li>\n<li>辅助函数：动作中使用的函数</li>\n</ul>\n<p>解决冲突：最长匹配，较前规则优先</p>\n<h2 id=\"Part-3-语法分析-CFG-Parsing\"><a href=\"#Part-3-语法分析-CFG-Parsing\" class=\"headerlink\" title=\"Part 3: 语法分析 - CFG &amp; Parsing\"></a>Part 3: 语法分析 - CFG &amp; Parsing</h2><h3 id=\"语法分析器概述\"><a href=\"#语法分析器概述\" class=\"headerlink\" title=\"语法分析器概述\"></a>语法分析器概述</h3><p>从词法分析器获得Token序列，确认该序列是否可以由语言的文法生成</p>\n<ul>\n<li>对于语法错误的程序，报告错误信息</li>\n<li>对于语法正确的程序，生成语法分析树(简称语法树) e.g. 抽象语法树AST</li>\n</ul>\n<p>实现：手动 or 自动(使用Parse generator&#x3D;{Yacc, Bison, ANTLR, mehir…})</p>\n<h3 id=\"上下文无关文法CFG\"><a href=\"#上下文无关文法CFG\" class=\"headerlink\" title=\"上下文无关文法CFG\"></a>上下文无关文法CFG</h3><p>CFG &#x3D; Context Free Language</p>\n<p>$$ G&#x3D;(T,N,P,S) $$<br>T：终结符集合(Terminals)<br>N：非终结符集合(Non-terminals)<br>P：产生式集合(Productions) $ A\\rightarrow a, A \\in N, a \\in (T \\cup N)^*$<br>S：开始符号(Startsymbol): $ S \\in N $</p>\n<blockquote>\n<p>📕“上下文无关”体现在：产生式左侧只有一个非终结符，因此类似 $xAy\\rightarrow xay$这样，需要关心符号前后别的符号是什么才能应用的产生式是不能在CFG里的。</p>\n</blockquote>\n<ul>\n<li>特殊符号：$ &#x3D;end of file(EOF)<br>添加一个新符号S’与一条新规则以表明必须在尾部：<ul>\n<li>$ S’ \\rightarrow S$ $</li>\n</ul>\n</li>\n<li>产生式缩写：左侧一样的产生式可以把右侧使用”|”合并。例如 $E\\rightarrow E+E|(E)|id$</li>\n</ul>\n<h3 id=\"推导Derivation和规约Reduction\"><a href=\"#推导Derivation和规约Reduction\" class=\"headerlink\" title=\"推导Derivation和规约Reduction\"></a>推导Derivation和规约Reduction</h3><p>例如有产生式 $A\\rightarrow \\gamma$，可以有这样的变换： $\\alpha A \\beta \\Rightarrow \\alpha \\gamma \\beta$<br>那么我们说：</p>\n<ul>\n<li>$\\alpha A \\beta $ <strong>直接推导</strong>到 $ \\alpha \\gamma \\beta$</li>\n<li>$\\alpha \\gamma \\beta $ <strong>直接规约</strong>到 $  \\alpha A \\beta$<br>不言而喻的<strong>多步推导记号</strong>：$\\Rightarrow^5$ $\\Rightarrow^+$ $\\Rightarrow^*$<br>分别代表五步推导，至少一步推导，0次或更多次推导</li>\n<li>推导&#x3D;从文法生成语言里的句子，规约&#x3D;识别句子成分并逐渐规约到开始符号</li>\n</ul>\n<ol>\n<li><p>最左推导Left-most Derivation</p>\n<ul>\n<li>最左推导&#x3D;每步代换最左边的非终结符。逆过程为最右规约</li>\n<li>类比可得出最右推导、最左规约的定义</li>\n<li>在自顶向下的分析中，总是采用<strong>最左推导</strong>；在自底向上的分析中，总是采用<strong>最左归约</strong></li>\n</ul>\n<p> <img src=\"/compiler-construction-principles/lmrm.png\" alt=\"left-most derive\" loading=\"lazy\"></p>\n</li>\n<li><p>句型 句子 语言</p>\n<ul>\n<li>句型(Sentential form) &#x3D; 文法G下可能推导出的一个符号序列：可能包含终结符&#x2F;非终结符，可为空</li>\n<li>句子(Sentence) &#x3D; 不含非终结符的句型（仅含终结符）</li>\n<li>语言(Language) &#x3D; 文法G可产生的所有句子的集合</li>\n</ul>\n</li>\n<li><p>正则文法(RE) 与 上下文无关文法(CFG)</p>\n<ul>\n<li>上下文无关语言L(G) :&#x3D; CFG产生的所有句子的集合</li>\n<li>正则语言L(r) :&#x3D; RE产生的所有句子的集合<ul>\n<li>RE &#x3D; Regex Expression &#x3D; 正则表达式</li>\n<li>正则表达式r定义正则语言L(r)</li>\n<li>$ L(r) \\in L(G) $：因为正则对产生式限制更大，必须为( $A,B \\in N, a \\in T\\cup {\\epsilon} $ )：<ul>\n<li>左线性文法：形如 $A\\rightarrow aB$ 或 $A\\rightarrow a$</li>\n<li>右线性文法：形如 $A\\rightarrow Ba$ 或 $A\\rightarrow a$</li>\n</ul>\n</li>\n<li>正则语言可用于词法分析，上下文无关语言可用于语法分析（语言描述能力、复杂性决定的）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Chomsky范式（计算理论课程内容）:</p>\n<ul>\n<li>0型文法&#x3D;短语结构文法 递归可枚举</li>\n<li>1型文法&#x3D;上下文有关文法</li>\n<li>2型文法&#x3D;CFG</li>\n<li>3型文法&#x3D;RE</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"CFG的分析树Parse-Tree\"><a href=\"#CFG的分析树Parse-Tree\" class=\"headerlink\" title=\"CFG的分析树Parse Tree\"></a>CFG的分析树Parse Tree</h3><ul>\n<li><p>分析树性质</p>\n<ul>\n<li>根节点&#x3D;文法初始符号</li>\n<li>叶节点&#x3D;终结符</li>\n<li>内部节点&#x3D;非终结符</li>\n<li>父节点→{叶节点}&#x3D;产生式</li>\n</ul>\n</li>\n<li><p>语法分析(Parsing)中的挑战<br><em>核心目标：对于终结符号串x，要么从S推导出x，要么设法将x规约到S</em>*</p>\n<ul>\n<li>自顶向下(Top-down) S-&gt;x, 从<strong>根节点</strong>开始构造Parse Tree</li>\n<li>自底向上(Bottom-up) x-&gt;S, 从<strong>叶节点</strong>开始构造Parse Tree</li>\n</ul>\n<p>作为搜索问题：搜索空间大-&gt;空间大小受文法产生式限制</p>\n<ul>\n<li>无限制：时间复杂度 $O(n^3)$</li>\n<li>上下文无关语言CFL 的子集需要的典型时间为 $O(n)$，例如<ul>\n<li>Predictive parsing using LL(1) grammars</li>\n<li>Shift-Reduce parsing using LR(1) grammars</li>\n<li>…</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"编程语言的文法设计\"><a href=\"#编程语言的文法设计\" class=\"headerlink\" title=\"编程语言的文法设计\"></a>编程语言的文法设计</h3><p>核心：<strong>无二义性</strong></p>\n<ul>\n<li><p>二义性来源：某些句子存在不止一棵分析树&#x3D;有两个不同的最左推导&#x3D;<strong>多种可选推导处于文法同一层</strong><br>例如：$$E \\Rightarrow E*E \\Rightarrow id*E \\Rightarrow id*E+E$$ 与 $$E \\Rightarrow E+E \\Rightarrow E*E+E \\Rightarrow id*E+E $$<br>对于”3*4+5”，前者给出3*(4+5)&#x3D;27（错误），后者给出3*4+5&#x3D;17（正确）。</p>\n</li>\n<li><p>解决办法：</p>\n<ul>\n<li>确保只有一种最左推导&#x3D;将同一层文法分层</li>\n<li>规定符号优先级（”*“” &gt; “+”,”-“）<ul>\n<li>越接近开始符号S的文法符号优先级越低</li>\n</ul>\n</li>\n<li>规定符号结合性（左结合&#x2F;右结合）<ul>\n<li>递归非终结符（也就是这个终结符在产生式左部右部都出现）在终结符（也就是这个运算符，比如<code>*</code>,<code>+</code>）左边，运算就左结合</li>\n<li><img src=\"/compiler-construction-principles/priority.png\" alt=\"op priority\" loading=\"lazy\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>判定CFG二义性：不可判定问题<br>但可以通过给定充分条件（无二义文法）确保无二义性：</p>\n<ul>\n<li>自顶向下：LL(1)</li>\n<li>自底向上：LR(1), LALR(1)<br><a name=\"grammars-set\"></a></li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/compiler-construction-principles/grammars.png\" alt=\"grammars\" loading=\"lazy\"></p>\n<h2 id=\"Part-4-语法分析-自顶向下\"><a href=\"#Part-4-语法分析-自顶向下\" class=\"headerlink\" title=\"Part 4: 语法分析 - 自顶向下\"></a>Part 4: 语法分析 - 自顶向下</h2><p>自顶向下每一步的推导都需要做出<strong>两个选择</strong>：</p>\n<ul>\n<li>替换哪个非终结符？</li>\n<li>应用哪个（左侧为该终结符的）产生式替换？</li>\n</ul>\n<p>通用形式：<strong>递归下降分析(Recursive-Descent Parsing)</strong></p>\n<ul>\n<li>发生错误（没有产生式可以产生合法的子节点）就回溯</li>\n<li>问题：太慢！</li>\n<li>该过程类似NFA，能否构造类似DFA的分析方法？</li>\n</ul>\n<h3 id=\"LL-1-和预测分析法\"><a href=\"#LL-1-和预测分析法\" class=\"headerlink\" title=\"LL(1)和预测分析法\"></a>LL(1)和预测分析法</h3><p>预测分析法(Predictive parsing)：接受LL(k)文法</p>\n<ul>\n<li>第一个L: “left to right” 从左到右扫描</li>\n<li>第二个L: “left-most derivation” 最左推导</li>\n<li>k: 向前看k个token确定推导选用的产生式（一般不明确说k就是k&#x3D;1）</li>\n</ul>\n<p>接下来需要添加约束使其无需回溯。我们先引入几个概念：</p>\n<ul>\n<li><p>First集和Follow集</p>\n<p>给定 $ G&#x3D;(T,N,P,S),\\alpha \\in (T\\cup N)^* $<br><strong>记空串为$\\epsilon$</strong></p>\n<ul>\n<li><p>First集：可从$\\alpha$推导得到的串的首个终结符的集合（也就是说，$\\alpha$自己推导出的第一个终结符可能是什么）<br>$$ \\text{First}(\\alpha)&#x3D;{a| \\alpha \\Rightarrow^*a…\\ ,a\\in T} $$</p>\n</li>\n<li><p>Follow集：从S出发，可能在推导过程中跟在A右边的终结符号集<br>$$ \\text{Follow}(A)&#x3D;{a|S\\Rightarrow^*…Aa…\\ ,a\\in T} $$</p>\n<ul>\n<li>例如: $ S\\rightarrow \\alpha\\ A a\\ \\beta $，终结符号 $ a\\in \\text{Follow}(A) $ （仔细区分a和α）</li>\n</ul>\n</li>\n</ul>\n<p>至此可以使用两个条件保证产生式的选择是唯一的：<br>对于产生式 $ A\\rightarrow \\alpha|\\beta $ ,</p>\n<ol>\n<li>$ \\text{First}(\\alpha)\\cap \\text{First}(\\beta)&#x3D; \\emptyset $ （α和β推导不出以同一个单词为首的串）<ul>\n<li>意义：显然的。这样看终结符是哪个就知道应该用哪个产生式。</li>\n</ul>\n</li>\n<li>若$\\beta \\Rightarrow^* \\epsilon$，那么$\\alpha \\nRightarrow^* \\epsilon$，且 $ \\text{First}(\\alpha) \\cap Follow(A) &#x3D; \\emptyset $ （α和β不能同时推出$\\epsilon$;First(α)不应在Follow(A) 中）<ul>\n<li>意义：其实就是考虑如果可以推导出空串时，后继终结符因为是空串所以暂时还没法确定，得从Follow集中寻找（再向后看），最终做出哪个产生式的选择。</li>\n<li>在<strong>满足这条要求的情况下</strong>，假设下一个输入是b,且$\\beta \\Rightarrow^* \\epsilon$<ul>\n<li>如果b∈First(α)，则选择A → α(属于上面1的情况)</li>\n<li>如果b∈Follow(A)，则选择A → β ,这对应A最终到达了$\\epsilon$而且后面紧跟着终结符b的情况</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p><strong>应试建议：直接列出LL(1)分析表并检查是否有<em>冲突</em>（见下文）。</strong></p>\n</li>\n</ul>\n<p>接下来我们会看到具体的LL(1)预测分析实现方式。<br><strong>三步走：计算First,Follow-&gt;构造预测分析表-&gt;预测分析</strong></p>\n<ol>\n<li><p>计算First, Follow</p>\n<ul>\n<li><p>Nullable集<br>  由于刚刚提到了空串，我们需要引入一个简单的新定义：Nullable集&#x3D;{可推导出空串的符号}。<br>  定义是递归的：</p>\n<ul>\n<li>Base Case: 如果有产生式 $ X\\rightarrow \\epsilon$, 那么X当然是Nullable的</li>\n<li>Inductive Case: 如果有产生式 $ X\\rightarrow Y_1 Y_2 Y_3 … Y_n$, 且 $Y_1,Y_2,Y_3,…,Y_n$<strong>每个都能</strong>推导出空串，则X是Nullable的</li>\n<li>对于每个产生式，我们可以循环用它们不断更新Nullable集直到不动点。这同样适用于First集与Follow集。</li>\n</ul>\n</li>\n<li><p>First集：</p>\n<ul>\n<li>Base Case: 如果X是终结符terminal: First(X)&#x3D;{X}</li>\n<li>Inductive Case: 如果有产生式 $ X\\rightarrow Y_1 Y_2 Y_3 … Y_n$<ul>\n<li>首先，$\\text{First}(X) \\cup &#x3D; \\text{First}(Y_1)$ ($ a\\cup &#x3D; b$意为$ a \\leftarrow a\\cup b$，也就是把b并进a里)</li>\n<li>如果$Y_1 \\in \\text{Nullable}: $$\\text{First}(X) \\cup &#x3D; \\text{First}(Y_2)$</li>\n<li>如果$Y_1,Y_2 \\in \\text{Nullable}: $$\\text{First}(X) \\cup &#x3D; \\text{First}(Y_3)$</li>\n<li>…</li>\n<li>直到某个$Y_i \\notin \\text{Nullable}$则停止</li>\n</ul>\n</li>\n<li>对于每个产生式，我们可以循环用它们不断更新First集直到不动点。</li>\n</ul>\n</li>\n<li><p>Follow集：</p>\n<ul>\n<li>Base Case: $ \\text{Follow}(A)&#x3D;\\emptyset $</li>\n<li>Inductive Case: 如果有产生式 $ B\\rightarrow s_1 A\\ s_2 $<ul>\n<li>$\\text{Follow}(A) \\cup &#x3D; \\text{First}(s_2)$</li>\n<li>如果$s_2 \\in \\text{Nullable}$, $\\text{Follow}(A) \\cup &#x3D; \\text{Follow}(B)$</li>\n</ul>\n</li>\n<li>对于每个产生式，我们可以循环用它们不断更新Follow集直到不动点。</li>\n</ul>\n</li>\n</ul>\n<p> Tips(不要求掌握):Tiger book algorithm 3.13指出他们可以同时计算，感兴趣可以看看。</p>\n</li>\n<li><p>构造预测分析表</p>\n<ul>\n<li><p><del>打开网站即可<a href=\"https://jsmachines.sourceforge.net/machines/ll1.html\">LL(1) Parser Generator</a></del> 不过这个网站确实对于理解第三步中PDA相关过程很有帮助。</p>\n</li>\n<li><p>回顾自顶向下推导的两个选择题：</p>\n<ul>\n<li>Q: 替换当前句型中的哪个非终结符? A: “Left-most”一词说明：总是选择每个句型的最左非终结符进行替换。</li>\n<li>Q: 用该非终结符的哪个产生式进行替换? A: 构建二维表M, 通过当前非终结符和看到的终结符决定选取何种产生式。</li>\n</ul>\n</li>\n<li><p>定义并构造M：</p>\n<ul>\n<li>每一行A对应一个非终结符</li>\n<li>每一列a对应某个终结符或输入结束符<code>$</code></li>\n<li>表中的某一格M[A,a]表示：针对当前非终结符A，下一个输入Token为终结符a时，可选的产生式集合<br><img src=\"/compiler-construction-principles/tableM.png\" alt=\"M table\" loading=\"lazy\"></li>\n<li>构造过程：对于每个产生式 $X\\rightarrow \\gamma$<ul>\n<li>如果 $ t\\in \\text{First}(\\gamma)$, 插入产生式 $X\\rightarrow \\gamma$ 到M[X,t]</li>\n<li>如果 $ \\gamma \\in \\text{Nullable} $ 且 $t \\in \\text{Follow}(X)$, 插入产生式 $X\\rightarrow \\gamma$ 到M[X,t]</li>\n</ul>\n</li>\n<li><strong>如果某一格存在多个产生式，就说明无法确定选取哪个产生式（也即：产生了<em>冲突</em>），也就说明不是LL(1)文法！</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>预测分析</p>\n<ul>\n<li><p>递归下降</p>\n<ul>\n<li>例如对于文法：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">S -&gt; E $</span><br><span class=\"line\">E -&gt; E + T</span><br><span class=\"line\">E -&gt; E – T</span><br><span class=\"line\">E -&gt; T</span><br><span class=\"line\">T -&gt; T * F</span><br><span class=\"line\">T -&gt; T / F</span><br><span class=\"line\">T -&gt; F</span><br><span class=\"line\">F -&gt; id</span><br><span class=\"line\">F -&gt; num</span><br><span class=\"line\">F -&gt; ( E )</span><br></pre></td></tr></table></figure>\n\n<p>形如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">S</span><span class=\"params\">(<span class=\"type\">void</span>)</span> &#123; E(); eat(EOF); &#125; </span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">E</span><span class=\"params\">(<span class=\"type\">void</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span>(tok) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">case</span> ?: E(); eat(PLUS); T(); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> ?: E(); eat(MINUS); T(); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> ?: T(); <span class=\"keyword\">break</span>; </span><br><span class=\"line\">    <span class=\"keyword\">default</span>: error();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 问号处内容由预测分析表M决定，读者有兴趣可以帮忙验证一下这个文法是否LL(1)</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>非递归下降（<strong>无需掌握</strong>）</p>\n<ul>\n<li>本质上还是递归下降，只是改写成Pushdown Automata所以相当于模拟一个栈</li>\n<li>如果栈顶是非终结符A：利用预测分析表,选择产生式A -&gt; a（也就是将栈顶的非终结符A替换成串a）</li>\n<li>如果栈顶是终结符a：将栈顶记号a和输入中的Token匹配并出栈</li>\n<li>初态：压入初始符号</li>\n<li>终态：输入读取完毕，栈空，此时接受</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"消除左递归、提左公因子\"><a href=\"#消除左递归、提左公因子\" class=\"headerlink\" title=\"消除左递归、提左公因子\"></a>消除左递归、提左公因子</h3><ol>\n<li><p>LL(1)文法的部分性质<br>可用于判定问题。</p>\n<ul>\n<li>LL(1)文法是无二义的</li>\n<li>LL(1)文法是无左递归的</li>\n<li>LL(1)文法是无左公因子的</li>\n</ul>\n</li>\n<li><p>左递归(left-recursive)文法:</p>\n<ul>\n<li><p>有非终结符A使得 $A \\Rightarrow^* A\\alpha$</p>\n</li>\n<li><p>形如 $S\\rightarrow Sa$ 的称为直接&#x2F;立即左递归</p>\n</li>\n<li><p>问题：这会导致递归下降分析进入无限循环</p>\n<ul>\n<li>$S\\rightarrow Sa|b$ 分析 $baaaa$</li>\n<li>可能永远卡在”a”里而没机会考虑”b”: $ S \\Rightarrow Sa \\Rightarrow Saa \\Rightarrow Saaa \\Rightarrow Saaaa …$</li>\n</ul>\n</li>\n<li><p>解决办法：通过文法变换消除（详见龙书）<br>比如可以将这一文法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A -&gt; A a | b (a,b不以A开头，a不为空)</span><br></pre></td></tr></table></figure>\n\n<p>转为右递归：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A -&gt; b A&#x27;</span><br><span class=\"line\">A&#x27; -&gt; aA&#x27; | ε</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>左公因子的(left-factored)文法:</p>\n<ul>\n<li>$ P \\rightarrow \\alpha \\beta | \\alpha \\gamma$</li>\n<li>问题：同一非终结符的多个候选式存在共同前缀，可能导致回溯</li>\n<li>解决办法：限制文法 或 文法变换<ul>\n<li>例如可以提取左公因子来“推迟决定”，这样可以在读入更多token后进行决策：<br> 把<br> $$ P \\rightarrow \\alpha \\beta | \\alpha \\gamma $$<br> 变换为<br> $$ P \\rightarrow \\alpha Q \\\\ Q \\rightarrow \\beta | \\gamma $$</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"错误恢复\"><a href=\"#错误恢复\" class=\"headerlink\" title=\"错误恢复\"></a>错误恢复</h3><p>错误：表M中对应格是空格，没有任何可取的产生式<br>我们不希望遇到错误直接全盘放弃，而是令Parser报错后，尽可能从错误中恢复并继续工作，这样可以一次性尽可能报出程序里全部错误。</p>\n<p>可以通过以下几种方式恢复：</p>\n<ul>\n<li>删除：例如，可以一直跳过token直到遇到当前非终结符对应Follow集中的token</li>\n<li>插入：例如，如果左右括号不匹配，我们可以插入一个括号，暂时假装它是匹配的</li>\n<li>替换：例如，变量名错误可以替换为最相近的变量名</li>\n</ul>\n<p>我们之后会细讲错误恢复的策略。</p>\n<h2 id=\"Part-5-语法分析-自底向上\"><a href=\"#Part-5-语法分析-自底向上\" class=\"headerlink\" title=\"Part 5: 语法分析 - 自底向上\"></a>Part 5: 语法分析 - 自底向上</h2><p>从串w归约为文法开始符号S的过程。规约时，一个与某产生式体<strong>相匹配的特定子串</strong>被替换为该产生式头部的<strong>非终结符号</strong>。</p>\n<p>问题：</p>\n<ul>\n<li>何时归约(归约哪些符号串)？</li>\n<li>归约到哪个非终结符号？</li>\n</ul>\n<p>回顾LL(1)的优势劣势：</p>\n<ul>\n<li>+ 运行高效(线性时间)</li>\n<li>+ 递归实现符合文法结构、适合手动构造&amp;自动生成</li>\n<li>- 能分析的文法类型受限</li>\n</ul>\n<p>我们提出新文法：LR(k)</p>\n<ul>\n<li>表达力: Every LL(k) grammar is also LR(k)</li>\n<li>不要求无左公因式</li>\n<li>可以处理左递归文法</li>\n<li>被广泛采用(Yacc, Bison, …)</li>\n<li>“L”: left-to-right scanning 自左向右扫描</li>\n<li>“R”: right-most derivation in reverse 最右推导的逆</li>\n<li>“k”: 向前看的字符的个数(k省略时取1)</li>\n<li>子集（详见<a href=\"#grammars-set\">该图</a>）：LR(1), LALR(1), SLR, LR(0), …</li>\n</ul>\n<h3 id=\"移进-规约-Shift-Reduce\"><a href=\"#移进-规约-Shift-Reduce\" class=\"headerlink\" title=\"移进-规约 Shift-Reduce\"></a>移进-规约 Shift-Reduce</h3><p><strong>这是LR(k) Parsing 的一般模式。</strong></p>\n<p>核心思想：将字符串一分为二，</p>\n<ul>\n<li>右侧是未被parser检查过的</li>\n<li>左侧包含终结符与非终结符<br>我们接下来会使用”|”标记分割点。</li>\n</ul>\n<p>例如，考虑该文法： $ E \\rightarrow E+(E) | \\text{int} $</p>\n<ul>\n<li>显然并非LL(1)的：存在左递归</li>\n</ul>\n<p>我们考虑处理字符串”int+(int)+(int)”，则过程如下：<br><img src=\"/compiler-construction-principles/sr.png\" alt=\"shift reduce\" loading=\"lazy\"></p>\n<p>可见LR分析采用最右推导的<strong>逆过程</strong>：最左规约。因此LR分析的每一步都是最右句型。<br>一般实现方式：采用<strong>栈</strong>进行Shift-Reduce</p>\n<ul>\n<li>栈：包含左侧字符串</li>\n<li>输入流：包含剩余未处理的右侧字符串</li>\n<li>操作：<ul>\n<li>Shift: 从输入读入一个Terminal压入栈</li>\n<li>Reduce: 栈顶的几个元素满足某条产生式的<strong>RHS(Right hand side)</strong>, 则pop这些元素并压入产生式的<strong>LHS(Left hand side)</strong></li>\n<li>Error: 爆！留待后文讨论。</li>\n<li>Accept: shift “$” 并且栈中只剩下文法的开始符号</li>\n</ul>\n</li>\n<li>需要解决的问题：<strong>何时shift? 何时reduce?</strong><ul>\n<li>表驱动的LR分析：类似LL文法的表，但行列意义不同，且这个表一般很大（详见后文）</li>\n</ul>\n</li>\n</ul>\n<p>几个文法的包含关系（仍然是详见<a href=\"#grammars-set\">该图</a>）:<br>$ LR(0) \\in SLR(1) \\in LALR(1) \\in LR(1) $</p>\n<h3 id=\"LR-0-Parsing\"><a href=\"#LR-0-Parsing\" class=\"headerlink\" title=\"LR(0) Parsing\"></a>LR(0) Parsing</h3><p>核心思想：因为需要凑出产生式RHS，维护栈顶内容对于所有产生式右侧的“进度”。<br>项(Item):&#x3D; 一个产生式加上在其中某处的一个点。</p>\n<p>例如产生式 $A\\rightarrow XYZ$ 有4个Item:</p>\n<ul>\n<li>$A\\rightarrow \\bullet XYZ $</li>\n<li>$A\\rightarrow X\\bullet YZ $</li>\n<li>$A\\rightarrow XY\\bullet Z $</li>\n<li>$A\\rightarrow XYZ \\bullet $</li>\n</ul>\n<p>Item的含义：</p>\n<ul>\n<li>$ A\\rightarrow \\alpha \\bullet \\beta$: 已扫描&#x2F;归约到了α，并期望在接下来的输入中经过扫描&#x2F;归约得到β，然后把αβ归约到A</li>\n<li>$ A\\rightarrow \\alpha \\beta \\bullet$: 已扫描&#x2F;归约得到了αβ，此时已经可以把αβ归约为A</li>\n</ul>\n<p><strong>Item类似一个有穷自动机的状态!</strong></p>\n<ul>\n<li>一个项读入一个符号后可以转变为另一个项：例如$A\\rightarrow \\bullet XYZ $ 读入X就可以转为 $A\\rightarrow X\\bullet YZ $</li>\n<li>显然项的数量是有限的。</li>\n<li>这样的有穷自动机被称为<strong>LR(0)自动机</strong>。</li>\n</ul>\n<p>LR(0)Parsing的NFA:</p>\n<blockquote>\n<p>⚠ NFA只能识别正则语言RE，然而RE&lt;LR(0). 所以这里的NFA只是用于辅助记录栈顶识别进度。</p>\n</blockquote>\n<ul>\n<li>新增开始符号S’，并加入产生式” S’-&gt;S$ “</li>\n<li>NFA起始状态：$S’\\rightarrow \\bullet S$ $</li>\n<li>NFA终结状态：$S’\\rightarrow S\\bullet$ $</li>\n<li>转移：<ul>\n<li>$A\\rightarrow \\bullet XY $ 读入X就可以转为 $A\\rightarrow X\\bullet Y $</li>\n<li>对于产生式 $ X\\rightarrow \\alpha Y \\beta $ 与 $Y\\rightarrow \\gamma$ 那么 $ X\\rightarrow \\alpha \\bullet Y \\beta $ 可以直接转换（ε-move）到 $ Y \\rightarrow \\bullet \\gamma$ （相当于递归下降法里进入下一层递归，从而分析当前产生式内部的非终结符）</li>\n</ul>\n</li>\n</ul>\n<p>我们更希望能转为DFA. 当然可以使用子集构造法转换，但事实上可以直接构造DFA.<br><img src=\"/compiler-construction-principles/lr-nfa2dfa.png\" alt=\"lr-nfa2dfa\" loading=\"lazy\"></p>\n<p>LR(0)Parsing的DFA与分析表：</p>\n<ul>\n<li><p>DFA构造：</p>\n<ul>\n<li><p>项集闭包CLOSURE:&#x3D; a <strong>set</strong> of <strong>items</strong>, 记为I</p>\n</li>\n<li><p>任意符号记为X</p>\n</li>\n<li><p>对任意项集Closure(I)求法（其实就是ε-closure）：<br>Closure(I) &#x3D;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repeat</span><br><span class=\"line\">  for any item A→ α•Xβ in I</span><br><span class=\"line\">    for any production X→ γ</span><br><span class=\"line\">      I ← I + &#123;X→ •γ&#125; </span><br><span class=\"line\">until I does not change. </span><br><span class=\"line\">return I</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>TL;DR: 如果”·”的右边是非终结符X，就把X为LHS的产生式对应的初始项加入。注意这是递归的：加入的新初始项如果也有这个情况还得接着加。</p>\n</blockquote>\n</li>\n<li><p>接下来的构造方式通过类比NFA-&gt;DFA的子集构造法是显然的：<br>GOTO(I,X):&#x3D; I是一个项集，X是一个文法符号，则GOTO(I,X)定义为I中所有形如 $A\\rightarrow \\bullet X \\beta$ 的项所对应的新项 $A\\rightarrow X \\bullet \\beta$ 构成的新集合生成的闭包（I是状态，X是转移，I里符合要求（也就是下一个符号是X）的产生式前移一位越过X加入转移到的新状态，不符合的被丢弃；当然考虑到ε-moves要再求一遍新状态的闭包）<br><img src=\"/compiler-construction-principles/lr-dfa.png\" alt=\"lr-dfa\" loading=\"lazy\"><br><img src=\"/compiler-construction-principles/lr-dfa-eg.png\" alt=\"lr-dfa example\" loading=\"lazy\"></p>\n</li>\n</ul>\n</li>\n<li><p>DFA到分析表<br>分析表T类似LL(1)中的表M，但是行列的含义与内容都发生了很大变化。</p>\n<ul>\n<li><p>Action表项：</p>\n<ul>\n<li>每一行对应一个状态i</li>\n<li>每一列对应一个<strong>终结符t</strong></li>\n<li>表中的一格T[i,t]代表要做的操作action，有以下几种可能：<ul>\n<li>$s_n$ &#x3D; shift n :&#x3D; 从状态i经过<strong>终结符t</strong>转移到状态n. 步骤：<ol>\n<li>从输入流中取一个终结符t压入状态栈</li>\n<li>将n压入状态栈</li>\n</ol>\n</li>\n<li>$r_k$ &#x3D; reduce k :&#x3D; 确定使用第k个产生式进行规约（此时状态i没有出边）。 步骤：<ol>\n<li>弹出状态栈顶的几个状态（数量对应产生式#k的RHS长度）</li>\n<li>符号栈压入产生式#k的LHS，也即一个非终结符X</li>\n<li>查询Goto表（见下文）T[i,X]将对应的下一个状态压入状态栈</li>\n</ol>\n</li>\n<li>accept :&#x3D; 该状态包含 $S’\\rightarrow S \\bullet $ $, 接受字符串，运行完毕</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Goto表项：</p>\n<ul>\n<li>每一行对应一个状态i</li>\n<li>每一列对应一个<strong>非终结符X</strong></li>\n<li>表中的一格T[i,X]表明经过<strong>非终结符X</strong>下一个状态是什么</li>\n<li>格中的$g_n$ &#x3D; goto n :&#x3D; 从状态i经过<strong>非终结符X</strong>转移到状态n</li>\n</ul>\n</li>\n<li><p><img src=\"/compiler-construction-principles/dfa2table.png\" alt=\"dfa to table\" loading=\"lazy\"></p>\n<blockquote>\n<p>LR实际实现只有状态栈，符号信息可从相应状态中获取</p>\n</blockquote>\n</li>\n<li><p>一个例子：<br><img src=\"/compiler-construction-principles/lr0-stack-table.png\" alt=\"lr0-stack-table\" loading=\"lazy\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<p>如何理解”LR(0)”中的”0”:</p>\n<ul>\n<li>Item中没有Lookahead terminal等信息，不关心后面的token</li>\n<li>是否规约&#x2F;使用何产生式规约完全取决于栈顶状态</li>\n</ul>\n<p><strong>局限性</strong>：由于只要有产生式能规约就立刻规约，很容易产生冲突（也就是表中一格有多个$s_n$,$r_n$，不知道应该直接规约还是需要接受更多符号来完成另一个产生式，这被称作<strong>shift-reduce conflict</strong>）<br>我们引入新的文法，放宽一些限制。</p>\n<h3 id=\"SLR-1-Parsing\"><a href=\"#SLR-1-Parsing\" class=\"headerlink\" title=\"SLR(1) Parsing\"></a>SLR(1) Parsing</h3><p>SLR(1) &#x3D; Simple LR(1)</p>\n<p>我们说过k省略时默认为1，所以称为SLR文法即可。其实就是LR(0)稍微改改。</p>\n<p>考虑每次规约，都会使用一个产生式 $E\\rightarrow \\alpha$<br>“LR分析是最右推导的逆过程”，因此每步归约都应该满足：<br>$$ t \\in \\text{Follow}(E) $$其中t指的是<strong>输入流中下一个token</strong>, E指的是用于<strong>此规约用到的产生式的左部(LHS)</strong>.<br>因此对于SLR文法来说，SLR的DFA和LR(0)一样；但LR(0)的分析表中有一些$r_n$是非法的，需要删去。<br>在生成分析表的具体步骤上：</p>\n<ul>\n<li>LR(0)的某些状态包含可规约的Item，那么这个状态I在对应的Action表中T[I,_]这一行的每一个格子（无论终结符t是什么）无论如何都会有对应的$r_n$项</li>\n<li>SLR会关心后面的终结符是什么，因此如果t不在Follow集中，这不能是一个合法的规约，Action表对应的t列就不会有这个$r_n$</li>\n</ul>\n<p>例如，图中被划去的部分即为从LR(0)分析表到SLR分析表的变化：<br><img src=\"/compiler-construction-principles/slr-table.png\" alt=\"SLR分析表：删去了部分规约项\" loading=\"lazy\"></p>\n<p>规约的条件更严格，也就“自动”消除了一些冲突，也就允许了更多语言被纳入该文法，因此 $\\text{LR(0)} \\in \\text{SLR}$</p>\n<p><strong>局限性</strong>：显然不能消除所有shift-reduce冲突。如果产生冲突对应的终结符t恰好在Follow集里，就无法消除。例如考虑如下文法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">S&#x27; -&gt; S $</span><br><span class=\"line\">S -&gt; L = R</span><br><span class=\"line\">S -&gt; R</span><br><span class=\"line\">L -&gt; id</span><br><span class=\"line\">L -&gt; * R</span><br><span class=\"line\">R -&gt; L</span><br></pre></td></tr></table></figure>\n\n<p>由最后两条规则<code>L -&gt; * R</code> <code>R -&gt; L</code>可以看出Follow(R)与Follow(L)两个集合互相包含，即相等，即Follow(R)&#x3D;Follow(L)<br>然而’&#x3D;’在Follow(L)&#x3D;{<code>=</code>,<code>$</code>}中，因此我们遇到’L&#x3D;…’时仍然不知道应该接受等于号进行shift(这样就可以进一步在<code>S-&gt;L=R</code>这个产生式中前进)，还是直接使用<code>R-&gt;L</code>进行reduce.<br><img src=\"/compiler-construction-principles/slr-conflict.png\" alt=\"slr-conflict\" loading=\"lazy\"><br><img src=\"/compiler-construction-principles/slr-conflict-table.png\" alt=\"slr-conflict-table\" loading=\"lazy\"></p>\n<p>需要更多、更精确的限制才能进一步降低冲突的可能。</p>\n<h3 id=\"LR-1-Parsing\"><a href=\"#LR-1-Parsing\" class=\"headerlink\" title=\"LR(1) Parsing\"></a>LR(1) Parsing</h3><p>包含更多信息（后继token）来消除一些归约动作。<br>相当于“分裂”一些LR(0)状态，精确指明何时应该归约。</p>\n<p><strong>LR(1)项(item)的形式：$ A \\rightarrow \\alpha \\bullet \\beta,\\ a$</strong></p>\n<p>逗号后的a是 <strong>向前看符号(lookahead symbol)</strong> 即表明向前看一个终结符，可以是<code>$</code>.<br>和LR(0)对比，处理ε-move时记录合法的向前看符号w.</p>\n<p>各种计算：</p>\n<ul>\n<li><p>计算Closure<br>对于状态I中的一个item $$A\\rightarrow \\alpha \\bullet X \\beta,\\ z$$ 以及一个产生式 $$X\\rightarrow \\gamma$$<br>我们<strong>递归地</strong>寻找所有 $w\\in \\text{First}(\\beta z)$ 然后加入I：$I\\cup&#x3D;{(X\\rightarrow \\bullet \\gamma,\\ w) | \\forall w\\in \\text{First}(\\beta z) }$（直到不动点为止）<br>起始状态是 $S’\\rightarrow \\bullet S \\$,\\ ?$ 的闭包</p>\n<ul>\n<li>我们不关心”?”处是什么，因为永远不会移进<code>$</code>.<br>所以一种可行的表示是把<code>$</code>都移到产生式外部，而非真的要产生一个<code>$</code>符号： $S’\\rightarrow \\bullet S,\\ \\$$）<br>或者你也可以直接写作：$S’\\rightarrow \\bullet S\\$,\\ ?$ （推荐）</li>\n</ul>\n</li>\n<li><p>计算Goto表<br>基本和LR(0)算法保持相同，移入动作不考虑向前看符号z<br>也就是对于转移X，转移前后项的变换是：<br>$$A \\rightarrow \\alpha \\bullet X \\beta,\\ z \\ \\ \\Rightarrow\\ \\ A \\rightarrow \\alpha X \\bullet \\beta,\\ z$$</p>\n</li>\n<li><p>计算Action表：Reduce操作</p>\n<p>规约操作是变换较大的部分。<br>在LR(1)中，Action表项中Reduce操作形如$(I, z, A\\rightarrow \\alpha)$</p>\n<ul>\n<li>I: 代表状态I对应的行</li>\n<li>z: 代表向前看符号</li>\n<li>$ A\\rightarrow \\alpha $ 为规约所采用的产生式<br>这就限制了从某个可规约项规约时，必须向前看一个符号以确保它是lookahead symbol.</li>\n</ul>\n<p><img src=\"/compiler-construction-principles/lr1-items.png\" alt=\"lr1 items\" loading=\"lazy\"></p>\n</li>\n</ul>\n<p><strong>局限性</strong>：这样的文法限制过少，过于灵活，导致状态数量过多，状态表过于庞大。<br><img src=\"/compiler-construction-principles/lr1-con.png\" alt=\"lr1 con\" loading=\"lazy\"><br><img src=\"/compiler-construction-principles/lr1-dfa.png\" alt=\"lr1 dfa\" loading=\"lazy\"></p>\n<blockquote>\n<p>注：话虽如此，文法仍然可能因为R-R冲突与S-R冲突从而导致其不属于LR(1)！这样的例子可以在LR(k)且k&gt;1的文法中大量找到。</p>\n</blockquote>\n<p>因此我们在SLR(1)&#x3D;Simple LR(1)与LR(1)之间折中，可以得到一个新文法LALR(1).</p>\n<h3 id=\"LALR-1-Parsing\"><a href=\"#LALR-1-Parsing\" class=\"headerlink\" title=\"LALR(1) Parsing\"></a>LALR(1) Parsing</h3><p>LALR &#x3D; Look-Ahead LR</p>\n<p>动机：发现很多LR(1)中的状态都只有lookahead symbol的区别。能否合并？</p>\n<p><strong>LALR(1): 把LR(1)中只有lookahead symbol不同的item合并。</strong></p>\n<p>定义：把LR(1)中item的集合里所有lookahead symbol去掉，剩下的称为<strong>核(core)</strong><br>把LR(1)中所有核相同的状态两两合并为一个状态。每次合并都删除两个旧状态，新增一个新状态，入边出边的连接方式是显然的，直接接在新状态上即可。<br>新状态的item是两个旧状态的item的并（其实就是把每个item的lookahead symbol合并一下）。</p>\n<p><img src=\"/compiler-construction-principles/lr1-lalr1.png\" alt=\"lr1 to lalr1\" loading=\"lazy\"></p>\n<p>这样得到的表将会小很多：与SLR的分析表<strong>一样大</strong>！通常状态数只有LR(1)的十分之一。付出的微小代价：规约-规约冲突(reduce-reduce conflict)<br>例如对于如下文法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">S -&gt; a E c</span><br><span class=\"line\">   | a F d</span><br><span class=\"line\">   | b F c</span><br><span class=\"line\">   | b E d</span><br><span class=\"line\">E -&gt; e</span><br><span class=\"line\">F -&gt; e</span><br></pre></td></tr></table></figure>\n\n<p>在LALR分析表中有两个状态会被合并成一个。而之后的下个字符将会出现歧义。这个冲突对应的状态：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">E -&gt; e, &#123;c,d&#125;</span><br><span class=\"line\">F -&gt; e, &#123;c,d&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>LR(1)分析器：将产生两个不同的状态(图中的状态#6与#9)，不会产生冲突：<img src=\"/compiler-construction-principles/lr1-eg.png\" alt=\"lr1 example\" loading=\"lazy\"></li>\n<li>LALR(1)分析器：只会产生一个状态，产生冲突<ul>\n<li>若下个输入字符为c或d，可以归约成E或F</li>\n</ul>\n</li>\n</ul>\n<p>因此，上述文法对于LALR(1)是二义的。<br>但这是可以接受的：LALR(1)足以处理绝大部分程序设计语言。</p>\n<h2 id=\"Part-6-语法分析杂项\"><a href=\"#Part-6-语法分析杂项\" class=\"headerlink\" title=\"Part 6: 语法分析杂项\"></a>Part 6: 语法分析杂项</h2><h3 id=\"语法分析器的生成器：YACC\"><a href=\"#语法分析器的生成器：YACC\" class=\"headerlink\" title=\"语法分析器的生成器：YACC\"></a>语法分析器的生成器：YACC</h3><p>Yacc &#x3D; yet another compiler-compiler:</p>\n<ul>\n<li>基于LALR(1)</li>\n<li>BNF(Backus Naur Form)范式</li>\n<li>GNU版本名为<em>Bison</em></li>\n<li>流程：<ol>\n<li>Yacc源程序(*.y) &gt;&gt; Yacc Compiler &gt;&gt; C语言实现的LALR分析器(y.tab.c)</li>\n<li>y.tab.c &gt;&gt; C Compiler &gt;&gt; 分析器可执行文件(<em>.exe&#x2F;</em>.out)</li>\n<li>输入 &gt;&gt; 分析器可执行文件 &gt;&gt; 输出</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li><p>Lex</p>\n<ul>\n<li>一种词法分析器的生成器，将词法转化为词法解析器yylex()</li>\n<li>Yacc生成的yyparse()可以接受yylex()进而生成语法分析器</li>\n</ul>\n</li>\n<li><p>Yacc源程序结构</p>\n<ul>\n<li>声明<ul>\n<li>C语言的声明</li>\n<li>词法单元的声明</li>\n</ul>\n</li>\n<li>翻译规则<ul>\n<li>产生式</li>\n<li>产生式相关语义动作（例如编译时计算）</li>\n</ul>\n</li>\n<li>辅助性C语言例程<ul>\n<li>直接拷贝到生成的*.tab.c中</li>\n<li>可以在语义动作中调用</li>\n<li>Lex生成的yylex()就是其中之一，可以返回词法单元</li>\n</ul>\n</li>\n</ul>\n<p> 例如，对于示例文法：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exp → exp addop term | term</span><br><span class=\"line\">addop → + | -</span><br><span class=\"line\">term → term mulop factor | factor</span><br><span class=\"line\">mulop → *</span><br><span class=\"line\">factor → ( exp ) | number</span><br></pre></td></tr></table></figure>\n\n<p> 有示例程序：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%&#123;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;ctype.h&gt;</span><br><span class=\"line\">int yylex(void);</span><br><span class=\"line\">int yyerror (char * s);</span><br><span class=\"line\">%&#125;</span><br><span class=\"line\">%token NUMBER</span><br><span class=\"line\">%%</span><br><span class=\"line\">command: exp &#123;printf(&quot;%d\\n&quot;, $1);&#125;;</span><br><span class=\"line\">exp: exp &#x27;+&#x27; term &#123;$$ = $1 + $3;&#125;</span><br><span class=\"line\">  | exp &#x27;-&#x27; term &#123;$$ = $1 - $3;&#125;</span><br><span class=\"line\">  | term &#123;$$ = $1&#125;</span><br><span class=\"line\">;</span><br><span class=\"line\">term: term &#x27;*&#x27; factor &#123;$$ = $1 * $3;&#125;</span><br><span class=\"line\">    | factor &#123;$$ = $1;&#125;</span><br><span class=\"line\">;</span><br><span class=\"line\">factor: NUMBER &#123;$$ = $1;&#125;</span><br><span class=\"line\">      | &#x27;(&#x27; exp &#x27;)&#x27; &#123;$$ = $2;&#125;</span><br><span class=\"line\">;</span><br></pre></td></tr></table></figure>\n\n<p> 其中翻译规则Rule的格式为 <code>Rule &#123;Action Code&#125;</code>，使用规则规约后Action Code就会被执行<br> 语义动作形如 <code>$$ = $1 + $3</code></p>\n<ul>\n<li><code>$$</code> 表示和产生式头(LHS)相关的属性值</li>\n<li><code>$i</code> 表示产生式体中第i个文法符号（终结符&#x2F;非终结符）的属性值</li>\n</ul>\n</li>\n<li><p>消除二义性与解决冲突</p>\n<ul>\n<li>消除二义性：<ul>\n<li>指定运算符优先级：先出现的优先</li>\n<li>指定运算符结合律：<code>%left</code>（左结合，例如乘法加法） <code>%right</code>（右结合，例如一元运算符负号）</li>\n</ul>\n</li>\n<li>冲突解决<ul>\n<li>规约-规约冲突：先出现的产生式优先采用</li>\n<li>移进-规约冲突：移进优先采用</li>\n</ul>\n</li>\n<li>更通用的方法：通过改写文法，可以在消除冲突的同时减少二义性</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"错误恢复（续）\"><a href=\"#错误恢复（续）\" class=\"headerlink\" title=\"错误恢复（续）\"></a>错误恢复（续）</h3><p>动机：一次性报告所有错误，而非遇到第一个就停下。</p>\n<ul>\n<li>局部错误恢复：调整Parse过程的栈，使其恢复到正常从而继续进行Parsing</li>\n<li>全局错误恢复：删除&#x2F;插入尽可能少的字符，使得源字符串成为合法的字符串</li>\n</ul>\n<ol>\n<li><p>局部错误恢复<br> Yacc中的一个方法：使用特殊的<code>error</code>符号（终结符）控制恢复过程。<br> 例如：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exp -&gt; ( error )</span><br><span class=\"line\">exp -&gt; error ; exp</span><br></pre></td></tr></table></figure>\n\n<p> 于是通过这样的产生式，我们可以把错误的影响范围控制在右括号处&#x2F;分号处。如果语法处理时遇到错误，可以一路跳过直到右括号和分号，然后继续处理。<br> 分号、右括号这样的符号就被叫做synchronizing token.</p>\n<p> 当语法分析器遇到错误时：</p>\n<ul>\n<li>不断弹出栈中状态，直到栈顶状态包含项 $ A \\rightarrow \\bullet error\\ \\alpha$</li>\n<li>分析器将error移入栈中</li>\n<li>如果α为空，分析器直接执行归约，并调用相关的语义动作；否则跳过一些符号，找到可以归约为α的串为止</li>\n</ul>\n<p> 流程示例：<br> <img src=\"/compiler-construction-principles/local-recovery.png\" alt=\"local error recovery\" loading=\"lazy\"></p>\n</li>\n<li><p>*全局错误恢复<br> <strong>不要求掌握。</strong><br> Burke-Fisher 错误恢复: 对于在发生错误处之前的K个token，每一处都允许插入&#x2F;删除&#x2F;修改一个token，直到修复成功。<br> 优势：</p>\n<ul>\n<li>不引入新产生式，不改变文法</li>\n<li>也不改变分析表</li>\n</ul>\n<p> 如何判定修复是否成功：修复后，在报告错误处继续Parsing直到下一个错误发生的距离最长（一般来说，修复后能从本来由于错误卡住的地方继续前进4个token就算成功了）。</p>\n<p> 实现：维护K个token前的旧栈，以及K个token组成的队列。遇到错误后基于旧栈和增删改后的token队列（不一定是K个了）试图parse. 尝试不同的增删改方案直到修复成功：<br> <img src=\"/compiler-construction-principles/burke-fisher.png\" alt=\"burke-fisher\" loading=\"lazy\"></p>\n<p> 语义动作需要延迟到进入旧栈中（进入旧栈说明在解析流程中已经确定了）再进行</p>\n<ul>\n<li>否则如果遇到错误，错误恢复发现原来的parsing方式不对时，文法符号的属性已经按照错误的方式运算了，回天乏术。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"语法分析小结：文法对比\"><a href=\"#语法分析小结：文法对比\" class=\"headerlink\" title=\"语法分析小结：文法对比\"></a>语法分析小结：文法对比</h2><h3 id=\"SLR-与-LR-1\"><a href=\"#SLR-与-LR-1\" class=\"headerlink\" title=\"SLR 与 LR(1)\"></a>SLR 与 LR(1)</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>SLR</th>\n<th>LR(1)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>移   进</td>\n<td>$ A\\rightarrow \\alpha \\bullet a \\beta \\in I_i \\\\ \\text{Goto}(I_i,a)&#x3D;I_j \\\\ \\text{Action}[i,a]&#x3D;s_j $</td>\n<td>$ A\\rightarrow \\alpha \\bullet a \\beta \\in I_i \\\\ \\text{Goto}(I_i,a)&#x3D;I_j \\\\ \\text{Action}[i,a]&#x3D;s_j $</td>\n</tr>\n<tr>\n<td>—</td>\n<td>—</td>\n<td>—</td>\n</tr>\n<tr>\n<td>规   约</td>\n<td>$ A\\rightarrow \\alpha \\bullet \\in I_i \\\\ \\alpha \\in \\text{Follow}(A) \\\\ \\text{Action}[i,a]&#x3D;r_j$</td>\n<td>$ A\\rightarrow \\alpha \\bullet \\in I_i \\\\ \\text{Action}[i,a]&#x3D;r_j $</td>\n</tr>\n</tbody></table>\n<p>可见唯一的区别就是SLR在规约时要求后继token是在Follow集里的。</p>\n<h3 id=\"LL-1-与-LR-1\"><a href=\"#LL-1-与-LR-1\" class=\"headerlink\" title=\"LL(1) 与 LR(1)\"></a>LL(1) 与 LR(1)</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>LR(1)</th>\n<th>LL(1)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>建立分析树</td>\n<td>自底而上</td>\n<td>自顶而下</td>\n</tr>\n<tr>\n<td>归约or推导</td>\n<td>规范归约(最右推导的逆)</td>\n<td>最左推导</td>\n</tr>\n<tr>\n<td>分析表（行x列）</td>\n<td>状态×文法符号，大</td>\n<td>非终结符×终结符，小</td>\n</tr>\n<tr>\n<td>分析栈</td>\n<td>状态栈，信息更多</td>\n<td>文法符号栈</td>\n</tr>\n</tbody></table>\n<ul>\n<li>LL(1): 对于多个可选产生式 $A\\rightarrow \\alpha_1|\\alpha_2|…$ 向前看下一个输入根据First,Follow确定使用哪条产生式推导</li>\n<li>LR(1): 对于多个可选产生式 $A\\rightarrow \\alpha,\\ B\\rightarrow \\alpha,… $ 在识别出整个$\\alpha$后，再往前看1个符号，然后确定使用哪条产生式归约</li>\n</ul>\n<h3 id=\"LL-1-LR-1-SLR\"><a href=\"#LL-1-LR-1-SLR\" class=\"headerlink\" title=\"LL(1) LR(1) SLR\"></a>LL(1) LR(1) SLR</h3><p><img src=\"/compiler-construction-principles/grammar-compare.png\" alt=\"grammar-compare\" loading=\"lazy\"></p>\n<h2 id=\"Part-7-抽象语法\"><a href=\"#Part-7-抽象语法\" class=\"headerlink\" title=\"Part 7: 抽象语法\"></a>Part 7: 抽象语法</h2><p>编程语言 &#x3D; 语法（识别一个合法的程序） + 语义（这个合法的程序对应的实际行为）</p>\n<ul>\n<li>语法：已经在之前章节讨论过。</li>\n<li>语义：<ul>\n<li>操作语义：如何执行程序？</li>\n<li><del>公理语义：可以证明程序的那些性质？</del> （该部分不在本课讨论）</li>\n<li>指称语义：程序是做什么的？</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"属性文法Attribute-Grammar\"><a href=\"#属性文法Attribute-Grammar\" class=\"headerlink\" title=\"属性文法Attribute Grammar\"></a>属性文法Attribute Grammar</h3><p>属性文法&#x3D;<strong>上下文无关文法+属性+属性计算规则</strong></p>\n<ul>\n<li>属性:&#x3D; 描述文法符号的语义特征，比如表达式E的值可以记为E.val</li>\n<li>属性计算规则(语义规则):&#x3D; 与产生式相关联、反映文法符号属性之间关系的规则，比如在乘法表达式中左侧的E.val要如何计算<ul>\n<li>仅表明属性间“抽象”关系，不涉及计算次序等具体实现细节</li>\n</ul>\n</li>\n<li>应用：<ul>\n<li>“推导类”：例如很多语言的<strong>编译期求值</strong></li>\n<li>“生成类”：生成AST， 中间代码等</li>\n<li>…</li>\n</ul>\n</li>\n<li>实现：例如在先前章节中Yacc等Parser生成器的<strong>语义动作</strong></li>\n</ul>\n<h3 id=\"语义动作Semantic-Action\"><a href=\"#语义动作Semantic-Action\" class=\"headerlink\" title=\"语义动作Semantic Action\"></a>语义动作Semantic Action</h3><p>我们可以给产生式绑定一个语义动作，使得按照这个产生式规约时&#x2F;推导时完成特定操作。</p>\n<p>每个token都可能有独属于自己的 <strong>语义值(Semantic Value)</strong> 。每种token的语义值类型可以不同，我们把A的语义值的类型称为“A的关联类型”。<br>例如对于产生式 $A\\rightarrow B\\ C\\ D$</p>\n<ul>\n<li>语义动作返回值必须是<em>A的关联类型</em></li>\n<li>这个值可以通过B C D各自的语义值进行运算得出</li>\n</ul>\n<p>例如通过如下语义动作可以在编译期直接evaluate表达式的值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">E-&gt;E1 + T   &#123; E.val= E1.val + T.val &#125;</span><br><span class=\"line\">E-&gt;E1 – T   &#123; E.val= E1.val - T.val &#125;</span><br><span class=\"line\">E-&gt;T        &#123; E.val= T.val &#125;</span><br><span class=\"line\">T-&gt;(E)      &#123; T.val= E.val &#125;</span><br><span class=\"line\">T-&gt;num      &#123; T.val= num.val &#125;</span><br></pre></td></tr></table></figure>\n\n<p>在递归下降法中，语义动作体现为每个符号对应的parsing函数。这里我们同时关心函数的<strong>返回值</strong>与<strong>副作用</strong>。<br>因此假设T和F两个token的关联类型都是<code>int</code>，对于表达式 $T\\rightarrow T * F$ 可以如此实现语义动作：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> a= T();</span><br><span class=\"line\">eat(TIMES); <span class=\"comment\">// &#x27;*&#x27;</span></span><br><span class=\"line\"><span class=\"type\">int</span> b= F();</span><br><span class=\"line\"><span class=\"keyword\">return</span> a*b;</span><br></pre></td></tr></table></figure>\n\n<p>而对于Parser生成器来说，其实现方式有所不同，以Yacc为例：</p>\n<ul>\n<li>用一个栈储存语义值，这个栈和状态栈是同步的</li>\n<li>当进行<strong>规约</strong>操作时，需要执行相应的语义动作（C语言实现）<ul>\n<li>可能用到的值一定可以通过多次pop语义值栈获得（和状态栈pop同步）</li>\n<li>pop完毕后运算得到的新值压入该栈（和状态栈压入新状态同步）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"抽象解析树APT\"><a href=\"#抽象解析树APT\" class=\"headerlink\" title=\"抽象解析树APT\"></a>抽象解析树APT</h3><p>APT &#x3D; Abstract Parse Tree 是语义动作的一种应用。</p>\n<blockquote>\n<p>⚠和抽象语法树(Abstract Syntax Tree)的区别请参阅<a href=\"https://stackoverflow.com/questions/5026517/whats-the-difference-between-parse-trees-and-abstract-syntax-trees-asts\">https://stackoverflow.com/questions/5026517/whats-the-difference-between-parse-trees-and-abstract-syntax-trees-asts</a></p>\n</blockquote>\n<p>能否<strong>通过描述语义动作直接实现整个编译器</strong>？可以，但是难以维护，且必须保证这些语义值的计算顺序和Parsing顺序完全一致。</p>\n<ul>\n<li>考虑分离语法解析（Parsing）和语义动作：一个可行方案是Parsing得到树，而后遍历以进行语义相关的操作。</li>\n</ul>\n<p>我们可以很容易得到一棵树：叶节点对应输入的token，内部节点对应一个语法规则。这被称为<strong>concrete parse tree</strong>.<br><img src=\"/compiler-construction-principles/concrete-pt.png\" alt=\"concrete-pt\" loading=\"lazy\"></p>\n<ul>\n<li>缺点：太“啰嗦”。例如括号相关产生式只是为了解析顺序正确才有的，没必要放进树里。</li>\n</ul>\n<h3 id=\"抽象语法树AST\"><a href=\"#抽象语法树AST\" class=\"headerlink\" title=\"抽象语法树AST\"></a>抽象语法树AST</h3><p>AST &#x3D; Abstract Syntax Tree<br>可以提供一个<em>干净的</em>（不包含Parsing的那些繁文缛节）接口用于后续编译流程的实现或优化（编译器后端）。</p>\n<p>生成方式：用<strong>具体语法</strong>（Parser生成器能懂的）为<strong>抽象语法</strong>（我们想要的、更可读的）生成抽象语法树：<br><img src=\"/compiler-construction-principles/AST.png\" alt=\"AST\" loading=\"lazy\"></p>\n<p>实现：</p>\n<ul>\n<li>为每一个非终结符定义一个类型声明，用于表示其关联类型。</li>\n<li>产生式统一放进一个union（如果是Rust就是Option直接解决，<del>C语言太坏了</del>）里，每一个产生式就是union里的一个结构体，这个结构体用于储存其子节点：<br><img src=\"/compiler-construction-principles/AST-def.png\" alt=\"AST definition\" loading=\"lazy\"></li>\n<li>为每个产生式定义一个函数，除了计算需要的语义值返回以外，还将申请空间、分配新的树节点并设置好其子节点：<br><img src=\"/compiler-construction-principles/AST-impl.png\" alt=\"AST implementation\" loading=\"lazy\"></li>\n<li>以Yacc为例，把这些函数放入对应产生式的语义动作块中即可在规约时自动调用。随着Parsing的逐步推进，每次规约都可以产生一个新的内部节点，最终逐步构建出整颗AST。</li>\n</ul>\n<p>此外，通过遍历AST还能做很多：</p>\n<ul>\n<li>通过一些“变形”缩小树的规模，减少最终代码的大小</li>\n<li>通过一些“变形”优化树的结构，提高最终代码的性能</li>\n<li>代码内联优化</li>\n<li>静态分析，编译期推导值</li>\n<li>类型系统检查等安全检查</li>\n<li>翻译到中间表示，虽然<strong>AST也常被视作一种“中间表示”</strong></li>\n</ul>\n<h3 id=\"位置Position\"><a href=\"#位置Position\" class=\"headerlink\" title=\"位置Position\"></a>位置Position</h3><p>在one-pass编译器中，词法分析、语法分析、语义分析是同步进行的。而错误发生时，<strong>词法分析器lexer</strong>的位置可以用来作为错误发生位置的合理估计反馈给用户。所以，lexer存有一个全局变量维护当前位置信息。</p>\n<p>然而，对于使用AST的编译器，词法分析结束后才开始语法分析，因此这是不可行的。<br>解决方案：AST每个节点记录自己在源文件中的<strong>位置</strong>，标记自己是具体哪几个字符派生而来的。</p>\n<ul>\n<li><p>lexer把每个token的起始位置、结束位置传递给parser</p>\n</li>\n<li><p>parser维护<em>位置栈</em>与<em>语义值栈</em>，这样语义操作就知道位置信息了</p>\n<ul>\n<li>不是所有的Parser生成器都可以做到这一点：例如Bison可以但Yacc不行</li>\n<li>对于Yacc等无法直接实现的，可以引入新的非终结符pos（其语义值包含需要的位置信息）并改写文法。例如可以如此改写PLUS表达式以利用位置信息：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%&#123; extern A_OpExp(A_exp, A_binop, A_exp, position); %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">%union &#123;</span><br><span class=\"line\">    int num;</span><br><span class=\"line\">    string id;</span><br><span class=\"line\">    position pos;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">%type &lt;pos&gt; pos</span><br><span class=\"line\"></span><br><span class=\"line\">pos: &#123; $$ = EM_tokpos; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">exp: exp PLUS pos exp &#123; $$ = A_OpExp($1, A_plus, $4, $3); &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"Part-8-语义分析\"><a href=\"#Part-8-语义分析\" class=\"headerlink\" title=\"Part 8: 语义分析\"></a>Part 8: 语义分析</h2><p>注意到：上述的属性文法等内容只适用于上下文无关文法CFG.<br>然而CFG有很多不足，例如不可能完成：</p>\n<ul>\n<li>检查数组引用的维度是否匹配</li>\n<li>检查数组越界</li>\n<li>确定变量应储存于栈上还是堆上</li>\n<li>…</li>\n</ul>\n<p>这是因为，这些检查和值有关（涉及语义），而非语法本身。因此我们需要通过检查、遍历 <strong>程序表示(Program Representation)</strong> 来完成 <strong>（广义的）语义分析</strong>。<br>常用的程序表示：</p>\n<ul>\n<li>abstract syntax tree (AST)</li>\n<li>control flow graph (CFG)</li>\n<li>programdependence graph (PDG)</li>\n<li>valueflowgraph (VFG)</li>\n<li>single static assignment (SSA)</li>\n</ul>\n<p>然后我们就可以：</p>\n<ul>\n<li>类型检查</li>\n<li>代码生成</li>\n<li>去除dead code</li>\n<li>寄存器分配</li>\n<li>…</li>\n</ul>\n<p>本课重点关注的（狭义的）语义分析指的是通过检查AST获知程序的静态属性，包括：</p>\n<ul>\n<li>作用域(Scope)与变量可见性</li>\n<li>变量、函数、表达式的类型<br>以及将AST转为中间代码(Intermediate Code)</li>\n</ul>\n<h3 id=\"符号表Symbol-Table\"><a href=\"#符号表Symbol-Table\" class=\"headerlink\" title=\"符号表Symbol Table\"></a>符号表Symbol Table</h3><p>Binding:&#x3D; 把类型、值等信息绑定到一个identifier上<br>Environment:&#x3D; 一些绑定的集合，体现了程序当前环境下已声明的一些变量&#x2F;函数&#x2F;…</p>\n<p><strong>符号表</strong>就是Environment的一种实现方式。我们在遍历AST的过程中可以维护一个符号表用于语义分析。<br>符号表中的重要组成部分就是各个局部变量及其作用域。当退出作用域时，自然就需要丢弃内部的一些binding.<br>变量在scope内重新定义时需要覆盖（屏蔽）掉更大作用域的，退出时则还原。<br>因此可见我们需要为符号表实现的接口包括：</p>\n<ul>\n<li>insert: 将名称绑定到相关信息(type, value, …), 且将覆盖已有的绑定关系（如果存在）</li>\n<li>lookup: 用名称查找信息</li>\n<li>beginScope: 进入作用域</li>\n<li>endScope: 退出作用域，将符号表恢复到进入之前的状态</li>\n</ul>\n<p>在Java等语言中，可能有多个环境同时活跃（对应不同的module, class等），他们都需要一个符号表。这被称为多符号表。</p>\n<ul>\n<li>符号表的实现：<br>绑定时，如果遇到了符号已经存在的情况，有两种策略：<ul>\n<li>Imperative Style: 直接覆盖旧的绑定，这样就不可能lookup到旧的信息。当这个新的绑定不再有效时，需要复原旧的绑定。<ul>\n<li>如何快速lookup且支持删除和复原(restore): 使用哈希表套链表储存每对binding. 我们称哈希表中的元素为bucket.</li>\n<li>insert: 直接插入对应bucket的链表头。如果已经存在，由于这使得新的binding关系更靠前，这样做可以成功覆盖。</li>\n<li>restore: 对应bucket的链表头弹出头部的一些元素。</li>\n<li>我们会发现需要维护一些必要的额外信息（比如scope变化时应该要弹出几次）。</li>\n</ul>\n</li>\n<li>Functional Style: 永远保留老的，只是查询时做一些额外处理（可以理解为只是renaming）。这样还原更简单。<ul>\n<li>直接使用BST（红黑树等）实现查找。</li>\n<li>可以使用可持久化数据结构完成删除、复原等操作，进一步降低单次操作的空间复杂度，非常方便。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>两种方法均可使用。</p>\n<h3 id=\"Tiger编译器符号相关的实现\"><a href=\"#Tiger编译器符号相关的实现\" class=\"headerlink\" title=\"Tiger编译器符号相关的实现\"></a>Tiger编译器符号相关的实现</h3><p>在哈希表中的链表进行lookup时，不断进行字符串比较是很耗时的。</p>\n<ul>\n<li>解决办法：使用新的数据结构将符号对象关联到一个整数上（哈希值）</li>\n</ul>\n<p>Tiger编译器的environment是destructive-update的。也就是说，有两个函数：</p>\n<ul>\n<li><code>S_beginScope</code>: 记下当前符号表的状态</li>\n<li><code>S_endScope</code>: 恢复到最近的、还未被恢复的<code>S_beginScope</code>记下的状态</li>\n</ul>\n<p>我们引入一个 <strong>辅助栈(Auxiliary stack)</strong> 来维护上文提到的必要的额外信息:</p>\n<ul>\n<li>符号入栈时，会将binding联动地插入对应bucket的链表头</li>\n<li>弹出栈顶符号时，对应bucket的链表头也会联动地被移除</li>\n<li>beginScope: 压入一个特殊标记到辅助栈中</li>\n<li>endScope: 一直弹出符号直到弹出了一个特殊标记<ul>\n<li>可以由此标记推断：此次因为退出scope引发的restore操作可以就此结束</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"类型检查\"><a href=\"#类型检查\" class=\"headerlink\" title=\"类型检查\"></a>类型检查</h3><ol>\n<li><p>类型系统</p>\n<p> 类型限定了变量的取值范围以及部分运算规则。<br> 可以大致把编程语言分为：</p>\n<ul>\n<li>类型化的(typed): C&#x2F;C++ Java Go</li>\n<li>非类型化的(untyped): LISP JavaScript<ul>\n<li>注意：不是没有类型，而是类型可变</li>\n</ul>\n</li>\n</ul>\n<p> 类型系统作用：</p>\n<ul>\n<li>提高开发效率（高层抽象&amp;指称语义）</li>\n<li>提高运行性能（指导编译优化）</li>\n<li>提高安全性（内存安全等）</li>\n<li>…</li>\n</ul>\n<blockquote>\n<p>事实上，可以理解为每引入一种类型就能<strong>完全</strong>消除某一类特定错误。</p>\n</blockquote>\n<p> 形式化的类型系统可用于数学领域，参见Coq以及<a href=\"https://leanprover-community.github.io/\">LEAN</a></p>\n</li>\n<li><p>Tiger的类型系统<br> 包含：</p>\n<ul>\n<li>原始类型(primitive type): <code>int</code>和<code>string</code></li>\n<li>构造类型(constructed type): <code>record</code>（类似结构体） 和<code>array</code></li>\n</ul>\n<p> 根据不同的判别法，<strong>类型等价</strong>这一关系分为：</p>\n<ul>\n<li>Name equivalence (NE): 必须声明是同一个类型才是同一类型</li>\n<li>Structure equivalence (SE): “长得一样”（内部结构一样）就是同一类型</li>\n</ul>\n<p> 显然前者被广泛采用，Tiger语言也不例外。<br> Tiger存在两个独立的命名空间，不同命名空间的同名identifier不会互相遮蔽(hide)对方：</p>\n<ul>\n<li>Types</li>\n<li>Functions and variables</li>\n</ul>\n</li>\n<li><p>Tiger的类型检查</p>\n<p>Tiger的语义分析需要两个环境：</p>\n<ul>\n<li><p><code>Type</code>: 把类型符号映射到其表示的具体类型对应的数据结构</p>\n<ul>\n<li>初始时包含primitive type对应的映射 int $\\mapsto$ Ty_int, string $\\mapsto$ Ty_string</li>\n</ul>\n</li>\n<li><p><code>Value</code>: 把变量名映射到具体类型，把函数名映射到(参数类型, 返回值类型)（也就是函数签名）</p>\n<ul>\n<li>初始时包含Tiger中预定义的一些函数定义</li>\n</ul>\n</li>\n</ul>\n<p><code>semant</code> 模块包含类型检查等语义分析相关操作。类型检查分为两部分：</p>\n<ul>\n<li>Type-checking expressions<ul>\n<li><code>transExp</code>可以在给定的两个环境下将输入的表达式标记上type（如果发现非法则报错）</li>\n</ul>\n</li>\n<li>Type-checking declarations<ul>\n<li>在Tiger语言中声明只可能在<code>let</code>语句中出现</li>\n<li>变量声明：如果提供了变量类型，则检查初始化表达式类型是否匹配；否则直接通过初始化表达式类型获得变量类型</li>\n<li>类型声明：<strong>递归地</strong>获取类型别名对应的实际类型。<ul>\n<li>Q: 如何处理递归声明 <code>type list = &#123;first: int, rest: list&#125;</code>？A: 不使用one-pass而是two-pass: pass#1: 记录声明头部（左侧）放入环境；pass#2: 完成</li>\n<li>不允许类型的直接循环引用(<code>type a=b;type b=a</code>)：必须通过record或array完成(<code>type a=b;type b=&#123;i:a&#125;</code>)</li>\n</ul>\n</li>\n<li>函数声明：检查形参、返回值与函数体<ul>\n<li>Q: 如何处理递归声明？A: 不使用one-pass而是two-pass: pass#1: 记录函数声明（签名）放入环境；pass#2: 处理函数题</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<blockquote>\n<p><strong>!!!以上所有内容为期中考覆盖范围</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"Part-9-活动记录Activation-Record\"><a href=\"#Part-9-活动记录Activation-Record\" class=\"headerlink\" title=\"Part 9: 活动记录Activation Record\"></a>Part 9: 活动记录Activation Record</h2><blockquote>\n<p>其实Activation Record就是栈帧Stack Frame</p>\n</blockquote>\n<h3 id=\"Why-How\"><a href=\"#Why-How\" class=\"headerlink\" title=\"Why &amp; How\"></a>Why &amp; How</h3><p>编译过程需要区分代码（由PC寄存器指向）与数据。</p>\n<ul>\n<li>高地址向低地址增长：栈Stack</li>\n<li>低地址向高地址增长：堆Heap</li>\n<li>低地址：静态数据（代码+全局变量）</li>\n</ul>\n<p>递归&#x2F;调用子函数时需要在<strong>栈帧</strong>存放当前函数的上下文信息：</p>\n<ul>\n<li>调用的参数</li>\n<li>局部变量</li>\n<li>子函数执行完毕后的返回地址</li>\n<li>…</li>\n</ul>\n<p>主要寄存器：</p>\n<ol>\n<li>Frame Pointer&#x2F;Base Pointer 基址寄存器</li>\n<li>Stack Pointer 栈顶寄存器<br>例如f()中调用g():<br><img src=\"/compiler-construction-principles/ar-entering.png\" alt=\"ar-entering\" loading=\"lazy\"><br>然后g()执行完毕返回f()继续执行：<br><img src=\"/compiler-construction-principles/ar-exiting.png\" alt=\"ar-exiting\" loading=\"lazy\"></li>\n</ol>\n<blockquote>\n<p>所以子函数是通过基址寄存器向高地址，越过返回地址获取自己的参数。</p>\n</blockquote>\n<p>思考：为什么不开启优化的时候如下的写法可以“返回”值？</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"type\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"type\">int</span> var=num+<span class=\"number\">1</span>;</span><br><span class=\"line\"> <span class=\"comment\">// no return!</span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"type\">int</span> a = <span class=\"built_in\">foo</span>(<span class=\"number\">114514</span>);</span><br><span class=\"line\"> cout&lt;&lt; a &lt;&lt;endl; <span class=\"comment\">// 114515</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>答案：如果有return语句，返回值会被push到栈帧。<br>但是这里并没有return语句，所以本来是返回值的位置就被栈帧里最后一个（也是唯一一个）局部变量<code>var</code>给“冒充”了。<br>当然这是UB, 不能保证这种行为的可重复性（例如开启高优化级别时，这个现象很容易就被优化坏了，只留下一个0）。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>基址寄存器&#x3D;FP<br>栈顶寄存器&#x3D;SP<br>如果f调用g(a1, a2, …):</p>\n<ul>\n<li>SP指向第一个参数a1</li>\n<li>SP减去栈帧大小（向低地址增长）得到FP<br>进入g:</li>\n<li>将旧的FP压入栈</li>\n<li>令新的FP&#x3D;SP</li>\n<li>g可以基于FP向高地址获取参数，或向低地址压入&#x2F;查询局部变量<br>从g退出：</li>\n<li>返回值拷贝至特殊寄存器</li>\n<li>SP&#x3D;FP（释放g的栈帧）</li>\n<li>从栈上取回旧的FP值到FP中</li>\n</ul>\n<h2 id=\"Part-10-寄存器与变量\"><a href=\"#Part-10-寄存器与变量\" class=\"headerlink\" title=\"Part 10: 寄存器与变量\"></a>Part 10: 寄存器与变量</h2><p>Intuition: 内存太慢了，使用层次化的储存提高速度(Regs-L1-L2-L3-Mem-Disks…)<br>所以其实并不是所有参数&#x2F;局部变量都要放栈上，有时直接通过寄存器传参&#x2F;保存局部变量即可。<br>Tiger语言：默认按值传递，函数内部改变不影响外部值<br><em>注：函数&#x2F;过程这两个词可以混用，是一个含义。</em></p>\n<h3 id=\"局部变量\"><a href=\"#局部变量\" class=\"headerlink\" title=\"局部变量\"></a>局部变量</h3><p>调用函数需要保护现场：因为寄存器的值可能会被子函数改变，返回时“现场已经被破坏”。为此部分寄存器的值需要在栈上进行备份。分为以下两种：</p>\n<ul>\n<li>Caller-save: 例如临时寄存器，调用者如果用到则需要自己保存，子函数可以任意修改</li>\n<li>Callee-save: 例如FP&#x2F;SP, 由子函数负责保存与恢复（进入子函数时push到栈，退出时从栈里pop），调用者无需关心</li>\n</ul>\n<h3 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h3><p>函数调用传参：大部分现代编译器对于前几个参数直接通过寄存器传递，多余的则仍然通过栈完成传递。<br>但是物理寄存器的数量是有限的：假设有如下调用链f(x)-&gt;g(y)-&gt;h(z), 如果所有函数都通过寄存器<code>r1</code>接收参数，则f调用g(y)时要备份<code>r1</code>，再将<code>r1</code>设为要传给g的参数y.<br>因此，每个函数都要将<code>r1</code>在栈上备份，带来额外的内存traffic。<br>优化策略：</p>\n<ul>\n<li>从变量生命周期入手：如果寄存器对应的变量&#x2F;参数在当前函数不再使用，子函数覆盖了自然也无妨</li>\n<li>全局寄存器分配策略：每个函数使用不同的一组寄存器传参</li>\n<li>优化叶过程(Leaf Procedure)：如果某函数不调用任何其他过程，自然也不需要为（不存在的）子过程备份传入的参数</li>\n<li>寄存器窗口Register Windows: 每次调用函数时，尽可能利用尚未用到的寄存器，然后为子函数分配新的一套可用的寄存器（SPARC采用该策略）</li>\n</ul>\n<h3 id=\"返回值与返回地址\"><a href=\"#返回值与返回地址\" class=\"headerlink\" title=\"返回值与返回地址\"></a>返回值与返回地址</h3><ul>\n<li><p>返回地址:<br>Tl;DR: 函数调用<code>call</code>指令地址为a，则函数调用完毕应返回至地址a+1<br>现代机器基本将该地址保存在一个指定(designated)寄存器中。非叶过程需要在调用时把该值写入栈上，叶过程则不必。</p>\n</li>\n<li><p>返回值：</p>\n<ul>\n<li>如果可以则放置在指定寄存器中（例如X86-64使用<code>rax</code>）。</li>\n<li>如果不可以（如：返回对象太大），一般来说调用者会在自己栈帧开一个临时空间，然后将地址作为一个隐藏的参数传递给被调用函数。这样被调用方可以直接在这个空间上储存返回值，最后用寄存器（比如<code>eax</code>&#x2F;<code>rax</code>）把返回值所在地址告诉调用者。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>关于局部变量、表达式中间值如何尽可能地利用寄存器储存，尽量减少内存traffic，以后会在<em>寄存器分配</em>部分详细阐述。</p>\n<h3 id=\"Frame-Resident-Variables\"><a href=\"#Frame-Resident-Variables\" class=\"headerlink\" title=\"Frame-Resident Variables\"></a>Frame-Resident Variables</h3><p>寄存器并非万能：有时，在栈上分配空间（实体化）是不可避免的。例如：</p>\n<ul>\n<li>对象过大，无法放在寄存器中</li>\n<li>数组对象，需要通过地址偏移访问</li>\n<li>寄存器被特殊需要，例如上文提到可能用于传参</li>\n<li>太多中间值&#x2F;局部变量，有限的寄存器放不下<ul>\n<li>称为 <strong>“Spill”</strong> 了, 在寄存器分配部分会展开讨论<br>以及有时变量“逃逸(escape)”了（也就是脱离了当前scope&#x2F;无法确定变量有效的生命周期）：</li>\n</ul>\n</li>\n<li>引用传参：需要内存地址（虽然对于现代语言经过优化并不总是需要一个地址）</li>\n<li>显式地取变量地址（C语言等）</li>\n<li>被嵌套函数访问（Tiger语言不需要考虑）</li>\n</ul>\n<p>这些变量就是 <em>frame-resident</em> 的，也就是它们不得不被分配在栈帧上。</p>\n<h2 id=\"Part-11-块结构Block-Structure\"><a href=\"#Part-11-块结构Block-Structure\" class=\"headerlink\" title=\"Part 11: 块结构Block Structure\"></a>Part 11: 块结构Block Structure</h2><p>Intuition: 在允许函数嵌套定义的语言（比如Tiger）中，内部函数可能使用外部函数中的局部变量。<br><img src=\"/compiler-construction-principles/nested-funcs.png\" alt=\"nested-funcs\" loading=\"lazy\"><br>变量可以通过FP访问（因为定义的变量内存地址在编译时未知，<strong>但相对当前函数的FP偏移值(offset)是已知的</strong>）。</p>\n<p>在编译时，如何使得内部函数访问非局部定义的外部变量呢？有以下几种方法：</p>\n<ul>\n<li><strong>静态链接Static Link</strong>: 当内部函数<code>g</code>被调用时，调用者<code>f</code>传入一个指针指向<code>f</code>的栈帧（或者说活动记录）<ul>\n<li>这种情况下，我们说”<code>f</code> statically encloses <code>g</code>“</li>\n<li>如果多次嵌套，嵌套次数为<code>N</code>，这些指针会构成一个长为<code>N</code>的单向链表串联起栈帧</li>\n<li>每个函数记录自己的嵌套深度<code>n</code></li>\n<li>如果访问了在深度<code>m</code>的变量，只需沿着该链向上<code>n-m</code>次就可以找到该变量所在的栈帧</li>\n<li>优缺点：Overhead小，但是因为要通过链表向上经过多层速度较慢</li>\n<li><img src=\"/compiler-construction-principles/static-link-nested.png\" alt=\"static-link-nested\" loading=\"lazy\"></li>\n<li><strong>注意：有时<code>f</code>中嵌套的函数<code>g</code>不直接引用外部变量，而更里面的函数<code>h</code>可能才会；这时<code>h</code>的static link可以越过<code>g</code></strong></li>\n</ul>\n</li>\n<li>Lamda lifting: 从最深的一层叶过程开始，把所有<code>g(a1)</code>用到的外部变量<code>o1</code> <code>o2</code>改写为真正传入的参数，于是变为<code>g(o1, o2, a1)</code>. 如此逐渐向上改写每一层即可。<br><img src=\"/compiler-construction-principles/lambda-lifting.png\" alt=\"lambda-lifting\" loading=\"lazy\"></li>\n<li>Display数组：一个全局数组，记录当前每个嵌套深度<code>i</code>对应的栈帧地址。这样不需要经过链表即可直接找到变量对应的栈帧。</li>\n</ul>\n<h2 id=\"Part-12-Tiger语言：一个例子\"><a href=\"#Part-12-Tiger语言：一个例子\" class=\"headerlink\" title=\"Part 12: Tiger语言：一个例子\"></a>Part 12: Tiger语言：一个例子</h2><h3 id=\"Tiger语言的栈帧布局-Layout\"><a href=\"#Tiger语言的栈帧布局-Layout\" class=\"headerlink\" title=\"Tiger语言的栈帧布局(Layout)\"></a>Tiger语言的栈帧布局(Layout)</h3><p><img src=\"/compiler-construction-principles/layout.png\" alt=\"layout\" loading=\"lazy\"></p>\n<ul>\n<li>incoming parameters: 调用者传入</li>\n<li>return address: 返回<code>CALL</code>指令</li>\n<li>local variables: 部分必须在栈帧中放置的局部变量</li>\n<li>saved registers: 该函数保存的一些寄存器值，为其他用途腾出寄存器</li>\n<li>out-going arguments: 调用其他函数时传递的参数</li>\n<li>static link: 如上所述</li>\n<li>FP&#x2F;SP: 指向基址&#x2F;栈顶</li>\n</ul>\n<h3 id=\"Tiger语言编译器的栈帧实现\"><a href=\"#Tiger语言编译器的栈帧实现\" class=\"headerlink\" title=\"Tiger语言编译器的栈帧实现\"></a>Tiger语言编译器的栈帧实现</h3><p><del>看起来就不是什么会详细考的部分</del></p>\n<p>formals &#x3D; formal-parameters (不包括static link之类隐藏的参数)</p>\n<ul>\n<li>记录变量在寄存器中还是在栈帧中</li>\n<li>记录变量是否逃逸(escape)</li>\n<li>…</li>\n</ul>\n<p>进入被调用函数的上下文&#x3D;新的栈帧&#x3D;“视角切换(view shift)”, 这是不同机器&#x2F;指令集的实现需要完成的。<br><img src=\"/compiler-construction-principles/view-shift.png\" alt=\"view-shift\" loading=\"lazy\"></p>\n<blockquote>\n<p>💡本质上，我们在做的事和Lab3里为每一个参数分配地址，把一切读写放在内存里是一样的。<br>只是为了效率，有时这个“地址”并不存在而是储存在寄存器中；此外有的变量会逃逸。<br>因此需要实现访问的接口，对在寄存器的变量或者会逃逸的变量进行一些额外处理。</p>\n</blockquote>\n<p>其他trivial话题：</p>\n<ul>\n<li>Temporary: 局部变量的抽象名，代表一些暂存在寄存器中的值<ul>\n<li>本质上是为不同scope里的相同变量名进行重命名，类似我们在lambda演算时做的重命名等价变换： $ \\lambda x.x \\equiv \\lambda y.y$ 所以 $\\lambda x.\\lambda x.x \\equiv \\lambda x.\\lambda y.y$, 然后才能无歧义地带入x, y</li>\n</ul>\n</li>\n<li>Label: 标记还不能确定的机器静态的、物理的地址</li>\n</ul>\n<h3 id=\"总结：两层抽象\"><a href=\"#总结：两层抽象\" class=\"headerlink\" title=\"总结：两层抽象\"></a>总结：两层抽象</h3><p><img src=\"/compiler-construction-principles/two-layers.png\" alt=\"2 layers: abstraction\" loading=\"lazy\"></p>\n<ul>\n<li><code>frame.h</code> <code>temp.h</code> 封装了<strong>机器无关</strong>的变量视角，我们无需关心是在内存还是在寄存器中</li>\n<li><code>Translate</code>模块用于在上述封装的基础上将高级语言翻译为有层次的、用static link连接起来的各个函数，维护函数间的层次关系；找到跨层次的、对外部变量的访问，并把每个访问定位到具体某一层函数的某一个变量上。<ul>\n<li>这里，我们让Static link这一指针“伪装”成一个传给嵌套函数的参数</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Part-13-中间表示-IR\"><a href=\"#Part-13-中间表示-IR\" class=\"headerlink\" title=\"Part 13: 中间表示(IR)\"></a>Part 13: 中间表示(IR)</h2><p><a name=\"intermediate-representation\"></a></p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>IR &#x3D; Intermediate Representation</p>\n<p>编译流程划分：</p>\n<ul>\n<li>前端：源代码-&gt;词法分析-&gt;语法分析-&gt;语义分析-&gt;</li>\n<li>中端：IR1-&gt;IR2-&gt;…-&gt;IRn-&gt;<ul>\n<li>这个过程可做一些机器无关优化（比如循环展开）</li>\n</ul>\n</li>\n<li>后端：指令选择-&gt;寄存器分配-&gt;指令调度-&gt;机器码<ul>\n<li>这个过程可做一些机器相关优化</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"为何需要IR\"><a href=\"#为何需要IR\" class=\"headerlink\" title=\"为何需要IR\"></a>为何需要IR</h3><ul>\n<li>更模块化，更可迁移（跨平台）<ul>\n<li>考虑n个语言和m种平台，如果没有IR则需要n*m个编译器；引入一个IR后先统一翻译成IR，则只需要n+m个编译器</li>\n</ul>\n</li>\n<li>多层的：分层应用不同的分析和优化（i.e. 变换）<ul>\n<li>例如GCC, LLVM, Rust…</li>\n</ul>\n</li>\n<li>可能丢失少部分机器特定的细节，但不会损失太多</li>\n</ul>\n<p>一个好的IR应该简单，然后将复杂的AST翻译为IR代码，最后组合不同代码块。</p>\n<h3 id=\"IR杂项\"><a href=\"#IR杂项\" class=\"headerlink\" title=\"*IR杂项\"></a>*IR杂项</h3><p><strong>不要求掌握。</strong></p>\n<ol>\n<li><p>IR分类：</p>\n<ul>\n<li>高层IR: 提供语言特性的检测（例如borrow checking）</li>\n<li>中层IR</li>\n<li>低层IR: 贴近目标语言，易于生成</li>\n</ul>\n</li>\n<li><p>表示方式：</p>\n<ul>\n<li><strong>结构化</strong><ul>\n<li>基于图（树、无环图……）</li>\n</ul>\n</li>\n<li>线性Linear: 储存布局是线性的<ul>\n<li>栈（虚拟）机、<strong>三地址码</strong>……</li>\n</ul>\n</li>\n<li>混合Hybrid: 节点内线性，节点间图形化<ul>\n<li>经常见到的控制流图(CFG)就是一种</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>三地址码：</p>\n<ul>\n<li>是一种线性的IR</li>\n<li>格式：<code>x = y op z</code></li>\n<li>每个指令至多一个算符<code>op</code>, 至多三个操作数（地址）<code>x</code> <code>y</code> <code>z</code></li>\n<li>地址可以为：<ul>\n<li>源程序中显式的变量名</li>\n<li>常量、字面量</li>\n<li>编译器生成的临时中间变量</li>\n</ul>\n</li>\n<li>也可以记为一个四元组：<code>(op, x, y, z)</code> <code>(unary_op, x, y, _)</code> …</li>\n</ul>\n</li>\n<li><p>*静态单赋值SSA:</p>\n<p> Lab3实现过但<strong>不要求掌握</strong>。<br> SSA是特殊的三地址码：每个变量只能被赋值一次<br> 加速分析优化，被广泛应用（如LLVM）</p>\n</li>\n</ol>\n<h3 id=\"Tiger语言的IR-Tree及其指令\"><a href=\"#Tiger语言的IR-Tree及其指令\" class=\"headerlink\" title=\"Tiger语言的IR Tree及其指令\"></a>Tiger语言的IR Tree及其指令</h3><p>许多现代语言采用多层IR: AST-&gt;IR1-&gt;IR2-&gt;…-&gt;IRk-&gt;机器码<br>Tiger只使用单个IR, 也就是IR Tree: AST-&gt;IR Tree-&gt;汇编-&gt;机器码</p>\n<p>IR Tree是一种特殊的树形IR。指令列举如下：</p>\n<p>表达式（有值，可能有副作用）：</p>\n<table>\n<thead>\n<tr>\n<th>Syntax</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>CONST(i)</strong></td>\n<td>The integer constant i</td>\n</tr>\n<tr>\n<td><strong>NAME(n)</strong></td>\n<td>The symbolic constant n (e.g. a label is a name representing a address)</td>\n</tr>\n<tr>\n<td><strong>TEMP(t)</strong></td>\n<td>Temporary t.</td>\n</tr>\n<tr>\n<td><strong>BINOP(o, e1, e2)</strong></td>\n<td>The application of binary operator o to operands e1, e2. The integer arithmetic operators are PLUS, MINUS, MUL, DIV; the integer bitwise logical operators are AND, OR, XOR; the integer logical shift operators are LSHIFT, RSHIFT; the integer arithmetic right-shift is ARSHIFT.</td>\n</tr>\n<tr>\n<td><strong>MEM(e)</strong></td>\n<td>The contents of wordSize bytes of memory starting at address e. <strong>When MEM is used as the left child of a MOVE, it means “store”, but anywhere else it means “fetch”.</strong></td>\n</tr>\n<tr>\n<td><strong>CALL(f, l)</strong></td>\n<td>A procedure call: the application of function f to argument list l.</td>\n</tr>\n<tr>\n<td><strong>ESEQ(s, e)</strong></td>\n<td>Statement s is evaluated for side effects, then e is evaluated for the result.</td>\n</tr>\n</tbody></table>\n<p>语句（无值，有副作用）：</p>\n<table>\n<thead>\n<tr>\n<th>Syntax</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>MOVE(TEMP t, e)</strong></td>\n<td>Evaluate e and move it into temporary t.</td>\n</tr>\n<tr>\n<td><strong>MOVE(MEM(e1) e2)</strong></td>\n<td>Evaluate e1, yielding address a. THEN evaluate e2, and store the result into wordSize bytes of memory starting at a.</td>\n</tr>\n<tr>\n<td><strong>EXP(e)</strong></td>\n<td>Evaluate e and discard the result.</td>\n</tr>\n<tr>\n<td><strong>JUMP(e, labs)</strong></td>\n<td>Transfer control (jump) to address e. The destination e may be a literal label, as in NAME(lab), or it may be an address calculated by any other kind of expression.</td>\n</tr>\n<tr>\n<td><strong>CJUMP(o, e1, e2, t, f)</strong></td>\n<td>Evaluate e1, e2 in that order, yielding values a, b. Then compare a, b using the relational operator o. If the result is true, jump to t; otherwise jump to f.</td>\n</tr>\n<tr>\n<td><strong>SEQ(s1, s2)</strong></td>\n<td>The statement s1 followed by s2.</td>\n</tr>\n<tr>\n<td><strong>LABEL(n)</strong></td>\n<td>DEFINE the constant value of name n to be the current machine code address.</td>\n</tr>\n</tbody></table>\n<p><strong>每个指令都对应IR Tree的一颗子树。指令为根，操作数为其子节点。</strong></p>\n<p>在这种中间表示中，我们假定有无数个寄存器。</p>\n<p><strong>重要指令：ESEQ(s, e)</strong>:</p>\n<ol>\n<li>首先，<code>s</code>被执行(evaluate), 可能带有副作用(side effect)</li>\n<li>而后，<code>e</code>被执行作为指令的值</li>\n</ol>\n<p>例如，<code>ESEQ(a=5, a+5)</code>会返回值<code>10</code>, 同时副作用是<code>a</code>的值变为5</p>\n<blockquote>\n<p>❗副作用&#x3D;更新了内存单元或更改了寄存器的值</p>\n</blockquote>\n<h3 id=\"从AST生成IR-Tree\"><a href=\"#从AST生成IR-Tree\" class=\"headerlink\" title=\"从AST生成IR Tree\"></a>从AST生成IR Tree</h3><p><del>这部分看看就行</del></p>\n<ol>\n<li><p>总览<br>Tiger语言并不区分语句(statement)和表达式。<br>AST中的表达式(expression)可以分为：</p>\n<ul>\n<li>返回数值的，记为<code>Ex</code></li>\n<li>不返回数值的，记为<code>Nx</code></li>\n<li>返回布尔值：用于条件跳转，记为<code>Cx</code><br> 加上一些辅助函数<code>unEx</code> <code>unNx</code> <code>unCx</code>用于在不同类型之间转换。</li>\n<li>例如<code>flag:= (a&gt;b | c&lt;d)</code>, 右侧是<code>Cx</code>没有返回值，要转换成<code>Ex</code><ul>\n<li>表达式上下文不同，含义也不同，因此需要我们在这一步根据情况像这样进行转换</li>\n<li>说到底，IR翻译是上下文有关问题，不便用CFG刻画</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>变量翻译</p>\n<ul>\n<li>普通变量<ul>\n<li>相对FP的便宜是固定的。假设偏移量为<code>k</code>，则内存中变量的值为：<code>MEM(BINOP(PLUS,TEMP fp, CONST k))</code></li>\n<li>注意，对于一些常见的操作（例如加法）有如下简写：<code>BINOP(PLUS, a, b) = +(a, b)</code></li>\n<li>因此若变量<code>a</code>在内存中为<code>InFrame(k)</code>, 则<code>F_Exp(a,T_Temp(F_FP())</code>翻译为<code>MEM(BINOP(PLUS,TEMPFP,CONST(k)))</code></li>\n<li>而如果变量<code>b</code>在寄存器中为<code>InReg(t_832)</code>, 则直接翻译为<code>TEMP(t_832)</code></li>\n</ul>\n</li>\n<li>数组变量<ul>\n<li>其实就是一种固定的指针，只是没法直接拷贝（这一点取决于具体语言有所不同，Pascal就可以）</li>\n<li>Tiger语言提供<code>Record</code>类型，类似结构体。本质上还是指针，可以（浅）拷贝</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>左值与右值<br> 初略的理解：<br> 右值：可以出现在赋值语句右侧，不能出现在左侧<br> 左值：可以出现在赋值语句左侧和右侧</p>\n<blockquote>\n<p>🤭当然C++作为一门博大精深的语言把左值、右值、纯右值、将亡值的定义和用法给玩出花来了。左值和将亡值合称泛左值(generalized lvalue&#x3D;glvalue)，纯右值和将亡值合称右值(right value&#x3D;rvalue)。</p>\n</blockquote>\n<p> 左值&#x2F;右值各自又分为两种：</p>\n<ul>\n<li><strong>标量(scalar)</strong>: 只有一个元素（比如单个的变量名）</li>\n<li><strong>结构化的(structured)</strong>: 例如C中的结构体和数组<ul>\n<li>在这种情况下，从内存中取值的指令<code>MEM(addr)</code>要修改为<code>MEM(addr, size)</code></li>\n<li>当然Tiger语言并不需要：因为在Tiger语言中所有变量和左值都是标量（Tiger的数组和record本质上只是指针）。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>杂项</p>\n</li>\n</ol>\n<p><strong>对于这部分内容，如果认真写过Lab3: 实现AST-&gt;IR的应该可以直接无视。</strong></p>\n<ul>\n<li><p>下标索引与field选择</p>\n<ul>\n<li>数组：考虑<code>a[i]</code>, 其实际地址为<code>(i-l)*s+a</code>, 其中a为基地址，s为元素大小，l为最小索引值（l取0时即为<code>i*s+a</code>）。</li>\n<li>Record: <code>a.f</code>地址自然是<code>offset(f)+a</code>, 其中<code>offset(f)</code>代表该field在Record中的固定偏移量</li>\n</ul>\n</li>\n<li><p>内存安全</p>\n<p>内存漏洞普遍存在且危害大。<br>部分解决方法：</p>\n<ul>\n<li>插入额外的指令动态检查数组越界或空指针<ul>\n<li>性能↓↓↓</li>\n</ul>\n</li>\n<li>静态检查：例如borrow checker</li>\n</ul>\n</li>\n<li><p>运算符与条件语句</p>\n<p>二元运算符的翻译是显然的。<br>一元运算符可以由等效的二元运算符表达式代替：<code>-a</code> &#x3D; <code>0-a</code> …<br>条件表达式可以转写为条件跳转，同时还能实现短路功能。</p>\n</li>\n<li><p>If, While, For</p>\n<p>通过多个LABEL和条件跳转完成。<br>结构：</p>\n<ul>\n<li>If(cond): <code>cjump(cond,:TRUE,:FALSE)</code> <code>:TRUE</code> <code>then</code> <code>:FALSE</code> <code>else</code></li>\n<li>While(cond): <code>:TEST</code> <code>cjump(cond,...)</code> <code>body</code> <code>:DONE</code><ul>\n<li>遇到break则跳转到<code>:DONE</code>, 遇到continue则跳转到<code>:TEST</code></li>\n</ul>\n</li>\n<li>For(init;cond;each): 转写为While即可。不过要记得及时跳出循环，因此在开头和执行<code>each</code>前都要判断<code>cond</code>是否成立。</li>\n</ul>\n</li>\n<li><p>函数调用</p>\n<p>显然的。但是记得在参数列表开头加入static link:<br><code>CALL(NAME :LABEL_f,[SL, e1, e2, ..., en])</code></p>\n</li>\n<li><p>类型、变量与函数定义</p>\n<ul>\n<li>丢弃类型定义（毕竟只是别名）</li>\n<li>确定变量相对函数frame的偏移</li>\n<li>把变量初始化值转为赋值语句，插入初始化处</li>\n<li>函数定义分为三部分：<ul>\n<li>prologue:<ul>\n<li>函数入口的LABEL标记</li>\n<li>更改栈帧的FP&#x2F;SP以创建新栈帧</li>\n<li>保存不逃逸的参数到可用寄存器</li>\n<li>保存逃逸的参数到栈帧（包含Static link）</li>\n<li>保存Callee-save的寄存器到栈帧（例如返回地址）</li>\n</ul>\n</li>\n<li>body: 翻译的函数体</li>\n<li>epiloge:<ul>\n<li>保存返回值到寄存器（或栈上某地址）</li>\n<li>从栈帧中恢复Callee-save的寄存器</li>\n<li>回退到调用者的栈帧（更改FP&#x2F;SP）</li>\n<li>Return指令</li>\n<li>【可选】伪指令标记函数在此结束</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>重定位</p>\n<p>对于条件跳转或其他跳转指令的目的地址有可能在此时没法直接确定。例如C语言的编译单元是每个<code>.c</code> <code>.h</code>文件，并不知道其他文件存在，所以可能遇到如下情况：</p>\n<ul>\n<li>需要函数入口&#x2F;变量的绝对地址，但目前只知道相对地址</li>\n<li>需要访问在外部定义的函数&#x2F;变量，但尚未进行链接</li>\n</ul>\n<p>如果都能直接通过偏移找到位置，那么就是 <strong>“位置无关代码(PIC)”</strong> 了。<br>我们维护一个表记录需要待确定、需要在之后被填入的地址在哪些位置，留待日后使用。<br>参考ELF的<a href=\"https://stackoverflow.com/questions/63672744/why-differentiate-rel-text-and-rel-data-section\">.rel.text</a></p>\n</li>\n</ul>\n<h2 id=\"Part-14-基本块与traces\"><a href=\"#Part-14-基本块与traces\" class=\"headerlink\" title=\"Part 14: 基本块与traces\"></a>Part 14: 基本块与traces</h2><p>轨迹 &#x3D; trace</p>\n<p><em>注：这里的许多概念都是针对Tiger语言的，承接上文。</em><br>在将IR的AST翻译为机器码的过程中，不可避免地需要解决将“树形的”AST转换到“线性的”机器码这一问题。<br>例如：一个包含<code>ESEQ</code>子节点的<code>BINOP</code>树代表一个二元运算符表达式。但由于<code>ESEQ</code>有副作用，这个表达式的值取决于<code>ESEQ</code>先求值&#x2F;后求值，是存在歧义的。<br>解决方法：将IR Tree变换为 <strong>正规形式(canonical form)</strong> ，而内部存在很多 <strong>正规树(canonical tree)</strong> （详见下文）.</p>\n<h3 id=\"正规形式Canonical-Form\"><a href=\"#正规形式Canonical-Form\" class=\"headerlink\" title=\"正规形式Canonical Form\"></a>正规形式Canonical Form</h3><p>对比IR Tree与canonical form:</p>\n<ul>\n<li>IR Tree:<ul>\n<li>容易从源码AST生成</li>\n<li>难以直接翻译为机器码</li>\n</ul>\n</li>\n<li>Canonical form:<ul>\n<li><code>SEQ</code>节点都在最右侧一路向下：<br><img src=\"/compiler-construction-principles/canonical-form.png\" alt=\"canonical form\" loading=\"lazy\"></li>\n<li>一个函数就是一个大<code>SEQ</code>序列：<code>SEQ(s1,s2,s3...)</code></li>\n<li>可以直接生成机器码</li>\n</ul>\n</li>\n</ul>\n<p>IR Tree-&gt;正规形式需要如下三步：</p>\n<ol>\n<li>IR树被转化&#x2F;重写，或者说线性化为一些正规树。<br>基本上干的事情就是消除<code>ESEQ</code>以及把<code>CALL</code>向上挪。最后把树中的<code>SEQ</code>删去，这棵树就会“破碎”成很多<strong>正规树</strong>。</li>\n<li>正规树被组装成一些基本块(basic block), 内部不包含<code>LABEL</code>与跳转语句。<br>这句话很别扭，更人体工程学的说法应该是“<code>LABEL</code>和跳转语句把代码（或这些树）分割成了不同基本块。”</li>\n<li>基本块被排序成一些<strong>trace</strong>, trace 中的<code>CJUMP</code>指令后紧跟着条件不成立需要跳转到的<code>false</code>标签。<br>这是因为在IR Tree中<code>CJUMP</code>条件为真&#x2F;假分别跳转至两个不同标签，但事实上机器码可以顺着执行下去(fall-through), 只有条件为真才需要跳转到远处，否则直接不跳转往下继续运行即可。</li>\n</ol>\n<h3 id=\"正规树Canonical-Tree\"><a href=\"#正规树Canonical-Tree\" class=\"headerlink\" title=\"正规树Canonical Tree\"></a>正规树Canonical Tree</h3><p>一种中间体。从IR Tree线性化而来，又到正规形式之中去。<br>不要太纠结这个概念。<em>正规树</em>，不过是因为要重排一些指令，不得不破碎原来的树为森林后，为这些树起的一个过于术语化的名字。</p>\n<p>性质：</p>\n<ul>\n<li>其他所有节点都是<strong>表达式</strong>。</li>\n<li>根节点为 <strong>语句(statement)</strong> ，所以正规树就对应IR中的一个语句，也就是IR Tree中的一个子树。<ul>\n<li>只不过有额外约束，所以经过了变换结构可能不一样（也可能由于原来的子树已经很纯很“正规”所以没变化）。</li>\n</ul>\n</li>\n<li>不存在<code>SEQ</code>或者<code>ESEQ</code>。<ul>\n<li><code>SEQ</code>: 用于分割出这些canonical tree, 自然被删了不存在。</li>\n<li><code>ESEQ</code>: 被变换成<code>SEQ</code>然后也被删了（详见下文）。</li>\n</ul>\n</li>\n<li>每个<code>CALL</code>节点的父节点即为canonical tree的根节点，且只能为<code>EXP</code>或<code>MOVE</code>.<ul>\n<li>事实上至多只能有一个<code>CALL</code>节点，因为我们规定<code>EXP</code>或<code>MOVE</code>只能包含一个<code>CALL</code>.<br>这是因为实现上返回值在指定寄存器里保存，如果有两个<code>CALL</code>就会导致覆写，需要引入新的临时寄存器保存值（详见下文）。</li>\n</ul>\n</li>\n</ul>\n<p>这些树最后会被组装为canonical form. 具体步骤见下。</p>\n<h3 id=\"Stage-1-线性化为正规树\"><a href=\"#Stage-1-线性化为正规树\" class=\"headerlink\" title=\"Stage 1: 线性化为正规树\"></a>Stage 1: 线性化为正规树</h3><p>线性化 &#x3D; linearization<br>如果没有特别限定，本部分的“树”指的就是IR Tree.</p>\n<ol>\n<li><p>消除<code>ESEQ</code><br> 首先要去除原先树中所有的ESEQ. 总的来说是不断向上“提升”<code>ESEQ</code>直到它可以转为<code>SEQ</code>.<br> 部分规则如下：</p>\n<table>\n<thead>\n<tr>\n<th>Expression</th>\n<th>Transforms to</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ESEQ(s1, ESEQ(s2, e))</td>\n<td>ESEQ(SEQ(s1, s2), e)</td>\n</tr>\n<tr>\n<td>BINOP(op, ESEQ(s, e1), e2)</td>\n<td>ESEQ(s, BINOP(op, e1, e2))</td>\n</tr>\n<tr>\n<td>MEM(ESEQ(s, e1))</td>\n<td>ESEQ(s, MEM(e1))</td>\n</tr>\n<tr>\n<td>JUMP(ESEQ(s, e1))</td>\n<td>SEQ(s, JUMP(e1))</td>\n</tr>\n<tr>\n<td>CJUMP(op, ESEQ(s, e1), e2, l1, l2)</td>\n<td>SEQ(s, CJUMP(op, e1, e2, l1, l2))</td>\n</tr>\n<tr>\n<td>BINOP(op, e1, ESEQ(s, e2))</td>\n<td>ESEQ(MOVE(TEMP t, e1), ESEQ(s, BINOP(op, TEMP t, e2)))</td>\n</tr>\n<tr>\n<td>CJUMP(op, e1, ESEQ(s, e2), l1, l2)</td>\n<td>SEQ(MOVE(TEMP t, e1), SEQ(s, CJUMP(op, TEMP t, e2, l1, l2)))</td>\n</tr>\n<tr>\n<td>MOVE(ESEQ(s, e1), e2)</td>\n<td>SEQ(s, MOVE(e1, e2))</td>\n</tr>\n<tr>\n<td>CALL(f, a)</td>\n<td>ESEQ(MOVE(TEMP t, CALL(f, a)), TEMP(t))</td>\n</tr>\n</tbody></table>\n<p> 这些变换的成立性是容易验证的，<br> 在这之中，要注意副作用的问题，也就是语句执行顺序对结果有影响的情况：例如对于<code>BINOP(op, e1, ESEQ(s, e2))</code>（<code>e1</code>先求值，而后执行<code>s</code>）：</p>\n<ul>\n<li>如果<code>s</code>会影响<code>e1</code>的值，那么不能调换二者的执行顺序。</li>\n<li>也就是说<strong>不一定能</strong>变形为<code>ESEQ(s, BINOP(op, e1, e2))</code>（<code>s</code>先执行，而后对<code>e1</code>求值）</li>\n<li>解决方法：使用临时变量保存<code>e1</code>值。这种情况下则变形为<code>ESEQ(MOVE(TEMP t,e1), ESEQ(s, BINOP(op, TEMP t, e2)))</code></li>\n</ul>\n<p> 可见，取决于<code>s</code>是否会影响<code>e1</code>值，有不同的变形策略。<br> 事实上，“会不会影响取值”是一种称为“可交换性(commutativity)”的属性：</p>\n<ul>\n<li>如果<code>s</code><strong>不</strong>影响<code>e1</code>值，那么我们说<code>s</code>, <code>e1</code> commute</li>\n<li>如果<code>s</code><strong>会</strong>影响<code>e1</code>值，那么我们说<code>s</code>, <code>e1</code> do NOT commute</li>\n</ul>\n<p> 如果能判断两者是否commute, 就可以最大限度避免引入新的临时变量，使得目标代码尽可能短小、高效。遗憾的是由于内存读写等原因，这一判定问题是困难的。不过我们只需要进行保守近似即可。也就是说，如果我们的保守近似策略判定二者commute, 那么他们一定commute; 否则如果策略无法确信二者commute, 则保守地认为他们互相有可能影响（不commute）。</p>\n<p> 一种年轻，简单，有时幼稚(naïve)的策略是：</p>\n<ul>\n<li>常量和所有语句commute</li>\n<li>空语句和所有语句commute</li>\n<li>其他情况均假定为not commute</li>\n</ul>\n<p> 当然，如果能进行别名分析(alias analyses)以判断某个内存地址是否会被两个不同指针指向, 就能确认更多的对象间commute, 得到更精确的近似。</p>\n</li>\n<li><p>移动<code>CALL</code>到顶层<br> 常见的现代编译器都使用指定寄存器保存函数返回值。因此形如<code>BINOP(PLUS, CALL(…), CALL(…))</code>有多个<code>CALL</code>子节点的表达式虽然结构正确，但在实现中存在对该寄存器的使用冲突。<br> 解决方法也很简单：对于多余的<code>CALL(fun, args)</code>直接转化为<code>ESEQ(MOVE(TEMP t, CALL(fun, args)), TEMP t)</code>, 也就是使用临时变量保存返回值。</p>\n</li>\n<li><p>重排并消除<code>SEQ</code><br> 在执行完上述步骤后，整个树可能形如<code>SEQ(SEQ(SEQ(..., sx), sy), sz)</code>.<br> 现在需要把<code>SEQ</code>变为父节点的最右儿子（类似平衡树的旋转）。这只需要无脑应用<code>SEQ(SEQ(a, b), c)</code> &#x3D;&gt; <code>SEQ(a, seq(b, c))</code>即可。<br> 然后树就变成了：<code>SEQ(s1, SEQ(s2, ..., SEQ(sn-1,sn)...))</code>（也就是让<code>SEQ</code>集中在树的“右上”部分）<br> <img src=\"/compiler-construction-principles/seq.png\" alt=\"seq\" loading=\"lazy\"></p>\n<p> 接下来把<code>SEQ</code>全部去除，只留下这些<code>s1</code> … <code>sn</code>: 每个都是一颗不含<code>SEQ</code>&#x2F;<code>ESEQ</code>的<strong>正规树</strong>！<br> 至此第一阶段任务完成。</p>\n</li>\n</ol>\n<h3 id=\"Stage-2-3-处理条件跳转\"><a href=\"#Stage-2-3-处理条件跳转\" class=\"headerlink\" title=\"Stage 2&amp;3: 处理条件跳转\"></a>Stage 2&amp;3: 处理条件跳转</h3><p>大部分机器不具备<code>CJUMP</code>的两个分支跳转到两个不同块这种功能。通常来讲是一个分支是继续顺序向下执行，另一个分支进行跳转。<br>因此需要重排树，让<code>CJUMP</code>后紧接的就是一个label, 对应其中一个分支跳转到的块。<br>这需要以下两步：</p>\n<ol>\n<li><p>Stage 2: 组装为基本块(basic block)<br> 基本块指的是一串代码，进入则一路执行到块末尾。性质：</p>\n<ul>\n<li>开头是一个label伪指令</li>\n<li>最后一个指令是跳转、条件跳转或返回等terminator</li>\n<li>中间不包含其他label&#x2F;terminator</li>\n</ul>\n<p> 本质上，如果没有跳转指令，程序只会一路向下执行。正是跳转指令（JUMP&#x2F;CJUMP&#x2F;RET&#x2F;…）令程序在执行中途跳出，而跳转的目标地址（也就是LABEL）令程序在执行中途跳入，才把原本的代码分割为了多个基本块。<br> 控制流图(Control-Flow Graph &#x3D; CFG)中的节点就是基本块，边就是跳转指令。<del>打开IDA反编译立刻就能见到。</del><br> <img src=\"/compiler-construction-principles/cfg.png\" alt=\"CFG\" loading=\"lazy\"><br> 生成的过程是显然的：找到一个<code>LABEL</code>就新起一块；找到一个<code>JUMP</code>&#x2F;<code>CJUMP</code>&#x2F;<code>RET</code>&#x2F;…就结束当前块并新起一块。有的块缺少<code>LABEL</code>或者terminator则补上一个。</p>\n</li>\n<li><p>Stage 3: 生成轨迹(traces)<br> 基本块如何排列并不影响程序执行结果。<br> 然而我们需要进行一些优化，尽可能减少跳转或提高跳转的效率。例如：</p>\n<ul>\n<li>对于<code>CJUMP(cond, true, false)</code>, 将false label对应的块紧挨着放置在<code>CJUMP</code>指令后，这样执行时就可以fall through</li>\n<li>尝试将无条件跳转<code>JUMP</code>的目标label对应的块直接放在<code>JUMP</code>后</li>\n<li>如果可以，甚至可以直接删除部分<code>JUMP</code>, 例如将函数内联</li>\n<li>优化缓存命中率:<br><img src=\"/compiler-construction-principles/block-ordering.png\" alt=\"block ordering\" loading=\"lazy\"></li>\n<li>…</li>\n</ul>\n<p> 在此定义几个相关概念:</p>\n<ul>\n<li><strong>轨迹trace</strong><ul>\n<li>一个可以被按顺序执行完毕的指令序列</li>\n<li>说人话：几个连接在一起的基本块构成一个trace</li>\n<li>CFG图中的一条链就是一个trace</li>\n</ul>\n</li>\n<li><strong>covering set of traces</strong><ul>\n<li>一个集合，元素是许多<strong>无环</strong>trace</li>\n<li>每个基本块在且恰好在一个trace中（i.e. 集合能覆盖整个CFG图）</li>\n</ul>\n</li>\n</ul>\n<p> 有一个比较显然的构建方法：从源节点（不叫根节点是因为这只是个图，大概率不是棵树）开始跑一次DFS即可。<br> 每次从一个未被染色的节点开始，递归地对于每个后继节点，如果还未染色则加入当前trace。<br> 重复该过程直到整个图都被染色。<br> <img src=\"/compiler-construction-principles/covering-set.png\" alt=\"coloring\" loading=\"lazy\"></p>\n<p> 通过这种方式可以去掉不少跳转。<br> 这是因为现在可以转变思维：原先的跳转指令似乎毫无关联，而现在则是把其中一些连在一起成为traces，然后默认代码执行是在一个trace上走到底的。于是只有要切换trace时才需要一个跳转。<br> 可见，其实我们希望被经常执行的一段代码序列要自己成一个trace，这样就可以尽量减少跳转，增加性能。<br> 在某个判据(criteria)下最好的一些trace就可以被称为 <strong>“optimal traces”</strong> .<br> 例如如果我们的判据是“最少的跳转指令”，对于<code>While</code>语句，通过合理的重排就可以去掉一个跳转达成：<br> <img src=\"/compiler-construction-principles/optimal-traces.png\" alt=\"to be optimal\" loading=\"lazy\"><br> <img src=\"/compiler-construction-principles/reorder-eg.png\" alt=\"reorder example\" loading=\"lazy\"></p>\n</li>\n</ol>\n<h3 id=\"IR-机器码：小结\"><a href=\"#IR-机器码：小结\" class=\"headerlink\" title=\"IR-&gt;机器码：小结\"></a>IR-&gt;机器码：小结</h3><p>一共四步：</p>\n<ol>\n<li>把IR Tree转成一些canonical trees</li>\n<li>重排这些canonical trees为traces, 使得<code>CJUMP(cond, :true, :false)</code>后紧跟着<code>LABEL(:false)</code></li>\n<li><strong>指令选择</strong>：从canonical trees产生伪汇编代码</li>\n<li>对伪汇编代码进行<strong>寄存器分配</strong>：确定哪些值可以放置在寄存器中</li>\n<li>指令调度（不在本课程中）：通过重排等操作优化代码、实现指令级并行</li>\n</ol>\n<p>其中后两步将在后文展开阐述。</p>\n<h2 id=\"Part-15-指令选择\"><a href=\"#Part-15-指令选择\" class=\"headerlink\" title=\"Part 15: 指令选择\"></a>Part 15: 指令选择</h2><p>回顾<a href=\"#intermediate-representation\">现代编译器架构</a>：<strong>指令选择</strong> 开始是编译器的后端部分。<br>LLVM支持用tblgen描述后端，从而自动生成指令选择器。</p>\n<h3 id=\"指令选择概述\"><a href=\"#指令选择概述\" class=\"headerlink\" title=\"指令选择概述\"></a>指令选择概述</h3><p><strong>任务：</strong> 把IR转化为 <em>抽象汇编代码</em>。</p>\n<p>抽象汇编代码&#x3D;</p>\n<ul>\n<li>具有有限个寄存器的汇编代码；</li>\n<li>为中间结果创造新的临时寄存器；</li>\n<li>在之后的流程中，会把这些寄存器映射到物理寄存器。</li>\n</ul>\n<p>指令选择要解决的问题：IR的一个语句有多种可能的实现方式，需要确定为其中“最好”的一种。<br>最好&#x3D; 最快&#x2F;最小&#x2F;最省电……这个判据取决于具体需求。总之需要综合考虑操作数&#x2F;结果的访存需求，指令本身的代价等。</p>\n<p>例如对于<code>MOVE(TEMP(t1), TEMP(t1) + MEM(TEMP(FP)+4))</code>, 既可以翻译为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov t2, rbp</span><br><span class=\"line\">add t2, 4</span><br><span class=\"line\">mov r3, [t2]</span><br><span class=\"line\">add t1, t3</span><br></pre></td></tr></table></figure>\n\n<p>，也可以翻译为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add t1, [rbp + 4]</span><br></pre></td></tr></table></figure>\n\n<p>指令选择一种可能的实现方式：<strong>对IR进行模式匹配，一个模式匹配一些IR片段，转化为机器指令</strong><br>IR Tree 是一种 <em>tree-oriented IR</em>, 自然需要在树上进行模式匹配。例如基于动态规划(DP)的匹配。<br>同理对于线性IR，就需要一些字符串匹配。例如纯文本匹配。<br>当然，匹配器(matcher)都是因地制宜相差甚远的，我们不需要当一个分类学家。</p>\n<p>接下来把重心放在树形IR上。</p>\n<h3 id=\"指令选择算法：基于树覆盖\"><a href=\"#指令选择算法：基于树覆盖\" class=\"headerlink\" title=\"指令选择算法：基于树覆盖\"></a>指令选择算法：基于树覆盖</h3><p>这里的覆盖意指：显然的，整棵 IR Tree 需要被完全覆盖才能完成翻译流程。<br>为了方便起见，接下来假设目标机器码是一个简单的架构（指令集）：<code>Jouette</code>架构。它基本上就是RISC-V的子集。我们约定：</p>\n<ul>\n<li>寄存器<code>r0</code>永远为0</li>\n<li>数据&#x2F;地址能直接在寄存器中放得下</li>\n<li>每时钟周期只有1个指令执行</li>\n<li>每个指令延迟1时钟周期（<strong>但内存-内存数据拷贝使用的<code>MOVEM</code>指令除外</strong>）</li>\n</ul>\n<p>有如下翻译方式：</p>\n<ul>\n<li>宏展开&#x2F;模板匹配<ul>\n<li>公式化地，把每条IR直接展开成一或多条机器指令</li>\n<li>缺点：缺乏优化<ul>\n<li>只能1-&gt;1或1-&gt;N, 但多条IR指令有时明明可以合并(N-&gt;1)</li>\n<li>盲目的，缺乏上下关联</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>通过寻找树上的模式(tree patterns)<ul>\n<li><strong>将在下文详细研究。</strong></li>\n<li>Tree Pattern: IR Tree的某个片段如果长得符合某个树形的模式(tree pattern)，就可以把这部分对应到一条机器码。<ul>\n<li>这种模式匹配出来的 IR Tree 片段被叫做 <strong>tile</strong>.</li>\n<li>tile 是模式匹配到的一个实例。</li>\n</ul>\n</li>\n<li>比如<code>LOAD ri &lt;- M[rj+c]</code>对应的模式就可以是<code>MEM(BINOP(PLUS, _expr_, CONST(_expr_)))</code></li>\n<li>目标：没有重叠地覆盖整棵IR Tree. 这个过程称为<code>tiling</code></li>\n<li>把机器码转为对应的 tree patterns (注意可能有多种模式都可以翻译到这种机器码)。以<code>Jouette</code>架构为例：<br><img src=\"/compiler-construction-principles/jouette-patterns.png\" alt=\"jouette patterns\" loading=\"lazy\"><ul>\n<li>接下来只需找到一种方式让各种机器指令的 tree pattern 能够覆盖整颗 IR Tree, 就任务完成了。<br>X86的例子：<br><img src=\"/compiler-construction-principles/tiling.png\" alt=\"x86 tiling example\" loading=\"lazy\"><br>Jouette的例子，其中<code>a</code>数组每个元素占据4个储存地址，因此要翻译的IR指令是<code>M[a+i*4]:=x</code>：<br><img src=\"/compiler-construction-principles/jouette-tiling.png\" alt=\"jouette tiling example\" loading=\"lazy\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>现在要做的是找到一种方法，使得生成的机器代码跑的比香港记者还快。<br><strong>注：以下讨论隐含的前提是每个指令速度一致。但是对于RISC指令集（见下一节）来说并非如此，有的指令可能耗费高达数十时钟周期。好消息是<code>Jouette</code>指令集不仅单发射还固定延迟，所以指令少即是跑得快。</strong></p>\n<p>每个Tile对应一个代价(cost), 反应了生成的目标机器指令运行的代价（功耗&#x2F;延迟&#x2F;速度……取决于你）。</p>\n<ul>\n<li>可以用很多小的tile轻松覆盖整棵树，但是大量tile对应大量目标代码，很长很慢；</li>\n<li>也可以用一些大块的tile进行覆盖，这样tile量少对应目标代码也较小，跑得快（但是这使得覆盖问题本身变得困难）。</li>\n</ul>\n<p>为此我们需要区分如下两个概念：</p>\n<ul>\n<li>Optimum tiling<ul>\n<li>全局最优：所有tiles总代价最小</li>\n</ul>\n</li>\n<li>Optimal tiling<ul>\n<li>局部最优：没有相邻的tile可以被合并成一个tile了</li>\n</ul>\n</li>\n</ul>\n<p>显然全局最优一定局部最优，但反之则不然。</p>\n<p>接下来就是不同的指令选择算法：</p>\n<ul>\n<li>Maximal Munch: 寻找optimal tiling (<strong>局部最优的</strong>)<ul>\n<li><strong>自顶向下</strong></li>\n<li>用可用的最大tile覆盖当前节点</li>\n<li>递归地对（那些根节点）还未被覆盖的每个子树应用该算法</li>\n<li>把所有tile对应的指令按照覆盖顺序的<strong>逆序</strong>收集起来即为目标机器码<ul>\n<li>为何逆序？考虑一个简单的<code>BINOP(PLUS, 1, 5)</code>, 该算法会先用加法指令对应的tile覆盖，然后再对操作数表达式（<code>1</code>和<code>5</code>）递归生成对应的tile. 但显然要先有操作数表达式的值，才能对他们执行加法指令。</li>\n</ul>\n</li>\n<li>运用贪心思想：更大的tile&#x3D;&gt;更精确的模式匹配&#x3D;&gt;更多指令中的信息被运用&#x3D;&gt;更优的代码</li>\n</ul>\n</li>\n<li>动态规划(dynamic programming, DP): optimum tiling (<strong>全局最优的</strong>)<ul>\n<li><p><strong>自底向上</strong></p>\n</li>\n<li><p>每个节点<code>x</code>都有一个代价，是代价最小的覆盖方案的代价。<br>而每个可用于覆盖节点<code>x</code>的tile都对应一种方案，该方案的代价为该tile的子树代价之和，加上这个tile <code>T</code>固有的代价：<br>$ cost(x)&#x3D;\\underset{\\forall \\text{tile } T \\text{ that can cover node } x}{min} (cost_T + \\underset{\\forall \\text{child } y \\text{ of tile } T}{\\sum} cost(y)) $<br>例如，假设<code>ADD</code>指令对应两种tile,</p>\n<ul>\n<li>第一种，对应最原始的模式<code>BINOP(PLUS, _expr1_, _expr2_)</code>，如果使用这个 tile, 该节点的代价自然就是<code>表达式1（左子树）的代价+表达式2（右子树）的代价+1</code>;</li>\n<li>第二种，操作数都是常数可以直接优化为常值，对应模式为<code>BINOP(PLUS, CONST(num), CONST(num))</code>，那么以该节点为根的子树立刻被完全覆盖，该节点代价就是固定值<code>1</code> !</li>\n</ul>\n<p>如果这两种tile都可用的话，显然应该选择第二种。</p>\n</li>\n<li><p>tile 的子树的代价均已知，在可用于覆盖当前节点的tiles中，采用一个使得该节点代价最小的进行覆盖即可。</p>\n</li>\n<li><p>正确性：使得某节点代价最小的 tile, 其子树必然也以代价最小的tile覆盖。否则子树可以替换为更优的覆盖方式，结果一定不会更劣。</p>\n</li>\n<li><p>时间复杂度：线性（因为可用 tile 数与IR Tree节点数量都是已知常数）。</p>\n</li>\n<li><p>步骤：</p>\n<ol>\n<li>自底向上，递归地求出所有子树的代价</li>\n<li>尝试所有在当前节点可用的tile, 每种tile对应一个覆盖方案</li>\n<li>找到代价最低的一个方案，记录所用的 tile 和代价在该节点上</li>\n<li>根节点的最小代价被找到，意味着整棵树的optimum tiling已完成，开始指令发射(instruction emission).<br>也就是从根节点开始，递归地，先发射该节点 tile 子树的指令，而后发射该节点 tile 的指令。<br>例如：<ol>\n<li>寻找<code>CONST 1</code>与<code>CONST 2</code>的最小代价与tile（略）</li>\n<li>寻找<code>+</code>的最小代价与 tile, 方案2被采用：<br><img src=\"/compiler-construction-principles/dp-plus-node.png\" alt=\"dp-plus-node\" loading=\"lazy\"></li>\n<li>寻找<code>MEM</code>的最小代价与 tile, 方案3被采用：<br><img src=\"/compiler-construction-principles/dp-mem-node.png\" alt=\"dp-mem-node\" loading=\"lazy\"></li>\n<li>发射指令：<br><img src=\"/compiler-construction-principles/dp-emit.png\" alt=\"dp-emit\" loading=\"lazy\"></li>\n</ol>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>这里需要特别注意：tile 的子树不是该节点的子树，而是用 tile 覆盖该节点以及部分子节点后，那些没被覆盖到的子树。<br>例如下图中红色的 tile 对应的子树并非两个<code>MEM</code>子树（因为被这个tile覆盖在内），而是两个<code>PLUS</code>子树：<br><img src=\"/compiler-construction-principles/tile-children.png\" alt=\"children of tile\" loading=\"lazy\"></p>\n</blockquote>\n<h3 id=\"树语法Tree-Grammar\"><a href=\"#树语法Tree-Grammar\" class=\"headerlink\" title=\"*树语法Tree Grammar\"></a>*树语法Tree Grammar</h3><p><strong>不要求掌握。</strong></p>\n<p>tree grammar 是一种上下文无关文法。<br>可以用 tree grammar 描述这些 tile.</p>\n<p>需要记录：</p>\n<ul>\n<li>pattern: 模式是什么样的</li>\n<li>replacement: 这个pattern被替换之后，原来的位置要用什么代替（比如一个加法指令被替换后，要用加法结果所在的寄存器替换该表达式）</li>\n<li>cost: tile 的固有代价</li>\n<li>template: 生成的目标代码模板</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>pattern-&gt;replacement</th>\n<th>cost</th>\n<th>template</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>+(r1,r2) -&gt; r2</td>\n<td>1</td>\n<td>add r1,r2</td>\n</tr>\n<tr>\n<td>store(r1,load(r2)) -&gt; DONE</td>\n<td>5</td>\n<td>movem r2,r1</td>\n</tr>\n</tbody></table>\n<h3 id=\"CISC-vs-RISC\"><a href=\"#CISC-vs-RISC\" class=\"headerlink\" title=\"CISC vs. RISC\"></a>CISC vs. RISC</h3><ul>\n<li>CISC<ul>\n<li>Complex Instruction Set Computer &#x3D; 复杂指令集计算机</li>\n<li>可能有多个寄存器类，有的指令只能使用一部分</li>\n<li>指令不等长</li>\n<li>计算指令可用内存作为操作数</li>\n<li>内存寻址方式多样</li>\n<li>指令可能有副作用</li>\n<li>…</li>\n<li>难以使用tree pattern-based tiling建模！</li>\n</ul>\n</li>\n<li>RISC<ul>\n<li>Reduced Instruction Set Computer &#x3D; 精简指令集计算机</li>\n<li>寄存器只有一类</li>\n<li>指令等长（例如32bit）</li>\n<li>计算指令只能用寄存器作为操作数</li>\n<li>内存寻址方式少</li>\n<li>指令没有副作用（WYSIWYG）</li>\n<li>…</li>\n</ul>\n</li>\n</ul>\n<p>CISC引入了一些问题：</p>\n<ul>\n<li>较少的寄存器：用一些临时节点代替，让寄存器分配器干活</li>\n<li>要求操作数&#x2F;结果放在不同寄存器：多显式move即可</li>\n<li>使用2地址码，但IR是3地址码：<code>t1&lt;-t2+t3</code>可转为<code>t1&lt;-t2; t1&lt;-t1+t3;</code>. 然后让寄存器分配器干活</li>\n<li>操作数使用了内存值：先放进寄存器即可</li>\n<li>有副作用（比如某种自增计数器）：无视&#x2F;改写&#x2F;换一套算法然后改用DAG模式匹配……</li>\n</ul>\n<p>对于CISC, IR Tree中的多个指令可能只需要一个机器指令就能解决，此时 optimal 和 optimum 区别巨大；<br>对于RISC, 很多时候二者没有什么区别，因此只需要最简单的 tiling 算法。</p>\n<p>现代编译器还需要额外考虑以下问题：</p>\n<ul>\n<li>多级流水中指令可以同时发射执行，因此多指令的执行时间并非简单加和即可</li>\n<li>cost只是一种不错的估计，而不能反应全貌。<ul>\n<li>例如，指令顺序可能影响流水线的 stall 频率从而影响 CPU 的 IPC, 指令间复杂的羁绊显然无法通过cost这一简单数字反应……</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Part-16-活跃变量分析\"><a href=\"#Part-16-活跃变量分析\" class=\"headerlink\" title=\"Part 16: 活跃变量分析\"></a>Part 16: 活跃变量分析</h2><h3 id=\"编译器优化\"><a href=\"#编译器优化\" class=\"headerlink\" title=\"*编译器优化\"></a>*编译器优化</h3><p><strong>不要求掌握。</strong></p>\n<p>例如GCC的 <code>-O</code> 系列编译选项。</p>\n<p>优化可以分为：</p>\n<ul>\n<li>空间优化</li>\n<li>时间优化</li>\n<li>能耗优化</li>\n</ul>\n<p>优化可以是：</p>\n<ul>\n<li>本地的：一个basic block里</li>\n<li>全局的（过程内）：在整个过程（函数&#x2F;方法）中</li>\n<li>全程序的（跨过程）：多个过程（函数&#x2F;方法）之间，甚至整个程序，甚至多个通过链接器连接起来的源程序间（参见LTO, link time optimization）</li>\n</ul>\n<p>常见优化（闲的话可以在lab里实现一下）：</p>\n<ul>\n<li>编译期常量求值：常量折叠、常量传播</li>\n<li>减少计算代价：代数简化、强度折减(strength reduction)</li>\n<li>消除重复计算：拷贝传播、值编号、消除公因子</li>\n<li>向量化：超字级并行(superword-level parallelism, SLP)、循环向量化</li>\n<li>循环优化：循环不变代码外提、循环展开、合并拆分、代码提升(code hoisting)</li>\n<li>减少函数调用开销：内联、尾递归优化</li>\n<li>控制流优化：死代码消除、if语句简化</li>\n</ul>\n<p>这些优化需要一些对代码的分析：</p>\n<ul>\n<li>控制流分析：基本块之间的跳转关系<ul>\n<li>例如：死代码消除</li>\n</ul>\n</li>\n<li>数据流分析：数据依赖、引用关系，活跃情况<ul>\n<li>例如：向量化</li>\n</ul>\n</li>\n<li>别名分析：寻找可能指向同一地址的指针</li>\n</ul>\n<h3 id=\"数据流分析Dataflow-Analysis\"><a href=\"#数据流分析Dataflow-Analysis\" class=\"headerlink\" title=\"数据流分析Dataflow Analysis\"></a>数据流分析Dataflow Analysis</h3><ul>\n<li>CFG &#x3D; Control-Flow Graph<ul>\n<li>节点代表一个语句<ul>\n<li>一般来说，我们会将多个相邻的不包含跳转指令，也不是跳转指令目的地的多个语句组合为一个基本块</li>\n</ul>\n</li>\n<li>有向边代表一个可能的跳转</li>\n</ul>\n</li>\n</ul>\n<p>我们可以从CFG（或其他类型的中间表示）中<strong>静态（i.e. 不需要真的运行程序）</strong>推导出一些程序的行为信息。<br>这其中就包括马上要研究的话题：<strong>变量的活跃性</strong>。</p>\n<h3 id=\"活跃性分析Liveness-Analysis\"><a href=\"#活跃性分析Liveness-Analysis\" class=\"headerlink\" title=\"活跃性分析Liveness Analysis\"></a>活跃性分析Liveness Analysis</h3><p>定义变量的liveness: 我们说变量<code>x</code>在执行到一个语句<code>s</code>时是活跃(live)的，当且仅当：</p>\n<ul>\n<li>存在某个语句<code>s&#39;</code>使用了<code>x</code></li>\n<li>存在一个执行路径，能从<code>s</code>执行到<code>s&#39;</code></li>\n<li>在某个这样的路径上，<code>x</code>没有被重新赋值&#x2F;定义过</li>\n</ul>\n<p><strong>简单粗暴的理解：活跃变量&#x3D;还有用的变量，需要留着备用；不活跃变量&#x3D;没有用的变量&#x3D;死变量，不再使用，对应的寄存器可以释放。</strong></p>\n<p>为什么要进行活跃性分析呢？因为从Low level IR到机器码的翻译过程中，需要把有限但很多的抽象寄存器对应到物理寄存器上，也就是<strong>寄存器分配</strong>。<br>如果能识别不需要使用的变量（i.e. 不活跃变量），那么其对应的虚拟&#x2F;物理寄存器就可以被释放，再次用于分配。</p>\n<blockquote>\n<p>可以把活跃变量分析理解为一种特殊的生命周期分析，只不过除了显式的变量，还要考虑那些中间值，统称 temporaries.<br>temporaries 其实经常指的就是 IR 中的那些虚拟寄存器。</p>\n</blockquote>\n<p>活跃性分析用途：</p>\n<ul>\n<li><p>指导&#x2F;优化寄存器分配，减少寄存器使用<br>例如对于：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1: a = 1; // a lives in out[1]-&gt;in[2]</span><br><span class=\"line\">2: b = a + 2; // b lives in out[2]-&gt;in[3]</span><br><span class=\"line\">3: c = b + 3; // c lives in out[3]-&gt;in[4]</span><br><span class=\"line\">4: return c;</span><br></pre></td></tr></table></figure>\n\n<p>我们会发现他们的 <strong>活跃区间(live range)</strong> 并不重叠，可以映射到同一个物理寄存器<code>r</code>，并据此重写代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r=1;</span><br><span class=\"line\">r=r+2;</span><br><span class=\"line\">r=r+3;</span><br><span class=\"line\">return r;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>消除多余代码：例如删去未被使用的变量</p>\n</li>\n<li><p>优化 IR 生成</p>\n</li>\n<li><p>提高安全性：检查未初始化的变量</p>\n</li>\n<li><p>…</p>\n</li>\n</ul>\n<h3 id=\"活跃性分析：数据流方程\"><a href=\"#活跃性分析：数据流方程\" class=\"headerlink\" title=\"活跃性分析：数据流方程\"></a>活跃性分析：数据流方程</h3><p>首先要明确一点：不可能精确知道一个变量在某处是否活跃，所以我们要做的只是<strong>保守估计</strong>（i.e. 标记为不活跃的变量一定不活跃，但反之则不然）。<br>这是因为对于代码片段<code>int x=10; f(); return x;</code>:<br>如果能判断x是否在定义并初始化<strong>之后</strong>依旧活跃，就等于能判断<code>f()</code>是否停机。而众所周知停机问题不可判定，so sad.</p>\n<p>在本节中，我们需要分析的是活跃变量。<br>而变量在CFG上，通过有向边“流向”各个节点。<br>所以我们将通过数据流分析，找到每个节点可能会有哪些变量“流过”；换言之，找到每个节点可能会有哪些变量在其上是活跃的。</p>\n<p>一些CFG上的术语定义（可能很抽象，往后看就行）：</p>\n<ul>\n<li>node&#x2F;节点：在本文中均指只包含一个语句的</li>\n<li>out-edges: 出边，指向后继节点</li>\n<li>in-edges: 入边，来自前驱节点</li>\n<li>pred[n]: 节点<code>n</code>的前驱节点<strong>们</strong></li>\n<li>succ[n]: 节点<code>n</code>的后继节点<strong>们</strong></li>\n<li>fact: 从CFG中能推断出的一些结论&#x2F;信息&#x2F;事实，这些结论是“绑定”在有向边上的<ul>\n<li>例如现在要研究的**变量活跃性(liveness)**就是一个fact.</li>\n<li>变量是否活跃这一信息是通过这些有向边传递的。</li>\n</ul>\n</li>\n<li>in[n]: 一个集合，包含节点<code>n</code>的入边(in-edges)上的所有facts<ul>\n<li>对于本节来说，我们要求的是变量的liveness, 所以为在节点<code>n</code>内 live-in(定义见下文) 的变量。<ul>\n<li>也就是 the live-in set of node <code>n</code></li>\n<li>也就是 the variables that are live-in at node <code>n</code></li>\n<li><strong>可以简单理解为：在节点<code>n</code>中的语句执行后，哪些变量处于活跃状态，有可能在未来被用到</strong></li>\n</ul>\n</li>\n<li>稍后会详细解释该集合的含义，以及如何计算它。</li>\n</ul>\n</li>\n<li>out[n]: 一个集合，包含节点<code>n</code>的出边(out-edges)上的所有facts<ul>\n<li>对于本节来说，我们要求的是变量的liveness, 所以为在节点<code>n</code>内 live-out(定义见下文) 的变量。<ul>\n<li>也就是 the live-out set of node <code>n</code></li>\n<li>也就是 the variables that are live-out at node <code>n</code></li>\n<li><strong>可以简单理解为：在节点<code>n</code>中的代码执行前，哪些变量处于活跃状态，有可能在当前节点<code>n</code>或未来被用到</strong></li>\n</ul>\n</li>\n<li>稍后会详细解释该集合的含义，以及如何计算它。</li>\n</ul>\n</li>\n<li>transfer function: 一个函数，定义一个节点上的信息如何通过传递给另一个节点<ul>\n<li>比如稍后会得到的两个in&#x2F;out的方程（等式）</li>\n</ul>\n</li>\n<li>use: 如果一个语句的右侧(RHS)出现了变量<code>x</code>, 我们说这个语句use了<code>x</code><ul>\n<li>这意味着变量<code>x</code>中储存的值被使用了，引入了一个数据依赖。</li>\n</ul>\n</li>\n<li>use of a variable <code>x</code>: 所有use了<code>x</code>的节点集合</li>\n<li>define: 对<code>x</code>赋值即为define了<code>x</code><ul>\n<li>注意：这里的 IR 没有类似 C 语言变量定义的语句，而初次赋值其实就是一种“变量定义”，或者叫 define。</li>\n<li>为何<strong>后续</strong>再次对<code>x</code>赋值也是define？这是因为我们如果以一种比较函数式的视角来看，我们并非是“把值<code>val</code>储存到<code>x</code>中”，<strong>而是将“名字<code>x</code>绑定到值<code>val</code>上”</strong>。<br>这不难理解：我们关心的是数据之间的依赖性（数据流），<code>x</code>只是对某个值的一个指代&#x2F;一个记号&#x2F;一个名字。<br><code>x=1; x=x+1; return x;</code> 与 <code>x=1; y=x+1; return y;</code> 是完全等价的。<br>也就是说，每次对<code>x</code>的赋值都是一个“重绑定”：<strong>原来的旧<code>x</code>已经死了，新的<code>x</code>只是恰好名字也叫<code>x</code>, 但它已经是全新的一个变量了</strong>。</li>\n</ul>\n</li>\n<li>def of a variable <code>x</code>: 所有define了<code>x</code>的节点集合</li>\n<li>def of a node <code>N</code>: 节点<code>N</code>定义的变量集合</li>\n<li><code>x</code> is <strong>live on an edge</strong>: 存在一条以这条有向边(edge)开始的路径，终点指向一个use of <code>x</code>, 且中间经过的节点不包含任何def of <code>x</code><ul>\n<li>这意味着：<code>x</code>可能在之后被使用；而且在被使用前没有被重定义&#x2F;赋值过（也就是要保证数据确实可能存在依赖：那个 use 必须真的使用现在这个<code>x</code>对应的值）。</li>\n</ul>\n</li>\n<li><strong>live-in</strong>: 如果<code>x</code> live on 节点的<strong>任意一个</strong>入边，那么我们说<code>x</code> live-in 该节点</li>\n<li><strong>live-out</strong>: 如果<code>x</code> live on 节点的<strong>任意一个</strong>出边，那么我们说<code>x</code> live-out 该节点</li>\n</ul>\n<blockquote>\n<p>可以把每个节点<code>n</code>理解为一个工厂，<code>in[n]</code>是工厂需要购买的材料，<code>out[n]</code>是工厂需要提供的材料。<br>工厂有时会自己生产新的材料给下游使用（<code>def[n]</code>），有时会消耗上游提供的材料（<code>use[n]</code>），其他时候可能只是把上游的材料原封不动地转交给下游工厂（<code>in[n]</code>和<code>out[n]</code>的交集*）</p>\n<p>*严格来说不考虑重绑定，或者说静态单赋值的情况下是<code>in[n]</code>和<code>out[n]</code>的交集。<br>如果有重绑定就会有重名的情况：比如对于下图中的节点 3, 由于该节点进行了赋值操作（define）， <code>in[3]</code>中的<code>c</code>和<code>out[3]</code>中的<code>c</code>看似在交集中，但其实值已经被改变，已经是两个不同的变量了，只是“恰好”名字一样。</p>\n</blockquote>\n<p><a name=\"cfg-example\"></a></p>\n<p><img src=\"/compiler-construction-principles/cfg-example.png\" alt=\"cfg example\" loading=\"lazy\"><br>例如对于上图：</p>\n<ul>\n<li>如下信息可以直接获得：<ul>\n<li>5的出边有2条，分别指向2和6</li>\n<li>4只有一条入边，来自3</li>\n<li>pred[3]&#x3D;{2}</li>\n<li>succ[5]&#x3D;{2, 6}</li>\n<li>def(a)&#x3D;{1, 4}</li>\n<li>use(a)&#x3D;{2, 5}</li>\n<li>def(3)&#x3D;{c}</li>\n<li>use(3)&#x3D;{b, c}</li>\n</ul>\n</li>\n<li>如下信息蕴含在图中，但无法直接获得，需要进一步求解：<ul>\n<li>in[1]&#x3D;{c}, out[2]&#x3D;{a, c}</li>\n<li>in[2]&#x3D;{a, c}, out[2]&#x3D;{b, c}</li>\n<li>in[6]&#x3D;{c}, out[6]&#x3D;{}</li>\n</ul>\n</li>\n</ul>\n<p>记住：CFG 中的一个结点是一段代码，但是为了方便起见我们都假设只有一个语句在里面。所以其实你可以很简单地合并一串连续的代码（变成基本块）。<strong>我们说“执行某个节点”，指的就是执行节点里的代码。</strong></p>\n<p>接下来的重点就是找到一种方式计算in&#x2F;out集合。<br>事实上可以迭代地不断计算、更新<code>in[n]</code>以及<code>out[n]</code>, 直到他们在某次迭代后不再改变变（i.e. 到达了这个算法的<em>不动点</em>）。</p>\n<p>要计算 in[n] 与 out[n], 需要用到以下几个规则(rule)：</p>\n<ol>\n<li>If $ a \\in in[n] $, then $ \\forall m \\in pred[n], a \\in out[m] $<ul>\n<li>解释：每个前驱节点都可能是在该节点执行前的节点（我们在静态分析，无法确定到底是从何处执行到<code>n</code>的）。<br>如果某个节点<code>n</code>要求执行前<code>a</code>是活跃的，我们想要确保无论是从<code>pred[n]</code>中的哪个前驱节点跳转而来，前驱节点执行完毕时<code>a</code>都是活跃的（因为我们在做保守估计）。</li>\n</ul>\n</li>\n<li>If $ a \\in use[n] $, then $ a \\in in[n] $<ul>\n<li>解释：如果某个节点<code>n</code>直接使用了变量<code>a</code>, 那当然要求<code>a</code>在节点执行前是活跃的。</li>\n</ul>\n</li>\n<li>If $ a \\in out[n] $ and $ a \\notin def[n] $ , then $ a \\in in[n] $<ul>\n<li>解释：如果现在已知某个变量<code>a</code>必须在节点<code>n</code>执行完毕时活跃，但是<code>n</code>自己并没有定义<code>a</code>, 那显然<code>a</code>是从之前的前驱节点继承而来。<br>因此，要求<code>a</code>在节点<code>n</code>执行之前就是活跃的。</li>\n</ul>\n</li>\n</ol>\n<p>从这些规则可以导出如下两个方程（等式），<strong>可直接用于迭代计算并更新 in[n] 与 out[n]</strong> 这两个<strong>集合</strong>:</p>\n<ul>\n<li>$ in[n] &#x3D; use[n] \\cup (out[n]-def[n]) $<ul>\n<li>解释：节点<code>n</code>需要向前驱节点索取的活跃变量包括自己需要使用的<code>use</code> 并上后续别的节点需要使用的<code>out</code>. 不过如果节点自己定义了一些变量，则不需要向前驱节点索要，所以挖去<code>def</code></li>\n</ul>\n</li>\n<li>$ out[n] &#x3D; \\underset{s \\in succ[n]}{\\cup} in[s] $<ul>\n<li>解释：后继节点要什么就给什么，后继节点的总需求就是该节点<code>n</code>需要供给的活跃变量。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"解方程\"><a href=\"#解方程\" class=\"headerlink\" title=\"解方程\"></a>解方程</h3><p>应用这两个方程可以给出如下算法求解出in&#x2F;out：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for each n</span><br><span class=\"line\">  // init. to empty sets, which is a very rough approximation:</span><br><span class=\"line\">  in[n] ←&#123;&#125;; out[n] ←&#123;&#125; </span><br><span class=\"line\">repeat:</span><br><span class=\"line\">  for each n</span><br><span class=\"line\">    in&#x27;[n] ← in[n]; out&#x27;[n] ← out[n]</span><br><span class=\"line\">    </span><br><span class=\"line\">    // `⋃` stands for &quot;union&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">    // use/def is easy to obtain at the very beginning</span><br><span class=\"line\">    in[n] ← use[n] ⋃ (out[n] − def[n]) </span><br><span class=\"line\"></span><br><span class=\"line\">    out[n] ← ⋃&#123; in[s], where s in succ[n] &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">until in&#x27;[n] = in[n] and out&#x27;[n] = out[n] for all n </span><br><span class=\"line\">// i.e. until no update can be made</span><br></pre></td></tr></table></figure>\n\n<p>每次迭代中集合总会<strong>单调地</strong>变大。<br>对于刚刚的<a href=\"#cfg-example\">这个 CFG</a>, 其求解流程如下，在7步后收敛：<br><img src=\"/compiler-construction-principles/calc-liveness-forward.png\" alt=\"calc-liveness-forward\" loading=\"lazy\"></p>\n<p>似乎每一步能更新的很少。但事实上<strong>想要加速收敛的技巧就藏在<code>for each n</code>这一句中：只需要反转一下每次迭代遍历节点的顺序即可</strong>！</p>\n<p>我们原先是顺着CFG中的有向边方向进行更新（1-&gt;6, in-&gt;out）。<br>然而考虑信息在节点间的传递是通过 $ out[n] &#x3D; \\underset{s \\in succ[n]}{\\cup} in[s] $ 完成的，其方向是从后向前的。<br>所以我们可以在每次迭代中，都按照<strong>逆序</strong>（6-&gt;1, out-&gt;in）进行计算：<br><img src=\"/compiler-construction-principles/calc-liveness-backward.png\" alt=\"calc-liveness-backward\" loading=\"lazy\"></p>\n<p>只需要 3 次迭代就收敛。</p>\n<blockquote>\n<p>本质上，liveness问题是“需求决定供给”的：后续的节点有对变量的使用需求，之前的节点才可能需要提供一个活跃的变量。<br>liveness 就是一种 fact.<br>迭代更新顺序也应遵循这些 facts 的流动方向。而在活跃性分析中，liveness 反向流过这些 CFG 的有向边，并且是先影响 out 再进而影响 in.<br>因此我们迭代的过程也要遵从这一规律，使得一次迭代中，某一个 use 引入的需求能够迅速传遍整个 CFG, 而非每次只影响附近的个别结点，</p>\n<p>关于迭代方向的重要性，可以类比一下冒泡排序：如果现有数组<code>2 3 4 5 6 7 1</code>需要排序，那么可以看出<code>1</code>自然的流动方向就是从右到左。<br>冒泡排序每次迭代会按顺序检查相邻的数字并交换逆序对。<br>如果从右到左，第一次迭代就可以完成排序：<code>1</code>连续被交换，迅速“上浮”至第一的位置；<br>如果非要从左到右，那么每次迭代<code>1</code>都只能被交换一次，上浮一位，需要多达6次迭代才能完成！</p>\n</blockquote>\n<p>杂项：</p>\n<ul>\n<li>把多个相邻的节点尽可能合并为基本块可以加速。</li>\n<li>根据变量多少，视具体情况用 bitmap 或有序列表等方式储存集合可以更快。</li>\n<li>实践中也可以每次专门求解某一变量<code>x</code>的数据流（in&#x2F;out），因为大部分中间临时值的 live range 很短。</li>\n<li>这一算法最差的时间复杂度可能为 $ \\Omega (N^4)$, 其中N为节点个数。好在这一上界很难达到……</li>\n<li>算法求解的是“最小不动点”：极端情况下，你当然可以让所有变量都是live的，这也是个不动点，但不是我们想要的。</li>\n<li>进一步优化算法：可以用队列记录有可能需要被进一步更新的节点（类似BFS）。</li>\n<li>变量活跃性可以分为：<ul>\n<li>动态的dynamic liveness: 运行时判断，显然是一种under-approximation, 因为不能覆盖所有可能执行路径。</li>\n<li>静态的static liveness: 像刚刚做的一样在编译期判断，显然是一种over-approximation, 因为估计得很保守，而事实上有些路径不可能被执行到。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Part-17-寄存器分配\"><a href=\"#Part-17-寄存器分配\" class=\"headerlink\" title=\"Part 17: 寄存器分配\"></a>Part 17: 寄存器分配</h2><p>我们当然希望一切储存访问都尽可能通过寄存器完成，因为寄存器的速度远快于内存的速度。<br>之前，在 IR 中可以有任意多的虚拟寄存器，但我们在物理架构上不可能有任意多的寄存器。<br>因此他们中的一些势必要被移动到内存中。</p>\n<p><strong>寄存器分配算法的任务：</strong></p>\n<ul>\n<li>将 IR 中大量的虚拟寄存器（储存变量或者运算的中间临时结果，<strong>统称 temporaries</strong>）分配到固定数量的 k 个物理寄存器上，保证代码使用不超过 k 个寄存器</li>\n<li>使得内存访问、储存尽可能少</li>\n<li>使得内存上用于储存 spilled 值的空间尽可能小</li>\n<li>算法需要尽可能高效<ul>\n<li>典型的复杂度：O(n) 或 O(nlogn)</li>\n</ul>\n</li>\n</ul>\n<p>在工程实践中，算法的实现大致分为两种：</p>\n<ul>\n<li><strong>图染色：</strong> 效果好，但是慢<ul>\n<li>“传统派”：GCC等采用</li>\n</ul>\n</li>\n<li><strong>线性扫描：</strong> 效果也很好，接近图染色的效果；运行速度快<ul>\n<li>“维新派”：LLVM等采用</li>\n</ul>\n</li>\n</ul>\n<p>不同的分配策略：</p>\n<ul>\n<li>Naïve register allocation: 变量（广义的变量，也就是虚拟寄存器储存的 temporaries）一股脑全塞内存里！</li>\n<li>局部寄存器分配：在 basic block 里进行，无法应对跨越多个块的对寄存器的复用。</li>\n<li>全局寄存器分配：在函数内进行，经常基于<strong>图染色</strong>：<ol>\n<li>建立一个<strong>干扰图&#x2F;相交图</strong> 。<ul>\n<li>这是一个无向图，每个边都代表两端的 temporary 同时存在过，不能被分配到同一个寄存器里。我们马上会详细阐述。</li>\n</ul>\n</li>\n<li>对于 k 个<strong>物理</strong>寄存器，找到这个图的 k-coloring(k染色)：也就是边连接的相邻节点不被染为同一个颜色的情况下，用 k 种颜色染色所有节点。<ul>\n<li>如果染色成功：每种颜色对应一个物理寄存器，分配完成</li>\n<li>如果染色失败：说明这个图<strong>并非 k-colorable</strong>，需要修改代码(原文：change the code to a nearby)。<ul>\n<li>会在后文详细阐述。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"干扰图Interference-Graph\"><a href=\"#干扰图Interference-Graph\" class=\"headerlink\" title=\"干扰图Interference Graph\"></a>干扰图Interference Graph</h3><p>相交图 &#x3D; 干扰图 &#x3D; interference graph &#x3D; conflict graph</p>\n<ul>\n<li><p>如果两个虚拟寄存器<code>a</code>和<code>b</code>因为某种约束限制，使得它们<strong>无法被分配到同一个物理寄存器中</strong>，我们就说<code>a</code>与<code>b</code>之间存在 <strong>干扰(interference)</strong> ，或者说他们”interfere”。<br>这些约束包括但不限于：</p>\n<ul>\n<li>live range 有重叠（<strong>最主要的原因！</strong>）：某个时刻<code>a</code>和<code>b</code>都是活跃的，值需要得到保留，我们自然无法在同一个寄存器中同时保存<code>a</code>和<code>b</code>；</li>\n<li>产出&#x2F;使用<code>a</code>这个值的指令比较特殊，不能使用某些特定寄存器（比如<code>r1</code>），那么<code>a</code>和<code>r1</code>也 interfere 了。<ul>\n<li>读者可能会疑惑<code>r1</code>不是物理寄存器吗？其实我们不用太纠结这个：最终都是为了让图染色算法能够“感知”到有这样一个约束存在，所以大可以把物理寄存器添加到虚拟寄存器中，图只要改一改就行。<br>说到底，现在要<strong>禁止<code>a</code>染上<code>r1</code>对应的颜色</strong>：<br>试图 ban 掉某种颜色：可以在一开始就把 k 个物理寄存器加入图中，对应 k 个节点 <code>r1</code> <code>r2</code> … <code>rk</code>, 并在他们之间建立全连接（<strong>注意！更高效的做法参见后文 <em>预染色</em> 部分</strong>），<br>这将强迫图染色器为他们分配 k 种不同的颜色。<br>建立干涉图的过程中，如果<code>a</code>和<code>r1</code> interfere 了，只需要在图中连接<code>a</code>与对应的节点<code>r1</code>即可。<br><img src=\"/compiler-construction-principles/physical-interference.png\" alt=\"physical interference\" loading=\"lazy\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>节点：一个节点就是 IR 中的一个虚拟寄存器，或者说一个 temporary.</p>\n</li>\n<li><p>无向边：一条边代表一个 interference, 边连接的两个节点<strong>不能</strong>被分配到同一个物理寄存器。</p>\n</li>\n<li><p>建图步骤：基本上就是<strong>在同时存在的变量之间连边</strong>。在变量<code>t</code>被定义（赋值也是定义）时，把它和所有其他的、当前活跃(live)的变量<code>vi</code>连边 (<code>b</code>, <code>vi</code>) 即可：<br>例如对于如下程序：</p>\n<table>\n<thead>\n<tr>\n<th>Inst.</th>\n<th>Live vars</th>\n<th>Operation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td>a</td>\n<td>-</td>\n</tr>\n<tr>\n<td>b&#x3D;a+2</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>a, b</td>\n<td>link b-a</td>\n</tr>\n<tr>\n<td>c&#x3D;b*b</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>a, c</td>\n<td>link c-a</td>\n</tr>\n<tr>\n<td>b&#x3D;c+1</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>a, b</td>\n<td>link b-a (duplicated)</td>\n</tr>\n<tr>\n<td>return b*a</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p>最终得到：<br><img src=\"/compiler-construction-principles/int-graph-abc.png\" alt=\"interference graph example\" loading=\"lazy\"></p>\n<ul>\n<li><p>需要特别处理（或者说优化）涉及<code>MOVE</code>指令的情况：<br>如果通过<code>MOVE</code>执行了<code>t:=s</code>这样的移动操作，由于<code>MOVE</code>后<code>t</code>和<code>s</code>储存的值是相同的，其实暂时可以不添加 <code>(s, t)</code> 这条边，而是采用同一寄存器。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t := s (MOVE)</span><br><span class=\"line\">...</span><br><span class=\"line\">x := ... s ... (use of `s`)</span><br><span class=\"line\">...</span><br><span class=\"line\">// `t` can still be stored in the same register as `s` !</span><br><span class=\"line\">y := ... t ... (use of `t`) </span><br></pre></td></tr></table></figure>\n\n<p>换言之，此时<code>t</code>只是<code>s</code>的一个别名。<br>……直到<code>t</code>被重定义（非<code>MOVE</code>）时，如果<code>s</code>此时还 live, 才不得不添加 <code>(s, t)</code> 这条边。<br>如果最终<code>s</code>和<code>t</code>在整个分配流程后被证明确实可以使用同一个寄存器，那么这个<strong>自己拷贝到自己的<code>MOVE</code>指令会自然在生成机器码的过程中被我们优化掉</strong>。<br>这对于单静态赋值SSA这种存在大量<code>MOVE</code>的 IR 来说是一个很大的优化。</p>\n<ul>\n<li>这种关系被称为<strong>移动关联(move-related)<strong>，在干扰图中可以用</strong>虚线</strong>表示。</li>\n</ul>\n</li>\n</ul>\n<p>关于如何加边，总结如下 <strong>（有点抽象，可以直接跳过，不会有任何问题）</strong> （请记得每次赋值、每个运算指令都是一种“定义”；<code>out[n]</code>即为 live-out 集合，定义在 CFG 部分，有疑惑可以回顾一下）：</p>\n<ul>\n<li>对于定义了<code>t</code>的<strong>非<code>MOVE</code>指令</strong><code>n</code>，我们有<code>out[n]=&#123;b1, b2, ..., bj&#125;</code>, 则添加边<code>(t, b1)</code>, <code>(t, b2)</code>, …, <code>(t, bj)</code>.</li>\n<li>对于<code>MOVE</code>指令<code>n</code>, 记作<code>t:=s</code>, 有<code>out[n]=&#123;b1, b2, ..., bk&#125;</code>, 则添加上述边<code>(t, b1)</code>, <code>(t, b2)</code>, …, <code>(t, bj)</code>中的一部分。具体而言，如果这些边都记作 <code>(t, bi)</code>, 我们要求<code>bi</code>不是<code>s</code>，也不是某个<code>s</code>的别名.<br>换言之，如果<code>bi</code>是<code>s</code>或是某个<code>s</code>的别名，储存的值和<code>s</code>一样，那么现在就不需要在图上连边 <code>(t, bi)</code>.<br><a name=\"program-eg-constrained\"></a><br>例如：<table>\n<thead>\n<tr>\n<th>Inst.</th>\n<th>Live vars</th>\n<th>Operation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td>a, b</td>\n<td>link a-b (assume no aliasing)</td>\n</tr>\n<tr>\n<td>t&#x3D;a</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>a, b, t</td>\n<td>MOVE: link t-b, but not link t-a</td>\n</tr>\n<tr>\n<td>a&#x3D;a*2</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>a, b, t</td>\n<td>link a-b(dup), a-t</td>\n</tr>\n<tr>\n<td>t&#x3D;b</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>a, b, t</td>\n<td>MOVE: link t-a(dup),  but not link t-b(though linked)</td>\n</tr>\n<tr>\n<td>return a*t+b</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"图染色概述\"><a href=\"#图染色概述\" class=\"headerlink\" title=\"图染色概述\"></a>图染色概述</h3><p>vertex coloring: 对所有节点进行染色，且<strong>对于任何边，两个端点节点的颜色都不一样</strong>。<br>k染色(k-coloring): 最多使用 k 种颜色的 vertex coloring.</p>\n<p>著名的四色定理指出：对于任意 <strong>“平面图”</strong> ，至多只需要 4 种颜色即可完成染色，也就是说所有平面图都是 4-colorable 的。<br>——温馨提示：这个定理和我们的课程内容八竿子打不着边。</p>\n<p>在得到干扰图后，我们对其进行k染色。<br>染色完毕后，每一种颜色对应一个物理寄存器，节点颜色即为节点所对应的寄存器。<br>当然也有可能染色失败：这意味着需要超过k种颜色才能染色成功。<br>如果需要的颜色种数超过物理寄存器个数，说明 spilling （部分临时寄存器分配不到物理寄存器，不得不“溢出”到内存上）是必要的。</p>\n<p><strong>任务：</strong> 找到最小的 k, 使得染色可以成功。-&gt; <strong>NP-hard!</strong><br>对应的判定问题：检查图是否 k-colorable. -&gt; <strong>NP-Complete!</strong><br>所以其实并不需要找到“最小”的k，只需要“较小”的结果即可。也就是需要实现一个<strong>近似算法</strong>，以及一些启发式的想法。<br>换句话说，可以容忍找到的k不是最小的，或是误判一个事实上 k-colorable 的图无法被k染色。</p>\n<p>接下来引入一种线性时间的算法，能给出不错的结果。大体分为4个部分：</p>\n<ol>\n<li>Build: 建图（刚刚已经完成了）</li>\n<li>Simplify: 对干扰图进行<strong>简化</strong></li>\n<li>Spill: 处理被挤出的寄存器</li>\n<li>Select&#x2F;Color: 进行节点染色操作</li>\n</ol>\n<p>我们将在下文详细介绍并改进该算法。</p>\n<blockquote>\n<p>请注意：我们提到的“变量”“temporary”“虚拟寄存器”“节点”其实基本上是同一个东西。<br><strong>temporary</strong> 是更广义的变量，包含运算的中间值。IR 里的 temporary <strong>有时也用“变量”称呼</strong>。<br>在 IR 里的这些 temporary 之后要进行寄存器分配。所以现在先假设有无数虚拟的寄存器，每个 temporary 都存在一个<strong>虚拟寄存器</strong>里。<br>而干扰图上的<strong>节点</strong>就代表这些虚拟寄存器。</p>\n</blockquote>\n<h3 id=\"一个简单的图染色算法\"><a href=\"#一个简单的图染色算法\" class=\"headerlink\" title=\"一个简单的图染色算法\"></a>一个简单的图染色算法</h3><p>首先，考虑一个简化版本的、很粗糙的近似算法，用于判断图是否 k-colorable, 并给出染色方案：</p>\n<ol>\n<li>Build: 建图，已经完成了。</li>\n<li>Simplify:<ul>\n<li>如果从图<code>G</code>中存在一个节点<code>n</code>，其度数（i.e. 相邻节点数量）小于k, 令图<code>G&#39;</code>为从<code>G</code>中移除该节点得到的图。<br>那么如果<code>G&#39;</code>是 k-colorable 的，则原来的图<code>G</code>也是。<ul>\n<li>这是显然的：给定一个图<code>G&#39;</code>的k染色方案，由于相邻节点数量不够多，一定有剩余的颜色分配给<code>n</code>.<br>因此把<code>G</code>的k染色问题简化为了<code>G&#39;</code>的k染色问题。</li>\n</ul>\n</li>\n<li>这就引出<strong>一个自然的启发式的算法：</strong><br><strong>不断地从图中删除度数少于k的节点（并放入栈中）</strong>。<br>可以保证，每次删除的这个节点都有剩余的、可用的颜色分配给他。<br>如此重复删除下去，有机会直接把图简化成空图！这样就能直接宣告整个染色过程结束了。</li>\n</ul>\n</li>\n<li>Spill: 暂时留白，什么也不做。</li>\n<li>Select: 接下来要从这个空图重建原图。<strong>每次从栈顶取出一个节点，一定有剩余的、可用的颜色能用于染色。</strong><ul>\n<li>每次简化删除一个节点时，都保证如果删除后颜色够用，那么删除前颜色也够用。</li>\n<li>因此对于每次删除，有删除后的k染色方案，就能推出一个删除前的k染色方案。</li>\n<li>显然，空图是 k-colorable 的。因此如果图被删空了，我们就可以归纳地推出原图的k染色方案。</li>\n<li>显然，删除顺序的逆序&#x3D;归纳推理的顺序&#x3D;算法找到的合法的染色顺序（所以使用的是栈）。</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"/compiler-construction-principles/coloring-k2.png\" alt=\"coloring-k2\" loading=\"lazy\"><br><img src=\"/compiler-construction-principles/coloring-rebuild-k2.png\" alt=\"coloring-rebuild\" loading=\"lazy\"></p>\n<p>这个算法跑的很快（线性），但很容易误伤无辜：毕竟这只是个近似算法。<br>如果一个近似算法 fail 了，这个图事实上可能还是 k-colorable 的，只是这个算法能力不足以找到可行解。<br>对于现在这个简单的算法来说，fail 就意味着在某一步，所有节点的度数都&gt;&#x3D;k（或者说图中的节点度数都是 <strong>significant</strong> 的）.</p>\n<p>此时不得不考虑如何实现刚刚留白的第三步，也就是处理 <strong>spilling</strong>: 也就是选择图中的一些节点，把他们放在内存（而非寄存器）中。</p>\n<h3 id=\"挤出Spilling\"><a href=\"#挤出Spilling\" class=\"headerlink\" title=\"挤出Spilling\"></a>挤出Spilling</h3><p>如果上述算法在某一步无法继续下去，也就是说图中所有节点的度数都&gt;&#x3D;k, 无法继续简化。<br>这就意味着染色失败了吗？其实并不一定：<strong>相邻节点数量少于k一定能染色成功；但这不代表邻居超过k个就一定失败。</strong><br>如果相邻节点重复使用了部分颜色，那么该节点依旧可以使用剩下的。所以可以当作无事发生，继续删除该节点并压入栈中，该算法继续运行。</p>\n<p>这就是 Chaitin-Briggs 提出的<strong>乐观染色(optimistic coloring)</strong>: 如果遇到有 spill 可能的节点（i.e. 度数&gt;&#x3D;k）<code>ns</code>时，先乐观地假设它其实可以被染色成功，不会 spill, 依旧删除并压入栈中，继续该算法。<br>不过这就使得后续的 select 部分需要做出修改：</p>\n<ul>\n<li>染色成功：把<code>ns</code>弹出栈时，邻居使用的颜色种数少于 k, 有剩余的颜色分配给<code>ns</code>. 这说明刚刚作出的乐观假设确实成立，万事大吉<br><img src=\"/compiler-construction-principles/optimistic-coloring-success-before.png\" alt=\"optimistic-coloring-success-before\" loading=\"lazy\"><br><img src=\"/compiler-construction-principles/optimistic-coloring-success.png\" alt=\"optimistic-coloring-success\" loading=\"lazy\"></li>\n<li>染色失败：把<code>ns</code>弹出栈时，邻居已经使用了 k 种颜色, <code>ns</code>无法染色成功。这说明刚刚的乐观假设过度乐观了，需要进行 spill 操作<br><img src=\"/compiler-construction-principles/optimistic-coloring-failed.png\" alt=\"optimistic-coloring-failed\" loading=\"lazy\"><ul>\n<li>此时不为<code>ns</code>染色，也不终止这个算法，而是继续进行 select 直到所有像<code>ns</code>这样无法被染色成功，需要 spill 的节点都找出来。</li>\n</ul>\n</li>\n</ul>\n<p>现在，改进版的染色算法如下：</p>\n<ol>\n<li>Build: 建立干扰图。</li>\n<li>Simplify: 不断执行简化，如果找到可能 spill 的节点（度数&gt;&#x3D;k）则标记，并按照乐观染色策略继续进行，直到简化为空图。最终，我们就标记了许多无法被染色的节点。</li>\n<li>Select: 当 select 算法运行一轮后，我们会发现：<ul>\n<li>这些无法被染色的节点中的一部分确实 spilled, 需要 do actual spills, 也就是改写和这部分变量读写相关的代码，继续执行第4步↓</li>\n<li>不发生 actual spill, 染色成功！算法结束。</li>\n</ul>\n</li>\n<li>Rewrite: 改写代码，将每个 spilled 变量(actual spilled variables)移动到内存上：<ol>\n<li>为 spilled 变量<code>f</code>分配内存地址<code>fa</code>(一般在栈帧上，除非太大或者有什么别的情况)</li>\n<li>引入新的<code>fx</code>系列 temporaries: <code>f1</code> <code>f2</code> … <code>fn</code>, 用于在每次使用&#x2F;定义<code>f</code>时临时储存<code>f</code>的值。这些临时变量的 live range 较短，减少了 interference.</li>\n<li>在所有使用<code>f</code>的指令前加入<code>fx:=load fa</code>（读的时候先从内存载入）。</li>\n<li>在所有定义<code>f</code>的指令后加入<code>store fx, fa</code>（写的时候需要写进内存）。</li>\n</ol>\n</li>\n<li>使用改写后的代码，返回步骤1进行 Rebuild. 由于引入了一系列 temporaries, 需要重建干扰图。在 spilling 后，这个干扰图相比原先的会更简化，更容易被染色成功。</li>\n</ol>\n<p>这个循环一般来说只需要一到两次就能结束。<br>下面来看一个例子，假设有4个物理寄存器（i.e. k&#x3D;4）：<br><img src=\"/compiler-construction-principles/coloring-k4.png\" alt=\"coloring k4\" loading=\"lazy\"><br>图中虚线代表<code>MOVE</code>.</p>\n<p>入栈顺序：g h k d j e f b c m<br>染色：</p>\n<table>\n<thead>\n<tr>\n<th>Node</th>\n<th>Color</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>m</td>\n<td>1</td>\n</tr>\n<tr>\n<td>c</td>\n<td>3</td>\n</tr>\n<tr>\n<td>b</td>\n<td>2</td>\n</tr>\n<tr>\n<td>f</td>\n<td>2</td>\n</tr>\n<tr>\n<td>e</td>\n<td>4</td>\n</tr>\n<tr>\n<td>j</td>\n<td>3</td>\n</tr>\n<tr>\n<td>d</td>\n<td>4</td>\n</tr>\n<tr>\n<td>k</td>\n<td>1</td>\n</tr>\n<tr>\n<td>h</td>\n<td>2</td>\n</tr>\n<tr>\n<td>g</td>\n<td>4</td>\n</tr>\n</tbody></table>\n<p><img src=\"/compiler-construction-principles/coloring-k4-result.png\" alt=\"coloring-k4-result\" loading=\"lazy\"></p>\n<h3 id=\"合并Coalescing\"><a href=\"#合并Coalescing\" class=\"headerlink\" title=\"合并Coalescing\"></a>合并Coalescing</h3><p>现在要进一步改进这个算法：在 simplify 后合并部分节点。</p>\n<p>之前，我们说到对于<code>t:=s</code>这样的<code>MOVE</code>指令需要特殊处理：并不立刻为<code>(t, s)</code>, <code>(t, s1)</code>, <code>(t, s2)</code>…（其中s1, s2, … 代表目前活跃的 s 的别名，保存的值和 s 相同）这些点对添加边。因为此时 t 只是 s 的又一个别名，可以共享一个寄存器。<br>等到某个定义改变了其中一方的值，破坏了这种别名关系时，才真正连边。<br>而如果整个算法运行完毕后，发现<code>MOVE</code>指令对应的这些点对之间确实还没有边，就说明这些节点事实上可以被 <strong>合并(coalesce)</strong> 为同一个节点。<br><img src=\"/compiler-construction-principles/coalescing.png\" alt=\"coalescing\" loading=\"lazy\"></p>\n<ul>\n<li>好处👍：可能使得原图更容易染色，例如合并的这两个节点共用大部分的相邻节点<br><img src=\"/compiler-construction-principles/coalescing-pros.png\" alt=\"coalescing-pros\" loading=\"lazy\"></li>\n<li>坏处👎：可能使得原图无法染色：极端情况下，合并后的节点的度数可能是合并前两个节点度数之和！</li>\n</ul>\n<p>在此引入<strong>保守合并策略</strong>。当某些条件成立时才合并节点<code>a</code>和<code>b</code>.</p>\n<p>有如下的策略可用：</p>\n<ul>\n<li><strong>Briggs</strong>: 确保合并出的新节点<code>ab</code>的相邻节点中，<strong>significant 节点（i.e. 度数&lt;&#x3D;k的节点）</strong> 数量少于 k 个。<ul>\n<li>避免创造新的 significant 节点。</li>\n<li>这样在执行 simplify 时，<code>ab</code>相邻节点中的 non-significant 节点被去掉后，<code>ab</code>自己也成为 non-significant 节点。 因此不会降低可染色性。</li>\n</ul>\n</li>\n<li><strong>George</strong>: 对于<code>a</code>的每个相邻节点<code>t</code>, 要么<code>t</code>是 non-significant 节点，要么<code>t</code>和<code>b</code>之间本来就有 interference 边。<ul>\n<li>non-significant 的邻居会被 simplify 掉。</li>\n<li><code>(a, t)</code>与<code>(b, t)</code>合并得到新边<code>(ab, t)</code>, 不会增加任何节点的度数。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"冻结Freeze\"><a href=\"#冻结Freeze\" class=\"headerlink\" title=\"冻结Freeze\"></a>冻结Freeze</h3><p>要明确一点：<strong>合并操作是一把双刃剑</strong>。合并的不止是寄存器，还有节点对应 temporaries 的 live range. 新的节点，也就是新的 temporary 能“活更久”，对寄存器分配造成更大压力。如果因此造成了更多 spill, 那么得不偿失：与其进行内存读写，还不如不要自作主张“优化”掉<code>MOVE</code>指令。</p>\n<p>如果 simplify 和 coalesce 都无法进行，我们寻找<code>MOVE</code>指令引入的<strong>低度数</strong>节点（也就是 non-significant 节点），或者说找一些低度数的 move-related 节点。<br>我们将这些节点“冻结”，也就是去除这些节点相关的移动关联(move-related)关系，不再试图让这些节点参与合并。<br>然后就可以再次尝试 simplify 和 coalesce.</p>\n<p>可参阅：<a href=\"https://www.cnblogs.com/AANA/p/16315859.html\">图着色寄存器分配 - anna - 博客园</a></p>\n<h3 id=\"图染色总结\"><a href=\"#图染色总结\" class=\"headerlink\" title=\"图染色总结\"></a>图染色总结</h3><p>引入了一些新东西，因此算法许多部分都有些微调。<br>最终梳理一下我们的算法。包含如下几个模块↓</p>\n<ol>\n<li>Build: 建图<ul>\n<li>建立干扰图</li>\n<li>标记节点是否是移动关联(move-related)节点（i.e. <code>MOVE</code>的源&#x2F;目标）</li>\n</ul>\n</li>\n<li>Simplify: 简化图<ul>\n<li>每次去除一个 non-significant 的<strong>非</strong>移动关联节点</li>\n</ul>\n</li>\n<li>Coalesce: 合并<code>MOVE</code>引入的移动关联节点<ul>\n<li>进行保守合并，得到的新节点标记为<strong>非移动关联节点</strong>，可用于下一次 simplify</li>\n</ul>\n</li>\n<li>Freeze: 冻结部分移动关联节点，放弃合并<ul>\n<li>simplify 和 coalesce 交替进行。如果两者都无法进行，则尝试放弃合并部分 non-significant 移动关联节点。</li>\n<li>放弃合并的节点不再视为 move-related 节点</li>\n</ul>\n</li>\n<li>Spill: 处理需要挤出到内存的变量<ul>\n<li>万策尽：确实存在需要 spill 的 temporaries, 找到所有这样的一起进行 spilling</li>\n<li>Do actual spilling: 改写 IR 代码以把它们移动到内存中，重新开始整个算法。</li>\n</ul>\n</li>\n<li>Select: 不断弹栈，为出栈节点分配可用颜色，直到只剩下<strong>预染色节点</strong>（见下文）。</li>\n</ol>\n<p>全流程：<br><img src=\"/compiler-construction-principles/coloring-algo-full.png\" alt=\"coloring-algo-full\" loading=\"lazy\"><br><img src=\"/compiler-construction-principles/coloring-algo-full-book.png\" alt=\"coloring-algo-full-book\" loading=\"lazy\"></p>\n<p>图中可以看出，simplify 和 coalesce 交替进行直到图为空或无法继续后，再进行 freeze 等操作。</p>\n<p>课件上有一个很好的例子，展示了如何把一个程序在一个 3 个寄存器(2 caller-save + 1 callee-save)的机器上进行编译。<br>有条件的同学建议参阅课件： ch11. 寄存器分配 第124页。</p>\n<h3 id=\"图染色杂项\"><a href=\"#图染色杂项\" class=\"headerlink\" title=\"图染色杂项\"></a>图染色杂项</h3><ul>\n<li><p><strong>预染色(pre-colored)</strong> 节点：</p>\n<ul>\n<li><p>栈顶指针寄存器、参数寄存器等 special purposed 寄存器不是通用的。</p>\n</li>\n<li><p>可以把这些物理寄存器一一对应成虚拟寄存器，或者说为每个 special purposed 寄存器分配一个专属 temporary &#x2F; node.</p>\n</li>\n<li><p>需要通过预先染色，以告诉染色器这种一一对应的关系：</p>\n<ul>\n<li>每个 pre-colored node 的颜色是唯一的</li>\n<li>pre-colored nodes 之间互相两两 interfere （不一定需要真的全连接，也可以特殊处理）</li>\n</ul>\n</li>\n<li><p>预染色节点<strong>不能</strong>被 simplify 掉。</p>\n</li>\n<li><p>预染色节点<strong>不能</strong>被 spill 到内存上。</p>\n</li>\n<li><p>预染色节点<strong>能</strong>参与合并(coalescing).</p>\n</li>\n<li><p>普通的 temporary &#x2F; node 可以使用预染色的颜色（只要不 interfere）</p>\n<ul>\n<li>例如，calling-convention register 可以在函数里当作临时寄存器使用。使用时，这个临时值(temporary)对应的节点颜色即为 calling-convention register 对应的预染色节点的颜色</li>\n</ul>\n</li>\n<li><p>编译器前端需要保证预染色 temporary 的 live range 足够短：多多使用<code>MOVE</code><br>最佳实践：</p>\n<ul>\n<li>temporary 的 live range 如果不需要跨越某个函数调用，<strong>最好</strong>放置在 caller-save 寄存器中</li>\n<li>temporary 的 live range 如果需要跨越某个或多个函数调用，<strong>只能</strong>放置在 callee-save 寄存器中</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>受限的(constrained)节点：如果两个节点之间同时有移动关联（虚线边）又有冲突（实线边），那么需要忽略这个移动关联关系。</p>\n<ul>\n<li>某个变量被多次<code>MOVE</code>进不同的值，合并后就会这样。</li>\n<li>例如上文<a href=\"#program-eg-constrained\">这个程序</a>：<br><img src=\"/compiler-construction-principles/example-constrainted.png\" alt=\"example-constrainted\" loading=\"lazy\"><br>如果<code>a</code>和<code>t</code>合并为<code>at</code>, 就不能和<code>b</code>共用寄存器。<br>同理，如果<code>b</code>和<code>t</code>合并为<code>bt</code>, 就不能和<code>a</code>共用寄存器。</li>\n</ul>\n</li>\n<li><p>需要 spilling 时如何选择节点进行 spill 呢？优先选择：</p>\n<ul>\n<li>较少使用的 temporary ：例如在循环外的。</li>\n<li>高度数的节点：它们是“罪魁祸首”，我们应当“擒贼先擒王”。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Part-18-垃圾回收\"><a href=\"#Part-18-垃圾回收\" class=\"headerlink\" title=\"Part 18: 垃圾回收\"></a>Part 18: 垃圾回收</h2><h3 id=\"运行时Runtime\"><a href=\"#运行时Runtime\" class=\"headerlink\" title=\"运行时Runtime\"></a>运行时Runtime</h3><p>运行时 &#x3D; Runtime &#x3D; (Language) Runtime System &#x3D; 程序默认的、不在编写时描述的builtin 方法等运行时环境信息。可能有：</p>\n<ul>\n<li>POSIX 信号处理</li>\n<li>任务智能分配到多核 CPU 的不同核心</li>\n<li>虚拟机（比如 JVM）</li>\n<li><strong>智能内存管理</strong><ul>\n<li>比如：<strong>垃圾回收</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"内存管理概述\"><a href=\"#内存管理概述\" class=\"headerlink\" title=\"内存管理概述\"></a>内存管理概述</h3><ul>\n<li><strong>手动内存管理</strong>带来许多安全隐患，是最主要的漏洞来源之一。可能的问题：<ul>\n<li>内存泄漏：不再使用的内存未释放，可用内存越来越少，消耗系统资源。</li>\n<li>Double-free: 重复释放同一块内存。可能导致程序崩溃，或是被攻击者以此误导 glibc 等实现未授权的内存写入。</li>\n<li>Use-After-Free(UAF): 使用已经被释放的内存区域（例如通过悬空指针）。如果在释放后这块区域被攻击者修改了，之后再次使用时可能误导程序做出恶意行为。</li>\n</ul>\n</li>\n<li>内存管理需要平衡性能、安全以及开发难度。</li>\n<li>内存区域划分：<ul>\n<li>Static area<ul>\n<li>编译期分配</li>\n<li>全局变量、字符串字面量等</li>\n</ul>\n</li>\n<li>Runtime stack<ul>\n<li>也就是栈，储存许多栈帧 &#x2F; 活动记录(activation record)</li>\n<li>包含局部变量、函数调用返回地址等信息</li>\n</ul>\n</li>\n<li><strong>堆(heap)</strong><ul>\n<li>通过<code>malloc</code> <code>new</code> 等方式在程序中动态分配的对象</li>\n<li>如果这些对象不再使用则称之为 <strong>垃圾(garbage)</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>垃圾回收(garbage collection, GC)：自动清理不被使用的垃圾。<ul>\n<li>是运行时的一部分。</li>\n<li>在 LISP 里第一个应用。</li>\n<li>两个阶段：<ol>\n<li>garbage detection: 检测已经成为垃圾的内存对象</li>\n<li>garbage reclamation: 释放这些垃圾对象</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>理想的垃圾回收器：<ul>\n<li>安全：不会回收还没成为垃圾的对象 <strong>（必须）</strong></li>\n<li>完善(Complete)：应回收尽回收</li>\n<li>Low overhead: 时空占用小</li>\n<li>Fast: short <strong>pause time(程序为了等待垃圾回收时阻塞的时间)</strong> + 并行化</li>\n<li>简单：……现在是，幻想时间……</li>\n<li>……</li>\n</ul>\n</li>\n</ul>\n<p>如何判断一块内存<code>M</code>之后是否会被继续使用？考虑程序<code>/* here */ Call P; Use M;</code>:<br>如果能在<code>here</code>处判断<code>M</code>是否会被继续使用，就意味着能判定<code>P</code>是否停机……这是个<strong>不可判定问题！</strong></p>\n<p>因此，我们需要再次使用<strong>保守估计</strong>的策略，只回收那些确信是垃圾的对象，确保垃圾回收器是安全的。<br>我们通过判断内存对象的<strong>可达性(reachability)<strong>来找出哪些对象可以 &#x2F; 无法通过指针，或是指针链访问到。</strong>不可达的对象一定不可用。</strong></p>\n<p>接下来的任务：使用某种方式获取内存对象的可达性信息。方法：</p>\n<ul>\n<li>引用计数Reference Count: 统计每个内存单元被引用的次数<ul>\n<li>直接追踪哪些内存单元是活跃的。</li>\n<li>分配堆上空间时，GC 介入。</li>\n<li>无法检测所有垃圾。</li>\n</ul>\n</li>\n<li>Tracing<ul>\n<li>当分配堆上空间<strong>失败时</strong>，GC 介入并检测活跃的内存单元。</li>\n<li>Mark-sweep</li>\n<li>Copy-collection</li>\n</ul>\n</li>\n<li>其他现代方法：generational GC 等。</li>\n</ul>\n<p>接下来我们会详细讨论这些方法。</p>\n<h3 id=\"基础数据结构：有向图\"><a href=\"#基础数据结构：有向图\" class=\"headerlink\" title=\"基础数据结构：有向图\"></a>基础数据结构：有向图</h3><p>对象间的引用关系构成一个有向图。</p>\n<ul>\n<li>点：<ul>\n<li><strong>变量&#x2F;寄存器</strong>：在图中是一些指向内存对象的 <strong>“根节点”</strong>。</li>\n<li>内存对象（例如一个 struct &#x2F; record）：被指向，也可能指向其他内存对象。</li>\n</ul>\n</li>\n<li>有向边：指针，<code>a</code>储存了指向<code>b</code>的指针，则对应一条有向边<code>a-&gt;b</code></li>\n</ul>\n<p><img src=\"/compiler-construction-principles/directed-graph.png\" alt=\"directed-graph\" loading=\"lazy\"></p>\n<p>在图上，我们可以更好地描述可达性：</p>\n<ul>\n<li>无法从任一“根节点”<code>r</code>出发，通过一条链<code>r-&gt;a-&gt;b-&gt;c-&gt;...-&gt;x</code>到达的内存对象<code>x</code>，就是不可达的对象。</li>\n<li>例如，如果内存对象<code>x</code>的入度为0, 则<code>x</code>一定不可达（但反之不然）。</li>\n</ul>\n<h3 id=\"Mark-and-Sweep\"><a href=\"#Mark-and-Sweep\" class=\"headerlink\" title=\"Mark-and-Sweep\"></a>Mark-and-Sweep</h3><p>一种朴素的垃圾回收方式。有如下两步：</p>\n<ol>\n<li>Mark: 从各个根节点出发，搜索并标记能到达的全部节点。</li>\n<li>Sweep: 线性扫描整个堆，把未被标记的节点（不可达节点）链接到 <strong>freelist</strong> 中, 最后清除标记。</li>\n</ol>\n<p><img src=\"/compiler-construction-principles/graph-marks.png\" alt=\"graph-marks\" loading=\"lazy\"><br>图中蓝色的节点即为<strong>未</strong>被标记的节点。<br>图中的<code>·</code>即为变量或是 record 中的字段。如有出边，则代表它是个指针，指向一个 record.</p>\n<p><strong>freelist</strong>: 储存所有可用的(free)内存块，<strong>是一个链表</strong>。程序开始运行，没有进行任何堆内存分配时，这个链表自然包含了程序内存中的所有块。</p>\n<p>当程序需要在堆上分配一个 record 时，从 freelist 中取出一块。<br>如果此时 freelist 空了或是不足以满足 record 的空间需求，则重新进行一次 Mark-and-Sweep 尝试找到垃圾并回收入 freelist, 然后再分配.<br>如果找不到任何垃圾回收，或是回收后 freelist 仍空间不足，则分配失败。</p>\n<p>Mark-and-Sweep 方案的代价分析：</p>\n<ul>\n<li>H: 堆的总块数</li>\n<li>R: 可达的数据块数</li>\n<li>时间花费：<ul>\n<li>Mark: 遍历可达对象，代价为 $ c_1 R $.</li>\n<li>Sweep: 遍历整个堆，代价为 $ c_2 H $.</li>\n<li>填充 freelist, 大小变为 H-R:<ul>\n<li>长期来看，分配对象数&#x3D;回收对象数。</li>\n<li>摊还后的代价 &#x3D; 单次代价&#x2F;回收对象数 &#x3D; $ (c_1 R + c_2 H)&#x2F;(H-R) $.</li>\n<li>如果堆一直接近满（H接近R），则时间花费极大！</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>该方案的问题与改进：</p>\n<ul>\n<li>问题：遍历可达对象时如果直接 DFS, 在极端情况下容易递归过深爆栈。<ul>\n<li>解决方法：使用显式的栈(explicit stack)进行 DFS: 手动模拟一个栈，初始时压入所有 roots; 每次弹出栈顶节点<code>t</code>，标记<code>t</code>, 把<code>t</code>指向的所有节点压入栈中；重复执行直到栈空。</li>\n</ul>\n</li>\n<li>问题：即使如此，栈的大小太大了<ul>\n<li>解决方法：<strong>Deutsch-Schorr-Waite (DSW) pointer reversal</strong><ul>\n<li><p>不使用显式的栈，而是复用图中的元素（节点与边），<strong>把栈“放在”图中：在图中用指针串起来一连串节点，也可以充当栈！</strong><br>当搜索某个节点（也就是内存中的一个对象，或者说 record）<code>x</code>时：</p>\n<ol>\n<li>标记<code>x</code>.</li>\n<li>如果发现有<code>x</code>的某个 field <code>x.fi</code> 储存了一个指针，并且指向一个未标记的子节点<code>y</code>：临时篡改<code>x.fi</code>,让它指向<code>x</code>的父节点<code>t</code>: <code>y:=x.fi; x.fi:= t</code>.<br><img src=\"/compiler-construction-principles/modify-pointer.png\" alt=\"modify-pointer\" loading=\"lazy\"></li>\n<li>递归地，搜索、标记子节点<code>y</code>(对应地更新<code>t:= x; x:= y</code>)。</li>\n<li>搜索完毕后，退回父节点(对应地更新<code>y:= x; x:= t; t:= x.fi</code>)，然后恢复这个被临时篡改的指针：<code>x.fi:= y</code>。</li>\n</ol>\n</li>\n<li><p>伪代码如下：<br><img src=\"/compiler-construction-principles/pointer-reversal.png\" alt=\"pointer-reversal\" loading=\"lazy\"></p>\n<ul>\n<li>对所有变量（“根节点”）<code>v</code>执行<code>DFS(v)</code></li>\n<li><code># of ...</code> &#x3D; <code>the number of ...</code></li>\n<li><code>x</code>: 全局指针，指向当前处理的节点</li>\n<li><code>t</code>: 全局指针，指向当前处理节点的“父节点”</li>\n<li><code>y</code>: <code>x</code>的某个子节点</li>\n<li><code>done[r]</code>: 记录<code>r</code>这个 record 中,已被检查&#x2F;搜索过的 fields 是那些。例如若<code>done[r]=3</code>:<ul>\n<li>说明<code>r.f0</code> <code>r.f1</code> <code>r.f2</code>已经被处理过，现在下一个要处理的子节点是 <code>r.f3</code> (如果<code>r.f3</code>是指针)。</li>\n<li>之后，如果<code>r.f3</code>指向子节点，搜索前篡改<code>r.f3</code>为<code>t</code>.</li>\n<li>最后，如果子节点搜索处理完毕回退到<code>r</code>, 程序就可以知道需要恢复的、之前被篡改的 field 就是<code>r.f3</code>.</li>\n</ul>\n</li>\n</ul>\n<p>课件示例拼接：<br><img src=\"/compiler-construction-principles/pointer-reversal-example.png\" alt=\"pointer-reversal-example\" loading=\"lazy\"></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>Mark-and-Sweep 总结：</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"addition\">+ 垃圾数量较少时很高效</span></span><br><span class=\"line\"><span class=\"addition\">+ 可以回收循环引用（A-&gt;B-&gt;C-&gt;A...）</span></span><br><span class=\"line\"><span class=\"addition\">+ 对象在内存中不需要移动，也就是其位置不需要更改（有时影响程序正确性：参考隔壁 Rust 的 std::pin）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"deletion\">- 垃圾数量多时很低效</span></span><br><span class=\"line\"><span class=\"deletion\">- GC 过程会阻塞程序运行，程序必须暂停以回收垃圾</span></span><br><span class=\"line\"><span class=\"deletion\">- 容易导致堆的碎片化，尤其是会产生许多内存（外部）碎片</span></span><br></pre></td></tr></table></figure>\n\n<p>关于 <strong>内存碎片</strong> 这一概念，我们会在该部分的最后进行说明。</p>\n<h3 id=\"引用计数Reference-Count\"><a href=\"#引用计数Reference-Count\" class=\"headerlink\" title=\"引用计数Reference Count\"></a>引用计数Reference Count</h3><p><em>&gt;&gt;&gt;To be continued…</em></p>\n<h3 id=\"Copying-Collection\"><a href=\"#Copying-Collection\" class=\"headerlink\" title=\"Copying Collection\"></a>Copying Collection</h3><p><em>&gt;&gt;&gt;To be continued…</em></p>\n<h3 id=\"垃圾回收：编译器相关接口-机制\"><a href=\"#垃圾回收：编译器相关接口-机制\" class=\"headerlink\" title=\"垃圾回收：编译器相关接口&#x2F;机制\"></a>垃圾回收：编译器相关接口&#x2F;机制</h3><p><em>&gt;&gt;&gt;To be continued…</em></p>\n<h3 id=\"杂项\"><a href=\"#杂项\" class=\"headerlink\" title=\"杂项\"></a>杂项</h3><ul>\n<li><p>内存碎片：意味着浪费了内存中的空间，内存不是“最密堆积”的。<br>有两种内存碎片：</p>\n<ul>\n<li>外部碎片(external fragmentation): 当程序要求分配一块内存时，尽管堆中看起来可用空间足够，但由于这些可用空间零散、碎片化地分布在各个位置，成为了外部碎片，我们找不到足够大的一段连续内存分配给程序，分配失败。<br><img src=\"/compiler-construction-principles/external-fragment.png\" alt=\"external-fragment\" loading=\"lazy\"></li>\n<li>内部碎片(internal fragmentation): 当程序要求分配一块内存时，由于地址对齐等原因，内存管理管理器可能返回一块比要求的更大的内存，用不完的部分即为内部碎片，将不可避免地被浪费。<br><img src=\"/compiler-construction-principles/internal-fragment.png\" alt=\"internal-fragment\" loading=\"lazy\"></li>\n</ul>\n</li>\n<li><p>内存分配方式：</p>\n<ul>\n<li>Linear allocation: <img src=\"/compiler-construction-principles/linear-alloc.png\" alt=\"linear\" loading=\"lazy\"></li>\n<li>Freelist allocation: <img src=\"/compiler-construction-principles/freelist-alloc.png\" alt=\"freelist\" loading=\"lazy\"></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Part-19-面向对象-OOP\"><a href=\"#Part-19-面向对象-OOP\" class=\"headerlink\" title=\"Part 19: 面向对象(OOP)\"></a>Part 19: 面向对象(OOP)</h2><p><em>&gt;&gt;&gt;To be continued…</em></p>\n<h2 id=\"Part-20-循环优化\"><a href=\"#Part-20-循环优化\" class=\"headerlink\" title=\"Part 20: 循环优化\"></a>Part 20: 循环优化</h2>",
            "tags": [
                "On Going",
                "Compiler",
                "Computer Science"
            ]
        }
    ]
}