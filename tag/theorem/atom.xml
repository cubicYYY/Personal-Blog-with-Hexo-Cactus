<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://cubicy.icu</id>
    <title>Cubic Y³ • Posts by &#34;theorem&#34; tag</title>
    <link href="http://cubicy.icu" />
    <updated>2024-04-07T18:38:20.000Z</updated>
    <category term="Misc" />
    <category term="Write-Up" />
    <category term="出题" />
    <category term="CISCN" />
    <category term="web" />
    <category term="Hackergame" />
    <category term="SchoolBus" />
    <category term="Rust" />
    <category term="Lifetime" />
    <category term="Code" />
    <category term="ProgrammingLanguage" />
    <category term="冰菓" />
    <category term="古籍研究社" />
    <category term="Treap" />
    <category term="BST" />
    <category term="图论" />
    <category term="Kruskal" />
    <category term="Stack" />
    <category term="Splay" />
    <category term="数链剖分" />
    <category term="持久化" />
    <category term="线段树" />
    <category term="树状数组" />
    <category term="LCA" />
    <category term="分块" />
    <category term="哈希" />
    <category term="Phar" />
    <category term="反序列化" />
    <category term="PHP" />
    <category term="Math" />
    <category term="Translation" />
    <category term="Theorem" />
    <entry>
        <id>http://cubicy.icu/yoneda/</id>
        <title>[译]Tai-Danae Bradley: 米田视角→米田嵌入→米田引理</title>
        <link rel="alternate" href="http://cubicy.icu/yoneda/"/>
        <content type="html">&lt;h1 id=&#34;米田视角-→-米田嵌入-→-米田引理&#34;&gt;&lt;a href=&#34;#米田视角-→-米田嵌入-→-米田引理&#34; class=&#34;headerlink&#34; title=&#34;米田视角 → 米田嵌入 → 米田引理&#34;&gt;&lt;/a&gt;米田视角 → 米田嵌入 → 米田引理&lt;/h1&gt;&lt;p&gt;&lt;em&gt;注：本标题为译者将三篇文章合而为一后添加。&lt;/em&gt;&lt;br&gt;原作者： &lt;a href=&#34;https://www.math3ma.com/about&#34;&gt;Tai-Danae Bradley&lt;/a&gt;&lt;br&gt;部分图片与启发来源：&lt;a href=&#34;https://bartoszmilewski.com/2015/09/01/the-yoneda-lemma/trackback/&#34;&gt;Bartosz Milewski&lt;/a&gt;&lt;br&gt;强烈建议读一读！↑&lt;/p&gt;
&lt;h2 id=&#34;译者序&#34;&gt;&lt;a href=&#34;#译者序&#34; class=&#34;headerlink&#34; title=&#34;译者序&#34;&gt;&lt;/a&gt;&lt;a name=&#34;prelude&#34;&gt;&lt;/a&gt;译者序&lt;/h2&gt;&lt;p&gt;米田引理(Yoneda Lemma)往往是新手在学习范畴论时遇到的第一个大障碍，犹如五十音图之于日语初学者。然而就译者本人看来，其难度并非来自于思维上的复杂，而更多来自于符号滥用（让人不禁想问数学整个领域是不是都这样）。尽管一些概念嵌套层数过多对思考确实造成了阻碍，但是通过优秀而无歧义的符号与生动的图示可以大大降低心智负担。本系列作者在这两点上都做得十分出色，故产生了想译为中文的想法。尽管如此，我仍然推荐读者阅读原文，或者至少尽量使用英文的术语以减少歧义。&lt;/p&gt;
&lt;p&gt;为了消除歧义，将本文使用的范畴论记号与称呼列举在此：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(TODO)&lt;/li&gt;
&lt;li&gt;co-Yoneda 引理&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里有几条锦囊也许能帮你快速抓住核心，如有错漏欢迎指出！如果在重新阅读时有迷路的感觉（尤其是第三部分），不知文章行文脉络时，不妨试着阅读一番，&lt;strong&gt;如果是初次阅读就请跳过吧&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;笔者认为，对于Yoneda引理（更准确的说，是推论 1）最精炼的总结是：“人是一切社会关系的总和。”&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;blockquote&gt;
&lt;p&gt;你在一个粒子加速器工作。你想要理解某个粒子，你所能做的就是将其他粒子甩到它上面，看看会发生什么。如果你了解你的神秘粒子对所有可能的测试粒子种类以及所有可能的测试能量大小是如何做出响应的，那么你就已经知道关于你的神秘粒子的一切了。&lt;br&gt;You work at a particle accelerator. You want to understand some particle. All you can do is throw other particles at it and see what happens. If you understand how your mystery particle responds to all possible test particles at all possible test energies, then you know everything there is to know about your mystery particle.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;熟悉群论的读者可能会想到凯莱定理(Caylay’s theorem)，也即所有群 G 同构于在 G 上的对称群(即 Sym(G))的子群。事实上，可以认为这个定理是米田引理的一个特例。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在群作用语言下的等效表述：如果群作用子 $\sigma_g: G\rightarrow \text{Aut}_{\text{set}}(S)$ (也就是每个元素对应到一个自同构上)是单射的（也就是单同态），群作用 $G\times S\rightarrow S$在某个集合 S（S 可以来自 G 本身）上是忠实的&lt;/li&gt;
&lt;li&gt;为什么&lt;strong&gt;这样的&lt;/strong&gt;群作用是忠实的(faithful)？只需要关注单位元在集合 S 中对应的元素 u：此时在不同的自同构下 u 一定被发送(send)到不同元素上。（参见&lt;a href=&#34;https://www.youtube.com/watch?v=sNX3txN9zc4&amp;&#34;&gt;Chapter 7: Group actions, symmetric group and Cayley’s theorem | Essence of Group Theory&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;接下来你会看到米田引理证明过程中也是通过关注恒等映射这样的“单位元”被发送至何处（这单位元其实如同一个“凝结核”，确定了其被发送至何方后将引发连锁反应，使得所有其他对象的去向被一一确定，后文会详细阐述），从而得出米田嵌入的忠实性。这不是巧合。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于程序员，可以这么理解：任何数据类型 T 都可以被一个函数 f 所取代。f 接受一个T的“处理器”handler（这个handler会把T转成目标类型） 并执行其余计算——即是续延（Continuation）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Haskell表述： &lt;code&gt;forall x . (t -&amp;gt; x) -&amp;gt; F x ≅ F t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;一种&lt;a href=&#34;https://bartoszmilewski.com/2015/09/01/the-yoneda-lemma/trackback/&#34;&gt;来自Bartosz Milewski的理解&lt;/a&gt;：我们可以把函子看成一种广义的容器（参见：&lt;a href=&#34;https://bartoszmilewski.com/2014/01/14/functors-are-containers/trackback/&#34;&gt;Functors are Containers&lt;/a&gt;），所以左边就是把t转成x，然后变成F x这一步只是把x装起来变成可以装x类型的容器而已（我们并不关心这个F对x做了什么，我们关心的是“F对x的确做了些什么”这个事实本身）。假设容器一开始只能装x类型的，但是如果对所有可能的类型x，有handler: t-&amp;gt;x可以转化成一个装有x类型的容器，那么这个容器事实上就是可以装t类型的。&lt;/li&gt;
&lt;li&gt;如果不把&lt;code&gt;F x&lt;/code&gt;看作容器，而是看成类型构造器，那么可以这么解释：基于t构造新类型的实质，就是需要从每个t类型值构造新的F t类型值（所以在这种视角下，没有具体的转换细节，我们只知道有一个新类型F t带来新的关系，这些新的关系从旧关系导出）。对任意可能的类型x，每个t类型值都对应一种自己的&lt;em&gt;转换方式&lt;/em&gt;，使得各个handler: t-&amp;gt;x（某种意义上是关系）分别转化为一个值v，v的类型是基于x构造的新类型F x。 &lt;strong&gt;或者说，每个类型x都可以要求一个能把t值转化为x值的handler，而后用构造器F构造新类型时，就可以从handler这些旧有关系导出新类型F t与其他新类型F x之间的新关系；因为这些handler把类型t的运算细节“包办”了。&lt;/strong&gt; 对于任意类型x，任意的handler都有这种&lt;em&gt;转换方式&lt;/em&gt;（共同构成每个x的自然变换）。因此，应用类型构造器F时，类型t的每个值都会指导形如(t-&amp;gt;…)的handler该如何转换为(F t-&amp;gt;F…)，而这些自然变换构成了t类型存在的全部意义。所有和t有关的运算都可以视为一种类型构造，因此类型t的意义只有在运算中才会得到显现，一个不参与运算（不构造新类型）的类型没有任何存在价值，这符合直觉。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分别取定F和A，会发现Yoneda引理这个同构关系对于F、t都是自然同构（参见&lt;a href=&#34;https://www.bilibili.com/video/BV1AN4y1V7mH&#34;&gt;【范畴论】第5讲，Yoneda引理&lt;/a&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每日更新！&lt;/p&gt;
&lt;h2 id=&#34;1-x2F-3：米田视角-The-Yoneda-Perspective&#34;&gt;&lt;a href=&#34;#1-x2F-3：米田视角-The-Yoneda-Perspective&#34; class=&#34;headerlink&#34; title=&#34;1&amp;#x2F;3：米田视角(The Yoneda Perspective)&#34;&gt;&lt;/a&gt;&lt;a name=&#34;1&#34;&gt;&lt;/a&gt;1&amp;#x2F;3：米田视角(The Yoneda Perspective)&lt;/h2&gt;&lt;p&gt;&lt;em&gt;本节翻译自 &lt;a href=&#34;https://www.math3ma.com/blog/the-yoneda-perspective&#34;&gt;https://www.math3ma.com/blog/the-yoneda-perspective&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://blog.sigfpe.com/2006/11/yoneda-lemma.html?m=1&#34;&gt;Dan Piponi&lt;/a&gt; 说这是“数学中最难的 trivial 玩意”；&lt;a href=&#34;https://ncatlab.org/nlab/show/Yoneda+lemma&#34;&gt;nLab&lt;/a&gt; 对它的看法是“初等的，深刻的，核心的”；而 &lt;a href=&#34;http://www.math.jhu.edu/~eriehl/context.pdf&#34;&gt;Emily Riehl&lt;/a&gt; 则将其提名为“可以说是范畴论中最重要的结果”。然而，正如 &lt;a href=&#34;http://www.maths.ed.ac.uk/~tl/categories/yoneda.ps&#34;&gt;Tom Leinster&lt;/a&gt; 所指出的，“许多人觉得它非常令人困惑。”&lt;br&gt;他们谈论的是什么？&lt;br&gt;&lt;strong&gt;正是米田引理(Yoneda lemma)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/yoneda/yoneda.jpg&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;“但……”你问道，“米田引理是啥？如果它还只是一个引理，那么……天哪……定理是什么？”&lt;/p&gt;
&lt;p&gt;在回答问题之前，我想通过“悠闲地漫步”(leisurely stroll)于其中的两个推论来诱导出这个结果。实际上，话说在前头，我没有在范畴学领域的任何部分“漫步”的资质（译者注：作者的自谦）。的确，有资格为我们展示 Yoneda 引理（译者注：后文我们均如此称呼，因为更常用）这颗闪闪发光的精切钻石的，按理说是范畴学家们，而我不是范畴学家（译者注：依然是作者的自谦）。不过，我就是喜欢跟你讲述一些我所喜欢的事物，而Yoneda引理正是我喜欢的。因此，我们还是于此处相遇了！&lt;/p&gt;
&lt;p&gt;现在我可以选择简单地告诉你推论在我眼里的样子，也可以选择简单地把引理甩给你。但正如 &lt;a href=&#34;http://www.math.csi.cuny.edu/~maher/&#34;&gt;Joseph Maher&lt;/a&gt; 曾经说过的那样：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数学是喜剧的反面，是反笑话(anti-joke)*。我们先告诉你笑点，然后费力地向你解释为什么这个笑点是对的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以，首先我要告诉你们一个笑点——关于 Yoneda 引理两个推论的总结。&lt;a href=&#34;http://www.math3ma.com/mathema/2016/10/6/the-sierpinski-space-and-its-special-property&#34;&gt;我之前在这个博客上提到过它&lt;/a&gt;，但我在这个系列中的目标是将它锚定在一个更正规严谨的数学基础上——也就是在费力地解释为什么它是正确的笑点。它是这样一个概念：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数学对象完全由它们与其他对象的关系所决定。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;让我们称其为&lt;em&gt;Yoneda视角&lt;/em&gt;。简而言之，它表明，如果你想理解对象（集合、群、拓扑空间等等），那么用&lt;a href=&#34;http://www.math.harvard.edu/~mazur/preprints/when_is_one.pdf&#34;&gt;Barry Mazur&lt;/a&gt;的话来说，你会想要理解“它们与同类的、所有其他对象之间的关系网络”。我们已经在几篇帖子中探讨了这个观念——&lt;a href=&#34;http://www.math3ma.com/mathema/2016/9/12/the-most-obvious-secret-in-mathematics&#34;&gt;The Most Obvious Secret in Mathematics&lt;/a&gt;和&lt;a href=&#34;http://www.math3ma.com/mathema/2016/10/6/the-sierpinski-space-and-its-special-property&#34;&gt;The Sierpinski Space and its Special Property&lt;/a&gt;——所以我就不在这里详细展开了。（如果你还没有看过，请务必去看一看！你可以认为这些帖子是本文的前传。）但是我想提一下，Yoneda 视角激发了一种观点，一些数学家——而且这个博客**也越来越多地采纳了这种观点，也即&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数学对象的性质比它的定义更重要。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么要采用这种观点？因为脱口而出背诵定义很容易：笛卡尔乘积是 blabla…，集合生成的自由群是 blabla…，商拓扑是 blabla…但定义并不总是能说明一切。积是天然带有向内或向外的映射的吗？如果一个自由群的生成集位于另一个群内，这两个群在某种程度上存在联系吗？商空间上的连续函数是什么样子的？这些问题都探询对象的属性——而正是属性定义了对象特征。一旦我们拓宽视角，从对象所存在的范畴这一视角检视对象，答案就会水落石出。&lt;/p&gt;
&lt;p&gt;我想表达的是什么呢？&lt;/p&gt;
&lt;p&gt;假设你想探索对象 X 的性质。现在想象一下，把自己带入另一个对象 Y 的视角。然后问：“从 Y 的视点(vantage point)看起来，X 是什么样的？” 然后现在走到另一个对象 Z 旁，同样设身身处地问：“现在呢？从 Z 这里看，X 是什么样？”一直这么做下去，直到你站在范畴中每个对象的角度都剖析了 X 一遍。最后，你就会收集到大量关于 X 的信息。&lt;/p&gt;
&lt;p&gt;就像&lt;a href=&#34;https://www.youtube.com/watch?v=vwF7AHTQaoc&#34;&gt;这个片段&lt;/a&gt;。从一侧看，片段里的这座雕塑像一头大象；从另一个角度看，它又看起来像两只长颈鹿。但这两个角度都没有给出对雕塑完整的描述。为了真正理解这座雕塑，我们应该从所有可能的视点来观看它。范畴理论也有同样的观点：更多的视点提供了更多的信息。注意，划重点：Yoneda 引理说明：‍&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;所有&lt;/strong&gt;的视点会给出&lt;strong&gt;所有&lt;/strong&gt;的信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这就是上述 Yoneda 视角的本质，也是思维清晰的数学家如此重视态射、交换图、普遍性质等的原因之一。（不知道你注意到了吗？）这都是关于关系的！当然，这只是一种直觉。实际数学形式是什么样的？那两个推论是什么？我所说的“…物体完全被…决定”究竟是什么意思？什么是“两个物体之间的关系”？我们如何看待“范畴中&lt;em&gt;所有对象的视点&lt;/em&gt;”？Yoneda 引理&lt;em&gt;具体&lt;/em&gt;是如何捕捉到这一点的？&lt;/p&gt;
&lt;p&gt;这些是我们&lt;a href=&#34;#2&#34;&gt;下周&lt;/a&gt;要回答的问题。&lt;br&gt;顺带一提，想复习一下范畴论吗？这里有几个地方可以起步：&lt;br&gt;&lt;a href=&#34;http://www.math3ma.com/mathema/2017/1/17/what-is-category-theory-anyway&#34;&gt;What is Category Theory, Anyway?&lt;/a&gt;&lt;br&gt;&lt;a href=&#34;http://www.math3ma.com/mathema/2017/1/23/what-is-a-category&#34;&gt;What’s a Category?&lt;/a&gt;&lt;br&gt;&lt;a href=&#34;http://www.math3ma.com/mathema/2017/1/31/what-is-a-functor-part-1&#34;&gt;What’s a Functor?&lt;/a&gt;&lt;br&gt;&lt;a href=&#34;http://www.math3ma.com/mathema/2017/2/6/what-is-a-natural-transformation&#34;&gt;What’s a Natural Transformation?&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;*: 所以数学家是 cocomedian? (那&lt;a href=&#34;https://www.instagram.com/p/BLwhFLFgTbE/?taken-by=math3ma&#34;&gt;comathematician&lt;/a&gt;是什么?)（译者注：co-这一词根前缀在范畴论中被大量应用，用来表达对偶的、相反的等意味。难道说，这可以说明 coconut 其实就是 nut？）&lt;br&gt;**: 参见 &lt;a href=&#34;http://www.math3ma.com/mathema/2017/1/17/what-is-category-theory-anyway&#34;&gt;Exhibit A&lt;/a&gt; 和 &lt;a href=&#34;http://www.math3ma.com/mathema/2016/9/12/the-most-obvious-secret-in-mathematics&#34;&gt;Exhibit B&lt;/a&gt; 和 &lt;a href=&#34;http://www.math3ma.com/mathema/2016/10/6/the-sierpinski-space-and-its-special-property&#34;&gt;Exhibit C&lt;/a&gt; 和 &lt;a href=&#34;https://twitter.com/math3ma/status/894700378792611840&#34;&gt;Exhibit D&lt;/a&gt; 和 &lt;a href=&#34;http://www.math3ma.com/mathema/2017/2/22/crumbs&#34;&gt;Exhibit E&lt;/a&gt;, 作为例证&lt;/p&gt;
&lt;h2 id=&#34;2-x2F-3：米田嵌入-The-Yoneda-Embedding&#34;&gt;&lt;a href=&#34;#2-x2F-3：米田嵌入-The-Yoneda-Embedding&#34; class=&#34;headerlink&#34; title=&#34;2&amp;#x2F;3：米田嵌入(The Yoneda Embedding)&#34;&gt;&lt;/a&gt;2&amp;#x2F;3：&lt;a name=&#34;2&#34;&gt;&lt;/a&gt;米田嵌入(The Yoneda Embedding)&lt;/h2&gt;&lt;p&gt;&lt;em&gt;本节翻译自 &lt;a href=&#34;https://www.math3ma.com/blog/the-yoneda-embedding&#34;&gt;https://www.math3ma.com/blog/the-yoneda-embedding&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;#1&#34;&gt;上周&lt;/a&gt;我们开始探讨Yoneda引理。然而，我们并没有直接陈述Yoneda引理本身（因为缺乏动机），而是“悠闲地漫步”于其推论之一———Yoneda视角，也就是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个对象完全由其与其他对象的“关系”确定，&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从范畴中的每个对象的视角看，对象是什么“样子”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但这让我们不禁想问，“实际数学形式是什么样的？那两个推论是什么推论？”在这篇文章中，我们会尽量找出答案。首先，让我们将这三个抽象叙述背后的具体数学概念具体化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“…两个对象之间的&lt;em&gt;关系&lt;/em&gt;…”&lt;/li&gt;
&lt;li&gt;“…范畴中&lt;em&gt;每个对象的视点&lt;/em&gt;…”&lt;/li&gt;
&lt;li&gt;“…一个对象&lt;em&gt;完全&lt;/em&gt;由…&lt;em&gt;表征(characterized)&lt;/em&gt;…”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们将逐一解密这些叙述方式。接下来，设 Set 表示集合范畴，C 为任意范畴。&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;“两个对象之间的关系”是指一个态射(morphism)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假如在 C 中，两个对象 X 和 Y 它们之间存在一个态射，那么我们就说他们“存在关系”。例如，如果X是一个具有&lt;a href=&#34;http://www.math3ma.com/the-back-pocket/2016/8/26/comparing-topologies&#34;&gt;离散拓扑&lt;/a&gt;的拓扑空间，那么从 X 到 Y 就有很多关系——也就是有很多从 X 到 Y 的连续函数——对于任何空间Y。事实上，从一个离散空间出发的&lt;em&gt;所有&lt;/em&gt;映射都是连续的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/yoneda/discrete.jpg&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;而反观域范畴，其中的对象之间的关系就非常少了——因为在不同特征(characteristics)的域之间不存在域同态！&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;“…范畴中&lt;em&gt;每个对象的视点&lt;/em&gt;…” 编码在一个函子(functor)中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要“从 C 中所有对象的视点”分析一个对象 X ，我们需要一种方法来跟踪 X 与 C 中所有对象的关系网。这个“关系网”指的就是所有&lt;em&gt;从Z到X&lt;/em&gt;和&lt;em&gt;从X到Z&lt;/em&gt;的态射集合，也就是这些集合：&lt;br&gt;$$\text{hom}(Z,X)\ 与\ \text{hom}(X,Z)\ ,对于范畴\textbf{C}中的任意对象Z.$$&lt;br&gt;注意到，我们希望C中的&lt;em&gt;每个&lt;/em&gt;Z都对应一个不同的集合。一个可行的办法是通过&lt;a href=&#34;https://www.math3ma.com/blog/what-is-a-functor-part-2&#34;&gt;反变函子(contravariant functor)&lt;/a&gt; $\text{hom}(-,X): \textbf{C}^{op}\rightarrow \textbf{Set}$，它将Z发送到集合$\text{hom}(Z,X)$，并将态射$f:Z\rightarrow W$发送到其&lt;a href=&#34;https://www.math3ma.com/blog/the-sierpinski-space-and-its-special-property&#34;&gt;拉回(pullback)&lt;/a&gt; $f^*$，$f^*$则定义为“与f前复合(precomposing)”这一操作（译者注：前复合、后复合的解释参见&lt;a href=&#34;https://math.stackexchange.com/questions/3889401/what-are-post-composition-and-pre-composition-in-category-theory&#34;&gt;What are post-composition and pre-composition in category theory?&lt;/a&gt;，同时请注意区分 $f^*$ 与 $f_*$ 这两个记号以免混淆前复合与后复合）。类似的，对于C中的所有Z，集合$\text{hom}(X,Z)$都在&lt;a href=&#34;https://www.math3ma.com/blog/what-is-a-functor-part-1&#34;&gt;协变函子&lt;/a&gt; $\text{hom}(X,-):\textbf{C}\rightarrow\textbf{Set}$的像(image)中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/yoneda/network.jpg&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;“一个对象‘完全由…确定’”意味着你知道它是在同构的意义下等价(up to isomorphism)的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说“一个对象X完全由…确定”意味着X&lt;a href=&#34;https://www.math3ma.com/blog/up-to-isomorphism&#34;&gt;在同构的意义下&lt;/a&gt;是唯一由省略号处内容所表征的对象。比如在本节第一段中，省略号处对应的是“它们与其他对象的关系”。（尽管通常来说省略号处是一个&lt;a href=&#34;https://jeremykun.com/2013/05/24/universal-properties/&#34;&gt;普适性质&lt;/a&gt;。这不足为奇。根据&lt;a href=&#34;#1&#34;&gt;Yoneda视角&lt;/a&gt;，这两种填空是大差不差的！（译者注：确实不知道怎么翻译该句”the two addendums go hand in hand”，此处的两种addendums可能指的是追加在省略号处的可以是“对象带有的普适性质”，也可以是上文的“对象与其他对象的关系”，而这两种答案本质上是一样的））重点在于，如果Y与X以&lt;em&gt;相同&lt;/em&gt;的方式与C中的&lt;em&gt;所有&lt;/em&gt;其他对象联系——也就是说，如果从整个范畴的视点看，Y看起来就像X一样——那么X和Y一定是同构的。&lt;/p&gt;
&lt;p&gt;例如，假设X和Y是拓扑空间，令$\cdot$表示单点空间，$I$和$S^1$表示单位区间和圆。那么我们有，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;X和Y具有相同的势(cardinality)当且仅当 $\text{hom}(\bullet,X) \cong \text{hom}(\bullet,Y)$&lt;/li&gt;
&lt;li&gt;X和Y具有相同的路径空间(path space)当且仅当 $\text{hom}(I,X) \cong \text{hom}(I,Y)$&lt;/li&gt;
&lt;li&gt;X和Y具有相同的（自由）&lt;a href=&#34;https://en.wikipedia.org/wiki/Loop_space&#34;&gt;环空间(loop space)&lt;/a&gt;当且仅当 $\text{hom}(S^1,X) \cong \text{hom}(S^1,Y)$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/yoneda/probe.jpg&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;根据路径空间和环空间的定义，后两点成立。（它们分别是从$I$和$S^1$到$X$的所有连续函数的空间。）而至于第一点，只是因为一个形如$\bullet \to X$的映射其实就是在$X$中选择一个点。我们甚至可以说$\bullet \to X$是$X$的一个“$\bullet$塑造的元素”。类似地，一个路径$I \to X$可以被看作是$X$的一个“$I$塑造的元素”，而一个环$S^1 \to X$则是一个“$S^1$塑造的元素。” 本质上，我们使用$\bullet$、$I$和$S^1$来探测(probe)$X$和$Y$。为了洞悉全貌，我们必须用&lt;em&gt;所有&lt;/em&gt;空间探测它们——也即从&lt;em&gt;所有&lt;/em&gt;空间的视点观察它们。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在确立这些数学形式之后，“一个对象X完全由X与其他对象的关系所确定”这个说法现在可以明确为两个要点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;要点 #1.&lt;/strong&gt; 关于X的一切我们需要知道的东西都被编码在$\text{hom}(-,X)$中。实际上，对象X&lt;strong&gt;表示&lt;/strong&gt;了函子$\text{hom}(-,X)$。&lt;br&gt;&lt;strong&gt;要点 #2.&lt;/strong&gt; 当且仅当它们所表示的函子$\text{hom}(-,X)$和$\text{hom}(-,Y)$同构时，X和Y才是同构的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们现在先考虑第一点，之后再重新审视第二点。所以我们真的能够像第一点说的那样用一个函子来确定一个对象吗？显然存在一个指派&lt;br&gt;$$X \mapsto \text{hom}(-, X)$$&lt;br&gt;这是因为范畴 $\textbf{C}$ 中的任何对象 $X$ 都对应于一个函子 $\text{hom}(-,X)$，那么这个函子存在于… 呃… 在哪呢？$\text{hom}(-,X)$ 位于哪里？它也存在于一个范畴中！正如我们很久以前提到的，存在一个范畴 $\textbf{Set}^{ \textbf{C}^{op} }$ ，它的对象是从 $\textbf{C}^{op}$ 到 $\textbf{Set}$ 的函子，而其态射是自然变换。因此，存在一个函子 $\mathscr{Y}: \textbf{C} \rightarrow \textbf{Set}^{ \textbf{C}^{op} }$，它将对象 $X$ 映射到 $\text{hom}(-, X)$，将一个态射 $f: X \rightarrow Y$ 映射到自然变换 $f^*: \text{hom}(-, X) \rightarrow \text{hom}(-, Y)$（你应该可以自己验证）。这个自然变换的每个分量都是通过与 $f$ 后合成(postcomposing)得到的。在范畴 $\textbf{Set}^{ \textbf{C}^{op} }$ 中的函子被称为预层(presheaf)，我们感兴趣的预层，即形式为 $\text{hom}(-,X)$ 的预层，被称为&lt;strong&gt;可表示函子&lt;/strong&gt;(representable functors)。但是我们需要证明这个命名是否合理： $X$ 真正地、忠实地且最大限度地&lt;em&gt;表示&lt;/em&gt;函子 $\text{hom}(-, X)$ 吗？&lt;/p&gt;
&lt;p&gt;答案是肯定的，但有一个条件：当 $\mathscr{Y}$ 将 $X$ 发送到预层范畴时，它必须&lt;em&gt;保留&lt;/em&gt; $X$ 与 $\textbf{C}$ 中对象之间的关系。换句话说，对于 $X$ 和 $Y$ 之间的每个关系，应恰好存在&lt;em&gt;一个&lt;/em&gt;关系（自然变换）在$\text{hom}(-, X)$ 和 $\text{hom}(-, Y)$ 之间。更正式地说，对于 $\textbf{C}$ 中的每对 $X$ 和 $Y$，由 $f \mapsto f_*$ 定义的函数&lt;br&gt;$$\text{hom}(X, Y) \rightarrow \textbf{Nat}(\text{hom}(-, X), \text{hom}(-, Y))$$&lt;br&gt;应该是一个双射。（记号 $\textbf{Nat}(-,-)$ 表示从 [留空] 到 [留空] 的自然变换集合（译者注：留空的意思是这里可以是任意 $-$ 处填入的对象）） 。如果 $\mathscr{Y}$ 满足这个条件，则称其为全忠实(fully faithful)*的并且被称它将范畴 $\textbf{C}$ &lt;strong&gt;嵌入&lt;/strong&gt;到 $Set^{C^{op}}$ 中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/yoneda/embed.jpg&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;但问题来了：&lt;/p&gt;
&lt;p&gt;将 $f$ 映射到 $f_*$ 的函数&lt;br&gt;$$\text{hom}(X, Y) \rightarrow \textbf{Nat}(\text{hom}(-, X), \text{hom}(-, Y))$$&lt;br&gt;真的是一个双射吗？&lt;/p&gt;
&lt;p&gt;单射性是显然的：如果 $f, g: X \rightarrow Y$ 是不同的态射，则它们的推出(pushforward) $f_*$ 和 $g_*$ 显然是不同的。但，满射性呢？给定任意的自然变换 $\eta: \text{hom}(-, X) \rightarrow \text{hom}(-, Y)$，是否存在一个态射 $f: X \rightarrow Y$ 使得 $\eta &amp;#x3D; f_*$？也就是说，&lt;br&gt;&lt;strong&gt;&lt;em&gt;每个&lt;/em&gt;可表示函子之间的自然变换是否都来自于表示了它们的对象之间的态射？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可能存在大量的自然变换 $\text{hom}(-, X)$ 和 $\text{hom}(-, Y)$！没有什么好理由去指望其中的每个都来自于一个 $X \rightarrow Y$ 的态射。&lt;/p&gt;
&lt;p&gt;然而，出人意料的，还真是！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;真就是这样的！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于每个自然变换 $\eta: \text{hom}(-, X) \rightarrow \text{hom}(-, Y)$，存在唯一的态射 $f: X \rightarrow Y$，使得 $\eta &amp;#x3D; f^*$。&lt;/p&gt;
&lt;p&gt;而&lt;strong&gt;这&lt;/strong&gt;正是Yoneda引理直接导出的。&lt;/p&gt;
&lt;p&gt;结果是，$\mathscr{Y}$ 将 $\textbf{C}$ 全忠实地嵌入到 $\textbf{Set}^{ \textbf{C}^{op} }$ 中。（这是上面提到的“要点 #1”的形式化表述。）因此，$\mathscr{Y}$ 被称为&lt;strong&gt;Yoneda嵌入&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;但是，态射 $X \rightarrow Y$ 与自然变换 $\text{hom}(-, X) \rightarrow \text{hom}(-, Y)$ 之间是双射的这一事实仅仅是Yoneda引理导出的一个&lt;em&gt;结果&lt;/em&gt;。正如我们&lt;a href=&#34;#3&#34;&gt;下周&lt;/a&gt;将看到的，Yoneda引理其实是一个更强的结论！它是关于&lt;strong&gt;任意&lt;/strong&gt;函子 $F: \textbf{C}^{op} \rightarrow \textbf{Set}$ 的自然变换 $\text{hom}(-, X) \rightarrow F$ 的结论。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;* 更一般地，对于任意函子 $F: \textbf{C} \rightarrow \textbf{D}$，存在一个函数 $\text{hom}&lt;em&gt;{\textbf{C} }(X, Y) \rightarrow \text{hom}&lt;/em&gt;{\textbf{D} }(F(X), F(Y))$，由 $f \mapsto F(f)$ 给出。如果这个映射是单射，我们说 $F$ 忠实(faithful)；如果它是满射，我们说 $F$ 全射(full)；如果它是双射，我们说 $F$ 全忠实(fully faithful)（译者注：相当于此时我们只关心态射在F作用下的变化情况）。以下是一个方便的&lt;a href=&#34;http://www.math3ma.com/mathema/2017/7/30/naming-functors&#34;&gt;表格&lt;/a&gt;，用于命名其他类型的函子。&lt;/p&gt;
&lt;p&gt;(译者注：方便起见将这个有趣的表格直接附在此处↓)&lt;br&gt;&lt;img src=&#34;/yoneda/naming.jpg&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-x2F-3：米田引理-The-Yoneda-Lemma&#34;&gt;&lt;a href=&#34;#3-x2F-3：米田引理-The-Yoneda-Lemma&#34; class=&#34;headerlink&#34; title=&#34;3&amp;#x2F;3：米田引理(The Yoneda Lemma)&#34;&gt;&lt;/a&gt;3&amp;#x2F;3：&lt;a name=&#34;3&#34;&gt;&lt;/a&gt;米田引理(The Yoneda Lemma)&lt;/h2&gt;&lt;p&gt;&lt;em&gt;本节翻译自 &lt;a href=&#34;https://www.math3ma.com/blog/the-yoneda-lemma&#34;&gt;https://www.math3ma.com/blog/the-yoneda-lemma&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;未完待续&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;译后记&#34;&gt;&lt;a href=&#34;#译后记&#34; class=&#34;headerlink&#34; title=&#34;译后记 &#34;&gt;&lt;/a&gt;译后记 &lt;a name=&#34;postlude&#34;&gt;&lt;/a&gt;&lt;/h2&gt;</content>
        <category term="Math" />
        <category term="Translation" />
        <category term="Theorem" />
        <updated>2024-04-07T18:38:20.000Z</updated>
    </entry>
</feed>
